var tipuesearch = {"pages":[{"title":" Forgex—Fortran Regular Expression ","text":"Forgex—Fortran Regular Expression Forgex—Fortran Regular Expression—is a regular expression engine written entirely in Fortran. This project is managed by Fortran Package Manager (FPM) , providing basic processing of regular expression, and as a freely available under the MIT license.\nThe engine's core algorithm uses a deterministic finite automaton (DFA) approach. This choice have been focused on runtime performance. Features Metacharacter | Vertical bar for alternation, * Asterisk, match zero or more, + Plus, match one or more, ? Question, match zero or one, \\ escape metacharacter, . match any character. Character class character class [a-z] inverted character class [&#94;a-z] character class on UTF-8 codeset [α-ωぁ-ん] Note that inverted class does not match the control characters. Range of repetition {num} , {,max} , {min,} , {min, max} ,\nwhere num and max must NOT be zero. Anchor &#94; , matches the beginning of a line $ , matches the end of a line Shorthand \\t , tab character \\n , new line character (LF or CRLF) \\r , return character (CR) \\s , blank character (white space, TAB, CR, LF, FF, \"Zenkaku\" space U+3000) \\S , non-blank character \\w , ( [a-zA-Z0-9_] ) \\W , ( [&#94;a-zA-Z0-9_] ) \\d , digit character ( [0-9] ) \\D , non-digit character ( [&#94;0-9] ) Documentation The documentation is available in English and Japanese at https://shinobuamasaki.github.io/forgex . Usage Build Operation has been confirmed with the following compilers: GNU Fortran ( gfortran ) v13.2.1 Intel Fortran Compiler ( ifx ) 2024.0.0 20231017 It is assumed that you will use the Fortran Package Manager( fpm ). First of all, add the following to your project's fpm.toml : [dependencies] forgex = { git = \"https://github.com/shinobuamasaki/forgex\" } APIs When you write use forgex at the header on your program, .in. and .match. operators, regex subroutine, and regex_f function are introduced. program main use :: forgex implicit none The .in. operator returns true if the pattern is contained in the string. block character (:), allocatable :: pattern , str pattern = 'foo(bar|baz)' str = \"foobarbaz\" print * , pattern . in . str ! T str = \"foofoo\" print * , pattern . in . str ! F end block The .match. operator returns true if the pattern exactly matches the string. block character (:), allocatable :: pattern , str pattern = '\\d{3}-\\d{4}' str = '100-0001' print * , pattern . match . str ! T str = '1234567' print * , pattern . match . str ! F end block The regex is a subroutine that returns the substring of a string that matches pattern as intent(out) argument. block character (:), allocatable :: pattern , str , res integer :: length pattern = 'foo(bar|baz)' str = 'foobarbaz' call regex ( pattern , str , res ) print * , res ! foobar ! call regex(pattern, str, res, length) ! the value 6 stored in optional `length` variable. end block By using the from / to arugments, you can extract substrings from the given string. block character (:), allocatable :: pattern , str , res integer :: from , to pattern = '[d-f]{3}' str = 'abcdefghi' call regex ( pattern , str , res , from = from , to = to ) print * , res ! def ! The `from` and `to` variables store the indices of the start and end points ! of the matched part of the string `str`, respectively. ! Cut out before the matched part. print * , str ( 1 : from - 1 ) ! abc ! Cut out the matched part that equivalent to the result argument of the `regex` subrouine. print * , str ( from : to ) ! def ! Cut out after the matched part. print * , str ( to + 1 : len ( str )) ! ghi end block The interface of regex subroutine is following: interface regex module procedure :: subroutine__regex end interface pure subroutine subroutine__regex ( pattern , text , res , length , from , to ) implicit none character ( * ), intent ( in ) :: pattern , text character (:), allocatable , intent ( inout ) :: res integer , optional , intent ( inout ) :: length , from , to If you want to the matched character string as the return value of the function,\nconsider using regex_f defined in the forgex module. interface regex_f module procedure :: function__regex end interface regex_f pure function function__regex ( pattern , text ) result ( res ) implicit none character ( * ), intent ( in ) :: pattern , text character (:), allocatable :: res UTF-8 String matching UTF-8 string can be matched using regular expression patterns just like ASCII strings.\nThe following example demonstrates matching Chinese characters.\nIn this example, the length variable stores the byte length, and in this case there 10 3-byte characters, so the length is 30. block character (:), allocatable :: pattern , str integer :: length pattern = \"夢.{1,7}胡蝶\" str = \"昔者莊周夢爲胡蝶　栩栩然胡蝶也\" print * , pattern . in . str ! T call regex ( pattern , str , res , length ) print * , res ! 夢爲胡蝶　栩栩然胡蝶 print * , length ! 30 (is 3-byte * 10 characters) end block Command Line Interface Tool Version 3.2 introduces a command line tool that is called forgex-cli and uses the Forgex engine for debugging, testing, and benchmarking regex matches. It performs matching with commands such as the one shown in below, and outputs the results directly to standard output. For detailed information, please refer to the documentation. Command: forgex-cli find match lazy-dfa '([a-z]*g+)n?' .match. 'assign' If you run it through fpm run : fpm run forgex-cli --profile release -- find match lazy-dfa '([a-z]*g+)n?' .match. 'assign' Output: pattern: ([ a - z ] * g + ) n ? text: ' assign ' parse time : 46.5 us compile nfa time : 74.9 us dfa initialize time : 78.4 us search time : 661.7 us matching result: T memory ( estimated ) : 10380 ========== Thompson NFA =========== state 1 : ( ? , 5 ) state 2 : < Accepted > state 3 : ( n , 2 )( ? , 2 ) state 4 : ( g , 7 ) state 5 : ([ \"a\" - \"f\" ], 6 )( g , 6 )([ \"h\" - \"m\" ], 6 )( n , 6 )([ \"o\" - \"z\" ], 6 )( ? , 4 ) state 6 : ( ? , 5 ) state 7 : ( ? , 8 ) state 8 : ( g , 9 )( ? , 3 ) state 9 : ( ? , 8 ) =============== DFA =============== 1 : [ \"a\" - \"f\" ] => 2 2 : [ \"o\" - \"z\" ] => 2 [ \"h\" - \"m\" ] => 2 g => 3 3 A: n => 4 4 A: state 1 = ( 1 4 5 ) state 2 = ( 4 5 6 ) state 3 A = ( 2 3 4 5 6 7 8 ) state 4 A = ( 2 4 5 6 ) =================================== Notes A program built by gfortran on Windows and macOC may crash if an allocatable character is used in an OpenMP parallel block. If you use the command line tool with PowerShell on Windows, use UTF-8 as your system locale to properly input and output Unicode characters. To do Add Unicode escape sequence \\p{...} Deal with invalid byte strings in UTF-8 ✅️ Optimize by literal searching method ✅️ Add a CLI tool for debugging and benchmarking ✅️ Make all operators pure elemental attribute ✅️ Publish the documentation ✅️ Support UTF-8 basic feature ✅️ Construct DFA on-the-fly ✅️ Support CMake building Parallelize on matching Code Convention All code contained herein shall be written with a three-space indentation. Acknowledgements For the algorithm of the power set construction method and syntax analysis, I referred to Russ Cox's article and Yoshiyuki Kondo's book.\nThe implementation of the priority queue was based on the code written by ue1221 .\nThe idea of applying the .in. operator to strings was inspired by kazulagi's one.\nThe command-line interface design of forgex-cli was inspired in part by the package regex-cli of Rust language. References Russ Cox \"Regular Expression Matching Can Be Simple And Fast\" , 2007 近藤嘉雪 (Yoshiyuki Kondo), \"定本 Cプログラマのためのアルゴリズムとデータ構造\", 1998, SB Creative. ue1221/fortran-utilities Haruka Tomobe (kazulagi), https://github.com/kazulagi , his article in Japanese rust-lang/regex/regex-cli License Forgex is as a freely available under the MIT license. See LICENSE . Developer Info Amasaki Shinobu","tags":"home","loc":"index.html"},{"title":"arg_element_t – Forgex—Fortran Regular Expression ","text":"type, public :: arg_element_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: v Source Code type , public :: arg_element_t character (:), allocatable :: v end type arg_element_t","tags":"","loc":"type/arg_element_t.html"},{"title":"arg_t – Forgex—Fortran Regular Expression ","text":"type, public :: arg_t Components Type Visibility Attributes Name Initial type( arg_element_t ), public, allocatable :: arg (:) integer, public :: argc character(len=:), public, allocatable :: entire Source Code type , public :: arg_t integer :: argc type ( arg_element_t ), allocatable :: arg (:) character (:), allocatable :: entire end type arg_t","tags":"","loc":"type/arg_t.html"},{"title":"cmd_t – Forgex—Fortran Regular Expression ","text":"type, public :: cmd_t Components Type Visibility Attributes Name Initial character(len=LEN_CMD), public, allocatable :: subc (:) character(len=LEN_CMD), private :: name = '' Type-Bound Procedures procedure, public :: get_name => cmd__get_name private pure function cmd__get_name (self) result(res) Arguments Type Intent Optional Attributes Name class( cmd_t ), intent(in) :: self Return Value character(len=:), allocatable procedure, public :: set_name => cmd__set_name private pure subroutine cmd__set_name (self, name) Arguments Type Intent Optional Attributes Name class( cmd_t ), intent(inout) :: self character(len=*), intent(in) :: name Source Code type , public :: cmd_t ! command type character ( LEN_CMD ), private :: name = '' character ( LEN_CMD ), allocatable :: subc (:) ! sub-command contains procedure :: get_name => cmd__get_name procedure :: set_name => cmd__set_name end type cmd_t","tags":"","loc":"type/cmd_t.html"},{"title":"flag_t – Forgex—Fortran Regular Expression ","text":"type, public :: flag_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_f character(len=32), public :: name character(len=:), public, allocatable :: short_f Source Code type , public :: flag_t character ( 32 ) :: name character (:), allocatable :: long_f , short_f end type flag_t","tags":"","loc":"type/flag_t.html"},{"title":"pattern_t – Forgex—Fortran Regular Expression ","text":"type, public :: pattern_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: p Source Code type , public :: pattern_t character (:), allocatable :: p end type pattern_t","tags":"","loc":"type/pattern_t.html"},{"title":"cla_t – Forgex—Fortran Regular Expression ","text":"type, public :: cla_t Components Type Visibility Attributes Name Initial type( arg_t ), public :: arg_info type( cmd_t ), public :: cmd integer, public :: flag_idx (NUM_FLAGS) logical, public :: flags (NUM_FLAGS) type( pattern_t ), public, allocatable :: patterns (:) type( cmd_t ), public :: sub_cmd type( cmd_t ), public :: sub_sub_cmd Type-Bound Procedures procedure, public :: collect_flags => cla__collect_flags private  subroutine cla__collect_flags (cla) Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: do_debug => cla__do_debug_subc private  subroutine cla__do_debug_subc (cla) Processes the debug command, reads a subcommand, and calls the corresponding procedure. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: do_find => cla__do_find_subc private  subroutine cla__do_find_subc (cla) Processes the debug command, reads a subcommand and a sub-subcommand,\nand calls the corresponding procedure. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: get_patterns => cla__get_patterns private  subroutine cla__get_patterns (cla, offset) Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla integer, intent(in) :: offset procedure, public :: init => cla__initialize private  subroutine cla__initialize (cla) Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: init_debug => cla__init_debug_subc private  subroutine cla__init_debug_subc (cla) Prepare subcommands for the debug command. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: init_find => cla__init_find_subc private  subroutine cla__init_find_subc (cla) Prepare subcommands for the find command. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: init_find_match => cla__init_find_match_subsubc private  subroutine cla__init_find_match_subsubc (cla) Prepare sub-subcommands for the match subcommand. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: read_cmd => cla__read_command private  subroutine cla__read_command (cla) Read the first argument and match it with registered commands. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: read_subc => cla__read_subcommand private  subroutine cla__read_subcommand (cla) Read the second argument and match it with registered subcommands. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: read_subsubc => cla__read_sub_subcommand private  subroutine cla__read_sub_subcommand (cla) Read the third argument and match it with registered sub-subcommands. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code type , public :: cla_t type ( arg_t ) :: arg_info type ( cmd_t ) :: cmd , sub_cmd , sub_sub_cmd type ( pattern_t ), allocatable :: patterns (:) logical :: flags ( NUM_FLAGS ) integer :: flag_idx ( NUM_FLAGS ) contains procedure :: init => cla__initialize procedure :: read_cmd => cla__read_command procedure :: read_subc => cla__read_subcommand procedure :: read_subsubc => cla__read_sub_subcommand procedure :: collect_flags => cla__collect_flags procedure :: get_patterns => cla__get_patterns procedure :: init_debug => cla__init_debug_subc procedure :: init_find => cla__init_find_subc procedure :: init_find_match => cla__init_find_match_subsubc procedure :: do_debug => cla__do_debug_subc procedure :: do_find => cla__do_find_subc end type cla_t","tags":"","loc":"type/cla_t.html"},{"title":"get_lap_time_in_appropriate_unit – Forgex—Fortran Regular Expression","text":"public  function get_lap_time_in_appropriate_unit(lap_time) result(res) This function takes a real number of seconds, converts it to the appropriate\nunits, and returns a string with the unit for output. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: lap_time Return Value character(len=NUM_DIGIT_TIME) Source Code function get_lap_time_in_appropriate_unit ( lap_time ) result ( res ) implicit none real ( real64 ), intent ( in ) :: lap_time character ( NUM_DIGIT_TIME ) :: res character ( 3 ) :: unit real ( real64 ) :: multiplied unit = 's' if ( lap_time >= 6 d1 ) then unit = 'm' multiplied = lap_time / 6 d1 else if ( lap_time >= 1 d0 ) then unit = 's' multiplied = lap_time else if ( lap_time >= 1 d - 3 ) then unit = 'ms' multiplied = lap_time * 1 d3 else if ( lap_time >= 1 d - 6 ) then if ( get_os_type () == OS_WINDOWS ) then unit = 'us' else unit = 'μs' end if multiplied = lap_time * 1 d6 else unit = 'ns' multiplied = lap_time * 1 d9 end if write ( res , '(f10.1, a)' ) multiplied , unit end function get_lap_time_in_appropriate_unit","tags":"","loc":"proc/get_lap_time_in_appropriate_unit.html"},{"title":"time_lap – Forgex—Fortran Regular Expression","text":"public  function time_lap() result(res) This function is for timing purposes and returns the lap time\nsince the last call of time_begin or time_lap . Arguments None Return Value real(kind=real64) Source Code function time_lap () result ( res ) implicit none real ( real64 ) :: res if ( get_os_type () == OS_WINDOWS ) then if ( is_supported ) then is_succeeded = QueryPerformanceCounter ( time_end_qhc ) res = dble ( time_end_qhc - time_begin_qhc ) / dble ( frequency ) time_begin_qhc = time_end_qhc else !$ end_s = omp_get_wtime() !$ res = end_s - last_s !$ last_s = end_s !$ return call use_cpu_time_end end if else !$ end_s = omp_get_wtime() !$ res = end_s - last_s !$ last_s = end_s !$ return call use_cpu_time_end end if contains subroutine use_cpu_time_end implicit none call cpu_time ( end_s ) res = end_s - last_s last_s = end_s end subroutine use_cpu_time_end end function time_lap","tags":"","loc":"proc/time_lap.html"},{"title":"time_begin – Forgex—Fortran Regular Expression","text":"public  subroutine time_begin() This subroutine is for timing purpose and starts a stopwatch. Arguments None Source Code subroutine time_begin () implicit none if ( get_os_type () == OS_WINDOWS ) then is_supported = QueryPerformanceFrequency ( frequency ) if ( is_supported ) then is_succeeded = QueryPerformanceCounter ( time_begin_qhc ) else !$ begin_s = omp_get_wtime() !$ last_s = begin_s !$ return call use_cpu_time_begin end if else !$ begin_s = omp_get_wtime() !$ last_s = begin_s !$ return call use_cpu_time_begin end if contains subroutine use_cpu_time_begin implicit none begin_s = 0 d0 last_s = 0 d0 end_s = 0 d0 call cpu_time ( begin_s ) last_s = begin_s end subroutine use_cpu_time_begin end subroutine time_begin","tags":"","loc":"proc/time_begin.html"},{"title":"QueryPerformanceCounter – Forgex—Fortran Regular Expression","text":"interface For Windows, use high-resolution system call for timing. private  function QueryPerformanceCounter(PerformanceCount_count) result(is_succeeded_c) bind(c, name=\"QueryPerformanceCounter\") Arguments Type Intent Optional Attributes Name integer(kind=c_long_long), intent(out) :: PerformanceCount_count Return Value logical(kind=c_bool)","tags":"","loc":"interface/queryperformancecounter.html"},{"title":"QueryPerformanceFrequency – Forgex—Fortran Regular Expression","text":"interface For Windows, use high-resolution system call for timing. private  function QueryPerformanceFrequency(Frequency_countPerSec) result(is_supported_c) bind(c, name=\"QueryPerformanceFrequency\") Arguments Type Intent Optional Attributes Name integer(kind=c_long_long), intent(out) :: Frequency_countPerSec Return Value logical(kind=c_bool)","tags":"","loc":"interface/queryperformancefrequency.html"},{"title":"do_find_match_dense_dfa – Forgex—Fortran Regular Expression","text":"public  subroutine do_find_match_dense_dfa(flags, pattern, text, is_exactly) Uses forgex_cli_memory_calculation_m forgex_nfa_state_set_m forgex_dense_dfa_m forgex_utility_m forgex_cli_utils_m forgex_automaton_m forgex_cli_time_measurement_m forgex_syntax_tree_graph_m Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern character(len=*), intent(in) :: text logical, intent(in) :: is_exactly Source Code subroutine do_find_match_dense_dfa ( flags , pattern , text , is_exactly ) use :: forgex_automaton_m use :: forgex_syntax_tree_graph_m use :: forgex_cli_memory_calculation_m use :: forgex_cli_time_measurement_m use :: forgex_dense_dfa_m use :: forgex_nfa_state_set_m use :: forgex_cli_utils_m use :: forgex_utility_m implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern character ( * ), intent ( in ) :: text logical , intent ( in ) :: is_exactly type ( tree_t ) :: tree type ( automaton_t ) :: automaton integer :: uni , ierr , i character (:), allocatable :: dfa_for_print character ( 256 ) :: line real ( real64 ) :: lap1 , lap2 , lap3 , lap4 , lap5 logical :: res integer :: from , to from = 0 to = 0 if ( flags ( FLAG_HELP ) . or . pattern == '' ) call print_help_find_match_dense_dfa if ( flags ( FLAG_NO_LITERAL )) call info ( \"No literal search optimization is implemented in dense DFA.\" ) call time_begin () ! call build_syntax_tree(trim(pattern), tape, tree, root) call tree % build ( trim ( pattern )) lap1 = time_lap () call automaton % preprocess ( tree ) lap2 = time_lap () ! build nfa call automaton % init () lap3 = time_lap () ! automaton initialize call construct_dense_dfa ( automaton , automaton % initial_index ) lap4 = time_lap () ! compile nfa to dfa if ( is_exactly ) then res = match_dense_dfa_exactly ( automaton , text ) if ( res ) then from = 1 to = len ( text ) end if else block call match_dense_dfa_including ( automaton , char ( 10 ) // text // char ( 10 ), from , to ) if ( is_there_caret_at_the_top ( pattern )) then from = from else from = from - 1 end if if ( is_there_dollar_at_the_end ( pattern )) then to = to - 2 else to = to - 1 end if if ( from > 0 . and . to > 0 ) then res = . true . else res = . false . end if end block end if lap5 = time_lap () ! search time open ( newunit = uni , status = 'scratch' ) write ( uni , fmta ) HEADER_NFA call automaton % nfa % print ( uni , automaton % nfa_exit ) write ( uni , fmta ) HEADER_DFA call automaton % print_dfa ( uni ) rewind ( uni ) ierr = 0 dfa_for_print = '' do while ( ierr == 0 ) read ( uni , fmta , iostat = ierr ) line if ( ierr /= 0 ) exit if ( get_os_type () == OS_WINDOWS ) then dfa_for_print = dfa_for_print // trim ( line ) // CRLF else dfa_for_print = dfa_for_print // trim ( line ) // LF end if end do close ( uni ) output : block character ( NUM_DIGIT_KEY ) :: pattern_key , text_key character ( NUM_DIGIT_KEY ) :: parse_time , nfa_time , dfa_init_time , dfa_compile_time , matching_time character ( NUM_DIGIT_KEY ) :: memory character ( NUM_DIGIT_KEY ) :: tree_count , nfa_count , dfa_count character ( NUM_DIGIT_KEY ) :: matching_result character ( NUM_DIGIT_KEY ) :: cbuff ( 12 ) = '' integer :: memsiz pattern_key = \"pattern:\" text_key = \"text:\" parse_time = \"parse time:\" nfa_time = \"compile nfa time:\" dfa_init_time = \"dfa initialize time:\" dfa_compile_time = \"compile dfa time:\" matching_time = \"search time:\" memory = \"memory (estimated):\" matching_result = \"matching result:\" tree_count = \"tree node count:\" nfa_count = \"nfa states:\" dfa_count = \"dfa states:\" memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) + mem_nfa_graph ( automaton % nfa ) & + mem_dfa_graph ( automaton % dfa ) + 4 * 3 if ( allocated ( automaton % entry_set % vec )) then memsiz = memsiz + size ( automaton % entry_set % vec , dim = 1 ) end if if ( allocated ( automaton % all_segments )) then memsiz = memsiz + size ( automaton % all_segments , dim = 1 ) * 8 end if if ( flags ( FLAG_VERBOSE )) then cbuff = [ pattern_key , text_key , parse_time , nfa_time , dfa_init_time , dfa_compile_time , matching_time ,& matching_result , memory , tree_count , nfa_count , dfa_count ] call right_justify ( cbuff ) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 1 )), trim ( adjustl ( pattern )) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 2 )), \"'\" // text_highlight_green ( text , from , to ) // \"'\" write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 5 )), get_lap_time_in_appropriate_unit ( lap3 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 8 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 9 )), memsiz write ( stdout , fmt_out_ratio ) trim ( cbuff ( 10 )), tree % top , size ( tree % nodes , dim = 1 ) write ( stdout , fmt_out_ratio ) trim ( cbuff ( 11 )), automaton % nfa % nfa_top , automaton % nfa % nfa_limit write ( stdout , fmt_out_ratio ) trim ( cbuff ( 12 )), automaton % dfa % dfa_top , automaton % dfa % dfa_limit else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff = [ pattern_key , text_key , parse_time , nfa_time , dfa_init_time , dfa_compile_time , matching_time ,& matching_result , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 3 )] call right_justify ( cbuff ) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 1 )), trim ( adjustl ( pattern )) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 2 )), \"'\" // text_highlight_green ( text , from , to ) // \"'\" write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 5 )), get_lap_time_in_appropriate_unit ( lap3 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 8 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 9 )), memsiz end if if ( flags ( FLAG_TABLE_ONLY )) then call automaton % free () return end if write ( stdout , * ) \"\" write ( stdout , fmta , advance = 'no' ) trim ( dfa_for_print ) write ( stdout , fmta ) FOOTER end block output call automaton % free () end subroutine do_find_match_dense_dfa","tags":"","loc":"proc/do_find_match_dense_dfa.html"},{"title":"do_find_match_forgex – Forgex—Fortran Regular Expression","text":"public  subroutine do_find_match_forgex(flags, pattern, text, is_exactly) Uses forgex_parameters_m forgex_cli_time_measurement_m forgex_cli_utils_m forgex Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern character(len=*), intent(in) :: text logical, intent(in) :: is_exactly Source Code subroutine do_find_match_forgex ( flags , pattern , text , is_exactly ) use :: forgex , only : regex , operator (. in .), operator (. match .) use :: forgex_parameters_m , only : INVALID_CHAR_INDEX use :: forgex_cli_time_measurement_m use :: forgex_cli_utils_m , only : text_highlight_green implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern , text logical , intent ( in ) :: is_exactly real ( real64 ) :: lap logical :: res character (:), allocatable :: res_string integer :: from , to , unused res_string = '' from = INVALID_CHAR_INDEX to = INVALID_CHAR_INDEX call time_begin () if ( is_exactly ) then res = pattern . match . text else res = pattern . in . text end if lap = time_lap () ! Invoke regex subroutine to highlight matched substring. call regex ( pattern , text , res_string , unused , from , to ) output : block character ( NUM_DIGIT_KEY ) :: pattern_key , text_key character ( NUM_DIGIT_KEY ) :: total_time , matching_result character ( NUM_DIGIT_KEY ) :: buf ( 4 ) pattern_key = \"pattern:\" text_key = \"text:\" total_time = \"time:\" matching_result = \"result:\" if ( flags ( FLAG_NO_TABLE )) then write ( stdout , * ) res else buf = [ pattern_key , text_key , total_time , matching_result ] call right_justify ( buf ) write ( stdout , '(a, 1x, a)' ) trim ( buf ( 1 )), trim ( adjustl ( pattern )) write ( stdout , '(a, 1x, a)' ) trim ( buf ( 2 )), '\"' // text_highlight_green ( text , from , to ) // '\"' write ( stdout , fmt_out_time ) trim ( buf ( 3 )), get_lap_time_in_appropriate_unit ( lap ) write ( stdout , fmt_out_logi ) trim ( buf ( 4 )), res end if end block output end subroutine do_find_match_forgex","tags":"","loc":"proc/do_find_match_forgex.html"},{"title":"do_find_match_lazy_dfa – Forgex—Fortran Regular Expression","text":"public  subroutine do_find_match_lazy_dfa(flags, pattern, text, is_exactly) Uses forgex_parameters_m forgex_cli_memory_calculation_m forgex_nfa_state_set_m forgex_utility_m forgex_cli_utils_m forgex_automaton_m forgex_syntax_tree_optimize_m forgex_api_internal_m forgex_syntax_tree_graph_m Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern character(len=*), intent(in) :: text logical, intent(in) :: is_exactly Source Code subroutine do_find_match_lazy_dfa ( flags , pattern , text , is_exactly ) use :: forgex_automaton_m use :: forgex_syntax_tree_graph_m use :: forgex_syntax_tree_optimize_m use :: forgex_cli_memory_calculation_m use :: forgex_api_internal_m use :: forgex_nfa_state_set_m use :: forgex_cli_utils_m use :: forgex_utility_m , only : is_there_caret_at_the_top , is_there_dollar_at_the_end use :: forgex_parameters_m , only : ACCEPTED_EMPTY implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern character ( * ), intent ( in ) :: text logical , intent ( in ) :: is_exactly type ( tree_t ) :: tree type ( automaton_t ) :: automaton integer :: uni , ierr , i character (:), allocatable :: dfa_for_print , prefix , suffix , entire character ( 256 ) :: line real ( real64 ) :: lap1 , lap2 , lap3 , lap4 , lap5 logical :: res , flag_runs_engine , flag_fixed_string integer :: from , to dfa_for_print = '' lap1 = 0 d0 lap2 = 0 d0 lap3 = 0 d0 lap4 = 0 d0 lap5 = 0 d0 from = 0 to = 0 prefix = '' suffix = '' entire = '' flag_fixed_string = . false . flag_runs_engine = . false . if ( flags ( FLAG_HELP ) . or . pattern == '' ) call print_help_find_match_lazy_dfa call time_begin () call tree % build ( trim ( pattern )) lap1 = time_lap () call time_begin () if (. not . flags ( FLAG_NO_LITERAL )) then entire = get_entire_literal ( tree ) if ( entire /= '' ) flag_fixed_string = . true . if (. not . flag_fixed_string ) then prefix = get_prefix_literal ( tree ) suffix = get_suffix_literal ( tree ) end if end if lap5 = time_lap () if (. not . flag_fixed_string ) then call automaton % preprocess ( tree ) lap2 = time_lap () call automaton % init () lap3 = time_lap () end if if ( is_exactly ) then if ( flag_fixed_string ) then if ( len ( text ) == len ( entire )) then res = text == entire end if else call runner_do_matching_exactly ( automaton , text , res , prefix , suffix , flags ( FLAG_NO_LITERAL ), flag_runs_engine ) end if lap4 = time_lap () if ( res ) then from = 1 to = len ( text ) end if else block if ( flag_fixed_string ) then from = index ( text , entire ) if ( from > 0 ) to = from + len ( entire ) - 1 else call runner_do_matching_including ( automaton , text , from , to , & prefix , suffix , flags ( FLAG_NO_LITERAL ), flag_runs_engine ) end if if ( from > 0 . and . to > 0 ) then res = . true . else if ( from == ACCEPTED_EMPTY . and . to == ACCEPTED_EMPTY ) then res = . true . else res = . false . end if lap4 = time_lap () end block end if open ( newunit = uni , status = 'scratch' ) write ( uni , fmta ) HEADER_NFA call automaton % nfa % print ( uni , automaton % nfa_exit ) write ( uni , fmta ) HEADER_DFA call automaton % print_dfa ( uni ) rewind ( uni ) ierr = 0 do while ( ierr == 0 ) read ( uni , fmta , iostat = ierr ) line if ( ierr /= 0 ) exit if ( get_os_type () == OS_WINDOWS ) then dfa_for_print = dfa_for_print // trim ( line ) // CRLF else dfa_for_print = dfa_for_print // trim ( line ) // LF end if end do close ( uni ) output : block character ( NUM_DIGIT_KEY ) :: pattern_key , text_key character ( NUM_DIGIT_KEY ) :: parse_time , extract_time character ( NUM_DIGIT_KEY ) :: nfa_time , dfa_init_time , matching_time , memory character ( NUM_DIGIT_KEY ) :: runs_engine_key character ( NUM_DIGIT_KEY ) :: tree_count character ( NUM_DIGIT_KEY ) :: nfa_count character ( NUM_DIGIT_KEY ) :: dfa_count , matching_result character ( NUM_DIGIT_KEY ) :: cbuff ( 13 ) = '' integer :: memsiz pattern_key = \"pattern:\" text_key = \"text:\" parse_time = \"parse time:\" extract_time = \"extract literal time:\" runs_engine_key = \"runs engine:\" nfa_time = \"compile nfa time:\" dfa_init_time = \"dfa initialize time:\" matching_time = \"search time:\" memory = \"memory (estimated):\" matching_result = \"matching result:\" tree_count = \"tree node count:\" nfa_count = \"nfa states:\" dfa_count = \"dfa states:\" if ( flag_fixed_string ) then memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) else memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) + mem_nfa_graph ( automaton % nfa ) & + mem_dfa_graph ( automaton % dfa ) + 4 * 3 end if if ( allocated ( automaton % entry_set % vec )) then memsiz = memsiz + size ( automaton % entry_set % vec , dim = 1 ) end if if ( allocated ( automaton % all_segments )) then memsiz = memsiz + size ( automaton % all_segments , dim = 1 ) * 8 end if if ( flags ( FLAG_VERBOSE )) then cbuff = [ pattern_key , text_key , parse_time , extract_time , runs_engine_key , & nfa_time , dfa_init_time , matching_time , matching_result , memory , tree_count , & nfa_count , dfa_count ] call right_justify ( cbuff ) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 1 )), trim ( adjustl ( pattern )) ! write(stdout, '(a, 1x, a)') trim(cbuff(2)), '\"'//text//'\"' write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 2 )), '\"' // text_highlight_green ( text , from , to ) // '\"' write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 5 )), flag_runs_engine if ( flag_runs_engine . or . . not . flag_fixed_string ) then write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap3 ) else write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), not_running write ( stdout , fmt_out_char ) trim ( cbuff ( 7 )), not_running end if write ( stdout , fmt_out_time ) trim ( cbuff ( 8 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 9 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 10 )), memsiz write ( stdout , fmt_out_ratio ) trim ( cbuff ( 11 )), tree % top , size ( tree % nodes , dim = 1 ) write ( stdout , fmt_out_ratio ) trim ( cbuff ( 12 )), automaton % nfa % nfa_top , automaton % nfa % nfa_limit write ( stdout , fmt_out_ratio ) trim ( cbuff ( 13 )), automaton % dfa % dfa_top , automaton % dfa % dfa_limit else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff (:) = [ pattern_key , text_key , parse_time , extract_time , runs_engine_key , nfa_time , dfa_init_time , & matching_time , matching_result , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 3 )] call right_justify ( cbuff ) write ( stdout , '(a,1x,a)' ) trim ( cbuff ( 1 )), pattern ! write(stdout, '(a,1x,a)') trim(cbuff(2)), \"'\"//text//\"'\" write ( stdout , '(a,1x,a)' ) trim ( cbuff ( 2 )), \"'\" // text_highlight_green ( text , from , to ) // \"'\" write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 5 )), flag_runs_engine if ( flag_runs_engine . or . . not . flag_fixed_string ) then write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap3 ) else write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), not_running write ( stdout , fmt_out_char ) trim ( cbuff ( 7 )), not_running end if write ( stdout , fmt_out_time ) trim ( cbuff ( 8 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 9 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 10 )), memsiz end if if ( flags ( FLAG_TABLE_ONLY ) . or . . not . flag_runs_engine . or . flag_fixed_string ) then call automaton % free return end if write ( stdout , * ) \"\" write ( stdout , fmta , advance = 'no' ) trim ( dfa_for_print ) write ( stdout , fmta ) FOOTER end block output call automaton % free end subroutine do_find_match_lazy_dfa","tags":"","loc":"proc/do_find_match_lazy_dfa.html"},{"title":"runner_do_matching_exactly – Forgex—Fortran Regular Expression","text":"private  subroutine runner_do_matching_exactly(automaton, text, res, prefix, suffix, flag_no_literal_optimize, runs_engine) Uses forgex_cli_api_internal_no_opts_m forgex_syntax_tree_optimize_m forgex_api_internal_m forgex_automaton_m Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: text logical, intent(inout) :: res character(len=*), intent(in) :: prefix character(len=*), intent(in) :: suffix logical, intent(in) :: flag_no_literal_optimize logical, intent(inout) :: runs_engine Source Code subroutine runner_do_matching_exactly ( automaton , text , res , prefix , suffix , flag_no_literal_optimize , runs_engine ) use :: forgex_automaton_m use :: forgex_syntax_tree_optimize_m use :: forgex_cli_api_internal_no_opts_m use :: forgex_api_internal_m implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: text logical , intent ( inout ) :: res logical , intent ( inout ) :: runs_engine logical , intent ( in ) :: flag_no_literal_optimize character ( * ), intent ( in ) :: prefix , suffix if ( flag_no_literal_optimize ) then call do_matching_exactly_no_literal_opts ( automaton , text , res ) runs_engine = . true . else call do_matching_exactly ( automaton , text , res , prefix , suffix , runs_engine ) end if end subroutine runner_do_matching_exactly","tags":"","loc":"proc/runner_do_matching_exactly.html"},{"title":"runner_do_matching_including – Forgex—Fortran Regular Expression","text":"private  subroutine runner_do_matching_including(automaton, text, from, to, prefix, suffix, flag_no_literal_optimize, runs_engine) Uses forgex_cli_api_internal_no_opts_m forgex_automaton_m forgex_api_internal_m forgex_syntax_tree_optimize_m Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: text integer(kind=int32), intent(inout) :: from integer(kind=int32), intent(inout) :: to character(len=*), intent(in) :: prefix character(len=*), intent(in) :: suffix logical, intent(in) :: flag_no_literal_optimize logical, intent(inout) :: runs_engine Source Code subroutine runner_do_matching_including ( automaton , text , from , to , prefix , suffix , flag_no_literal_optimize , runs_engine ) use :: forgex_syntax_tree_optimize_m use :: forgex_automaton_m use :: forgex_api_internal_m use :: forgex_cli_api_internal_no_opts_m implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: text integer ( int32 ), intent ( inout ) :: from , to character ( * ), intent ( in ) :: prefix , suffix logical , intent ( in ) :: flag_no_literal_optimize logical , intent ( inout ) :: runs_engine if ( flag_no_literal_optimize ) then call do_matching_including_no_literal_opts ( automaton , text , from , to ) runs_engine = . true . else call do_matching_including ( automaton , text , from , to , prefix , suffix , runs_engine ) end if end subroutine runner_do_matching_including","tags":"","loc":"proc/runner_do_matching_including.html"},{"title":"do_matching_exactly_no_literal_opts – Forgex—Fortran Regular Expression","text":"public  subroutine do_matching_exactly_no_literal_opts(automaton, string, res) This subroutine is intended to be called from the forgex_cli_find_m module. Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: string logical, intent(inout) :: res Source Code subroutine do_matching_exactly_no_literal_opts ( automaton , string , res ) implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: string logical , intent ( inout ) :: res integer :: cur_i , dst_i ! current and destination index of DFA nodes integer :: ci ! character index integer :: next_ci ! next character index integer :: max_match ! character (:), allocatable :: str ! Initialize `cur_i` with automaton's initial index. cur_i = automaton % initial_index ! If the DFA have not been initialized, abort the program. if ( cur_i == DFA_NOT_INIT ) then error stop \"DFA have not been initialized.\" end if ! If the input string is an empty string, returns a logical value ! indicating whether the current state is accepting or not. if ( len ( string ) == 0 ) then res = automaton % dfa % nodes ( cur_i )% accepted return end if ! Initialize counter variables. max_match = 0 ci = 1 str = char ( 0 ) // string // char ( 0 ) ! Loop and proceed with matching unless the current index is DFA_INVALID_INDEX. do while ( cur_i /= DFA_INVALID_INDEX ) ! If the current state acceptable, the value of `max_match` is updated with `i`. if ( automaton % dfa % nodes ( cur_i )% accepted ) then max_match = ci end if if ( ci > len ( str )) exit ! Get the index of the next character and assign it to `next_ci`. next_ci = idxutf8 ( str , ci ) + 1 ! Lazy evaluation is performed by calling this procedure here. ! The index of destination DFA node is stored in the `dst_i` variable. call automaton % construct ( cur_i , dst_i , str ( ci : next_ci - 1 )) ! If there is mismatch in the first byte of the NULL character, try again with the second byte. if ( dst_i == DFA_INVALID_INDEX . and . ci == 1 ) then ci = 2 next_ci = idxutf8 ( str , ci ) + 1 call automaton % construct ( cur_i , dst_i , str ( ci : next_ci - 1 )) end if ! update counters cur_i = dst_i ci = next_ci end do ! If the maximum index of the match is one larger than length of the string, ! this function returns true, otherwise it returns false. if ( max_match >= len ( string ) + 2 ) then res = . true . else res = . false . end if end subroutine do_matching_exactly_no_literal_opts","tags":"","loc":"proc/do_matching_exactly_no_literal_opts.html"},{"title":"do_matching_including_no_literal_opts – Forgex—Fortran Regular Expression","text":"public  subroutine do_matching_including_no_literal_opts(automaton, string, from, to) Uses forgex_utility_m This procedure reads a text, performs regular expression matching using an automaton,\nand stores the string index in the argument if it contains a match. Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: string integer, intent(inout) :: from integer, intent(inout) :: to Source Code subroutine do_matching_including_no_literal_opts ( automaton , string , from , to ) use :: forgex_utility_m implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: string integer , intent ( inout ) :: from , to integer :: cur_i , dst_i ! current and destination index of DFA nodes integer :: ci ! character index integer :: next_ci ! next character index integer :: max_match ! maximum value of match attempts integer :: start ! starting character index integer :: i character (:), allocatable :: str str = string from = 0 to = 0 str = char ( 0 ) // string // char ( 0 ) cur_i = automaton % initial_index if ( cur_i == DFA_NOT_INIT ) then error stop \"DFA have not been initialized.\" end if if ( len ( string ) <= 1 . and . string == '' ) then if ( automaton % dfa % nodes ( cur_i )% accepted ) then from = ACCEPTED_EMPTY to = ACCEPTED_EMPTY end if return end if loop_init : block i = 1 start = i end block loop_init do while ( start < len ( str )) max_match = 0 ci = start cur_i = automaton % initial_index ! Traverse the DFA with the input string from the current starting position of ``cur_i`. do while ( cur_i /= DFA_INVALID_INDEX ) if ( automaton % dfa % nodes ( cur_i )% accepted . and . ci /= start ) then max_match = ci end if if ( ci > len ( str )) exit next_ci = idxutf8 ( str , ci ) + 1 call automaton % construct ( cur_i , dst_i , str ( ci : next_ci - 1 )) cur_i = dst_i ci = next_ci end do ! Update match position if a match is found. if ( max_match > 0 ) then from = start - 1 if ( from == 0 ) from = 1 ! handle leading NULL character. if ( max_match >= len ( str )) then to = len ( string ) else to = max_match - 2 end if return end if start = idxutf8 ( str , start ) + 1 ! Bruteforce searching end do end subroutine do_matching_including_no_literal_opts","tags":"","loc":"proc/do_matching_including_no_literal_opts.html"},{"title":"cmd__get_name – Forgex—Fortran Regular Expression","text":"private pure function cmd__get_name(self) result(res) Type Bound cmd_t Arguments Type Intent Optional Attributes Name class( cmd_t ), intent(in) :: self Return Value character(len=:), allocatable Source Code pure function cmd__get_name ( self ) result ( res ) implicit none class ( cmd_t ), intent ( in ) :: self character (:), allocatable :: res res = trim ( self % name ) end function cmd__get_name","tags":"","loc":"proc/cmd__get_name.html"},{"title":"cmd__set_name – Forgex—Fortran Regular Expression","text":"private pure subroutine cmd__set_name(self, name) Type Bound cmd_t Arguments Type Intent Optional Attributes Name class( cmd_t ), intent(inout) :: self character(len=*), intent(in) :: name Source Code pure subroutine cmd__set_name ( self , name ) implicit none class ( cmd_t ), intent ( inout ) :: self character ( * ), intent ( in ) :: name self % name = name end subroutine cmd__set_name","tags":"","loc":"proc/cmd__set_name.html"},{"title":"print_help – Forgex—Fortran Regular Expression","text":"public  subroutine print_help() Arguments None Source Code subroutine print_help implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 2 ) character ( CMD_DESC_SIZ ) :: cdesc ( 2 ) header = \"A tool for interacting with Forgex on the command line.\" usage ( 1 ) = \"forgex-cli <command> ...\" cmd ( 1 ) = \"debug\" cdesc ( 1 ) = \"Print the debug representation from Forgex's regex engine.\" cmd ( 2 ) = \"find\" cdesc ( 2 ) = \"Search for a string using one of the regular expression engines.\" call generate_and_output ( header , usage , \"COMMANDS\" , cmd , cdesc ) end subroutine print_help","tags":"","loc":"proc/print_help.html"},{"title":"print_help_debug – Forgex—Fortran Regular Expression","text":"public  subroutine print_help_debug() Arguments None Source Code subroutine print_help_debug implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 2 ) character ( CMD_DESC_SIZ ) :: cdesc ( 2 ) header = \"Prints the debug representation provided by Forgex.\" usage ( 1 ) = \"forgex-cli debug <command> ...\" cmd ( 1 ) = \"ast\" cdesc ( 1 ) = \"Print the debug representation of an AST.\" cmd ( 2 ) = \"thompson\" cdesc ( 2 ) = \"Print the debug representation of a Thompson NFA.\" call generate_and_output ( header , usage , \"COMMANDS\" , cmd , cdesc ) end subroutine print_help_debug","tags":"","loc":"proc/print_help_debug.html"},{"title":"print_help_debug_ast – Forgex—Fortran Regular Expression","text":"public  subroutine print_help_debug_ast() Arguments None","tags":"","loc":"proc/print_help_debug_ast.html"},{"title":"print_help_debug_thompson – Forgex—Fortran Regular Expression","text":"public  subroutine print_help_debug_thompson() Arguments None Source Code subroutine print_help_debug_thompson implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: op ( 3 ) character ( CMD_DESC_SIZ ) :: odesc ( 3 ) header = \"Print the debug representaion of a Thompson NFA.\" usage ( 1 ) = \"forgex-cli debug thompson <pattern>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Suppresses the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_debug_thompson","tags":"","loc":"proc/print_help_debug_thompson.html"},{"title":"print_help_find – Forgex—Fortran Regular Expression","text":"public  subroutine print_help_find() Arguments None Source Code subroutine print_help_find implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 1 ) character ( CMD_DESC_SIZ ) :: cdesc ( 1 ) header = \"Executes a search.\" usage ( 1 ) = \"forgex-cli find <command> ...\" cmd ( 1 ) = \"match\" cdesc ( 1 ) = \"Search for full matches.\" call generate_and_output ( header , usage , \"COMMANDS\" , cmd , cdesc ) end subroutine print_help_find","tags":"","loc":"proc/print_help_find.html"},{"title":"print_help_find_match – Forgex—Fortran Regular Expression","text":"public  subroutine print_help_find_match() Arguments None Source Code subroutine print_help_find_match implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 3 ) character ( CMD_DESC_SIZ ) :: cdesc ( 3 ) header = \"Executes a search for full matches.\" usage ( 1 ) = \"forgex-cli find match <engine>\" cmd ( 1 ) = \"dense\" cdesc ( 1 ) = \"Search with the fully-compiled DFA regex engine.\" cmd ( 2 ) = \"lazy-dfa\" cdesc ( 2 ) = \"Search with the lazy DFA regex engine.\" cmd ( 3 ) = \"forgex\" cdesc ( 3 ) = \"Search with the top-level API regex engine.\" call generate_and_output ( header , usage , \"ENGINES\" , cmd , cdesc ) end subroutine print_help_find_match","tags":"","loc":"proc/print_help_find_match.html"},{"title":"print_help_find_match_dense_dfa – Forgex—Fortran Regular Expression","text":"public  subroutine print_help_find_match_dense_dfa() Arguments None Source Code subroutine print_help_find_match_dense_dfa implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 2 ) character ( CMD_SIZ ) :: op ( 3 ) character ( CMD_DESC_SIZ ) :: odesc ( 3 ) header = \"Execute a search for matches using a fully-compiled DFA regex engine.\" usage ( 1 ) = \"forgex-cli find match dense <pattern> .match. <text>\" usage ( 2 ) = \"forgex-cli find match dense <pattern> .in. <text>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Suppress the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only. \" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_find_match_dense_dfa","tags":"","loc":"proc/print_help_find_match_dense_dfa.html"},{"title":"print_help_find_match_forgex_api – Forgex—Fortran Regular Expression","text":"public  subroutine print_help_find_match_forgex_api() Arguments None Source Code subroutine print_help_find_match_forgex_api implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 2 ) character ( CMD_SIZ ) :: op ( 1 ) character ( CMD_DESC_SIZ ) :: odesc ( 1 ) header = \"Executes a search for matches using the top-level API regex engine.\" usage ( 1 ) = \"forgex-cli find match forgex <pattern> .match. <text>\" usage ( 2 ) = \"forgex-cli find match forgex <pattern> .in. <text>\" op ( 1 ) = \"--no-table\" odesc ( 1 ) = \"Suppress the output of the property information table.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_find_match_forgex_api","tags":"","loc":"proc/print_help_find_match_forgex_api.html"},{"title":"print_help_find_match_lazy_dfa – Forgex—Fortran Regular Expression","text":"public  subroutine print_help_find_match_lazy_dfa() Arguments None Source Code subroutine print_help_find_match_lazy_dfa implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 2 ) character ( CMD_SIZ ) :: op ( 4 ) character ( CMD_DESC_SIZ ) :: odesc ( 4 ) header = \"Executes a search for matches using a lazy DFA regex engine.\" usage ( 1 ) = \"forgex-cli debug lazy-dfa <pattern> .match. <text>\" usage ( 2 ) = \"forgex-cli debug lazy-dfa <pattern> .in. <text>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Suppress the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only. \" op ( 4 ) = \"--disable-literal-optimize\" odesc ( 4 ) = \"Disable literals search optimization.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_find_match_lazy_dfa","tags":"","loc":"proc/print_help_find_match_lazy_dfa.html"},{"title":"generate_and_output – Forgex—Fortran Regular Expression","text":"private  subroutine generate_and_output(header, usage, choice, cmd, cmd_desc, desc) Arguments Type Intent Optional Attributes Name character(len=LINE_SIZ), intent(in) :: header character(len=LINE_SIZ), intent(in) :: usage (:) character(len=*), intent(in) :: choice character(len=CMD_SIZ), intent(in) :: cmd (:) character(len=CMD_DESC_SIZ), intent(in) :: cmd_desc (:) character(len=LINE_SIZ), intent(in), optional :: desc (:) Source Code subroutine generate_and_output ( header , usage , choice , cmd , cmd_desc , desc ) implicit none character ( LINE_SIZ ), intent ( in ) :: header character ( LINE_SIZ ), intent ( in ) :: usage (:) character ( * ), intent ( in ) :: choice character ( CMD_SIZ ), intent ( in ) :: cmd (:) ! command character ( CMD_DESC_SIZ ), intent ( in ) :: cmd_desc (:) ! description character ( LINE_SIZ ), intent ( in ), optional :: desc (:) character ( LINE_SIZ ), allocatable :: buff (:) integer :: num_line , i , offset if ( present ( desc )) then num_line = 3 + size ( desc ) + size ( usage ) + 2 + size ( cmd ) else num_line = 3 + size ( usage ) + 2 + size ( cmd ) end if ! header + blank + DESC + blank+ USAGE + size(usage) + blank + COMMANDS + size(cmd) allocate ( buff ( num_line )) buff (:) = \"\" buff ( 1 ) = header ! buff(2) blank offset = 2 if ( present ( desc )) then do i = 1 , size ( desc ) buff ( i + offset ) = desc ( i ) end do offset = offset + size ( desc ) endif offset = offset + 1 buff ( offset ) = \"USAGE:\" do i = 1 , size ( usage ) buff ( i + offset ) = \"   \" // trim ( usage ( i )) end do offset = offset + size ( usage ) buff ( offset + 2 ) = trim ( choice ) // \":\" offset = offset + 2 do i = 1 , size ( cmd ) buff ( i + offset ) = \"   \" // cmd ( i ) // \" \" // cmd_desc ( i ) enddo do i = 1 , num_line write ( stderr , fmta ) trim ( buff ( i )) end do stop end subroutine generate_and_output","tags":"","loc":"proc/generate_and_output.html"},{"title":"do_debug_ast – Forgex—Fortran Regular Expression","text":"public  subroutine do_debug_ast(flags, pattern) Uses forgex_cli_memory_calculation_m forgex_syntax_tree_graph_m forgex_syntax_tree_optimize_m Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern Source Code subroutine do_debug_ast ( flags , pattern ) use :: forgex_syntax_tree_graph_m use :: forgex_syntax_tree_optimize_m use :: forgex_cli_memory_calculation_m implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern type ( tree_t ) :: tree integer :: root integer :: uni , ierr , siz character (:), allocatable :: buff character (:), allocatable :: ast , prefix , suffix , entire !, middle real ( real64 ) :: lap1 , lap2 if ( flags ( FLAG_HELP )) call print_help_debug_ast call time_begin call tree % build ( trim ( pattern )) lap1 = time_lap () entire = get_entire_literal ( tree ) prefix = get_prefix_literal ( tree ) ! middle = get_middle_literal(tree) suffix = get_suffix_literal ( tree ) lap2 = time_lap () open ( newunit = uni , status = 'scratch' ) call tree % print ( uni ) inquire ( unit = uni , size = siz ) allocate ( character ( siz + 2 ) :: buff ) rewind ( uni ) read ( uni , fmta , iostat = ierr ) buff close ( uni ) ast = trim ( buff ) output : block character ( NUM_DIGIT_KEY ) :: parse_time , literal_time , tree_count , tree_allocated , & memory , literal_pre , literal_post , literal_all , literal_mid character ( NUM_DIGIT_KEY ) :: cbuff ( 9 ) integer :: i parse_time = \"parse time:\" literal_time = \"extract time:\" tree_count = \"tree node count:\" tree_allocated = \"tree node allocated:\" literal_all = \"extracted literal:\" literal_pre = \"extracted prefix:\" literal_mid = \"extracted middle:\" literal_post = \"extracted suffix:\" memory = \"memory (estimated):\" if ( flags ( FLAG_VERBOSE )) then cbuff = [ parse_time , literal_time , literal_all , literal_pre , literal_mid , literal_post , & memory , tree_count , tree_allocated ] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_char ) trim ( cbuff ( 3 )), entire write ( stdout , fmt_out_char ) trim ( cbuff ( 4 )), prefix ! write(stdout, fmt_out_char) trim(cbuff(5)), middle write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), suffix write ( stdout , fmt_out_int ) trim ( cbuff ( 7 )), mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) write ( stdout , fmt_out_int ) trim ( cbuff ( 8 )), root write ( stdout , fmt_out_int ) trim ( cbuff ( 9 )), size ( tree % nodes , dim = 1 ) else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff = [ parse_time , literal_time , literal_all , literal_pre , literal_mid , & literal_post , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 2 )] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_char ) trim ( cbuff ( 3 )), entire write ( stdout , fmt_out_char ) trim ( cbuff ( 4 )), prefix ! write(stdout, fmt_out_char) trim(cbuff(5)), middle write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), suffix write ( stdout , fmt_out_int ) trim ( cbuff ( 7 )), mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) end if end block output if ( flags ( FLAG_TABLE_ONLY )) return write ( stdout , fmta ) ast end subroutine do_debug_ast","tags":"","loc":"proc/do_debug_ast.html"},{"title":"do_debug_thompson – Forgex—Fortran Regular Expression","text":"public  subroutine do_debug_thompson(flags, pattern) Uses forgex_cli_memory_calculation_m forgex_syntax_tree_graph_m forgex_automaton_m Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern Source Code subroutine do_debug_thompson ( flags , pattern ) use :: forgex_cli_memory_calculation_m use :: forgex_automaton_m use :: forgex_syntax_tree_graph_m implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern type ( tree_t ) :: tree type ( automaton_t ) :: automaton integer :: root integer :: uni , ierr , i character (:), allocatable :: nfa character ( 256 ) :: line real ( real64 ) :: lap1 , lap2 nfa = '' if ( flags ( FLAG_HELP )) call print_help_debug_thompson if ( pattern == '' ) call print_help_debug_thompson call time_begin () ! call build_syntax_tree(trim(pattern), tree%tape, tree, root) call tree % build ( trim ( pattern )) lap1 = time_lap () call automaton % nfa % build ( tree , automaton % nfa_entry , automaton % nfa_exit , automaton % all_segments ) lap2 = time_lap () open ( newunit = uni , status = 'scratch' ) call automaton % nfa % print ( uni , automaton % nfa_exit ) rewind ( uni ) ierr = 0 do while ( ierr == 0 ) read ( uni , fmta , iostat = ierr ) line if ( ierr /= 0 ) exit if ( get_os_type () == OS_WINDOWS ) then nfa = nfa // trim ( line ) // CRLF else nfa = nfa // trim ( line ) // LF end if end do close ( uni ) output : block character ( NUM_DIGIT_KEY ) :: parse_time , nfa_time , memory , nfa_count , nfa_allocated , tree_count , tree_allocated character ( NUM_DIGIT_KEY ) :: cbuff ( 7 ) = '' integer :: memsiz parse_time = \"parse time:\" nfa_time = \"compile nfa time:\" memory = \"memory (estimated):\" nfa_count = \"nfa states:\" nfa_allocated = \"nfa states allocated:\" tree_count = \"tree node count:\" tree_allocated = \"tree node allocated:\" memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) & + mem_nfa_graph ( automaton % nfa ) + 4 * 3 if ( allocated ( automaton % entry_set % vec )) then memsiz = memsiz + size ( automaton % entry_set % vec , dim = 1 ) end if if ( allocated ( automaton % all_segments )) then memsiz = memsiz + size ( automaton % all_segments , dim = 1 ) * 8 end if if ( flags ( FLAG_VERBOSE )) then cbuff = [ parse_time , nfa_time , memory , tree_count , tree_allocated , nfa_count , nfa_allocated ] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_int ) trim ( cbuff ( 3 )), memsiz write ( stdout , fmt_out_int ) trim ( cbuff ( 4 )), root write ( stdout , fmt_out_int ) trim ( cbuff ( 5 )), size ( tree % nodes , dim = 1 ) write ( stdout , fmt_out_int ) trim ( cbuff ( 6 )), automaton % nfa % nfa_top write ( stdout , fmt_out_int ) trim ( cbuff ( 7 )), automaton % nfa % nfa_limit else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff (:) = [ parse_time , nfa_time , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 4 )] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_int ) trim ( cbuff ( 3 )), memsiz end if if ( flags ( FLAG_TABLE_ONLY )) return write ( stdout , * ) \"\" write ( stdout , fmta ) HEADER_NFA write ( stdout , fmta ) trim ( nfa ) write ( stdout , fmta ) \"Note: all segments of NFA were disjoined with overlapping portions.\" write ( stdout , fmta ) FOOTER end block output end subroutine do_debug_thompson","tags":"","loc":"proc/do_debug_thompson.html"},{"title":"cla__collect_flags – Forgex—Fortran Regular Expression","text":"private  subroutine cla__collect_flags(cla) Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla","tags":"","loc":"proc/cla__collect_flags.html"},{"title":"cla__do_debug_subc – Forgex—Fortran Regular Expression","text":"private  subroutine cla__do_debug_subc(cla) Uses forgex_cli_debug_m Processes the debug command, reads a subcommand, and calls the corresponding procedure. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__do_debug_subc ( cla ) use :: forgex_cli_debug_m implicit none class ( cla_t ), intent ( inout ) :: cla integer :: pattern_offset pattern_offset = 3 call cla % init_debug () call cla % read_subc () if ( cla % sub_cmd % get_name () == '' ) then call print_help_debug end if call cla % get_patterns ( pattern_offset ) ! Handle errors when a pattern does not exist. if (. not . allocated ( cla % patterns )) then select case ( cla % sub_cmd % get_name ()) case ( SUBC_AST ) call print_help_debug_ast case ( SUBC_THOMPSON ) call print_help_debug_thompson case default call print_help_debug end select end if if ( size ( cla % patterns ) > 1 ) then write ( stderr , '(a, i0, a)' ) \"Only single pattern is expected, but \" , size ( cla % patterns ), \" were given.\" stop end if select case ( cla % sub_cmd % get_name ()) case ( SUBC_AST ) call do_debug_ast ( cla % flags , cla % patterns ( 1 )% p ) case ( SUBC_THOMPSON ) call do_debug_thompson ( cla % flags , cla % patterns ( 1 )% p ) end select end subroutine cla__do_debug_subc","tags":"","loc":"proc/cla__do_debug_subc.html"},{"title":"cla__do_find_subc – Forgex—Fortran Regular Expression","text":"private  subroutine cla__do_find_subc(cla) Uses forgex_cli_find_m Processes the debug command, reads a subcommand and a sub-subcommand,\nand calls the corresponding procedure. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__do_find_subc ( cla ) use :: forgex_cli_find_m implicit none class ( cla_t ), intent ( inout ) :: cla logical :: is_exactly integer :: pattern_offset character (:), allocatable :: text pattern_offset = 4 call cla % init_find () call cla % read_subc () if ( cla % sub_cmd % get_name () == '' ) then call print_help_find else if ( cla % sub_cmd % get_name () == SUBC_MATCH ) then call cla % init_find_match () endif call cla % read_subsubc () if ( cla % sub_sub_cmd % get_name () == '' ) then select case ( cla % sub_cmd % get_name ()) case ( SUBC_MATCH ) call print_help_find_match end select end if call cla % get_patterns ( pattern_offset ) if (. not . allocated ( cla % patterns )) then select case ( cla % sub_sub_cmd % get_name ()) case ( ENGINE_LAZY_DFA ) call print_help_find_match_lazy_dfa case ( ENGINE_DENSE_DFA ) call print_help_find_match_dense_dfa case ( ENGINE_FORGEX_API ) call print_help_find_match_forgex_api end select end if if ( cla % sub_sub_cmd % get_name () == ENGINE_LAZY_DFA & . or . cla % sub_sub_cmd % get_name () == ENGINE_DENSE_DFA & . or . cla % sub_sub_cmd % get_name () == ENGINE_FORGEX_API ) then if ( size ( cla % patterns ) /= 3 . and . size ( cla % patterns ) /= 2 ) then write ( stderr , \"(a, i0, a)\" ) \"Three arguments are expected, but \" , size ( cla % patterns ), \" were given.\" stop else if ( cla % patterns ( 2 )% p /= OP_MATCH . and . cla % patterns ( 2 )% p /= OP_IN ) then write ( stderr , \"(a)\" ) \"Operator \" // OP_MATCH // \" or \" // OP_IN // \" are expected, but \" // cla % patterns ( 2 )% p // \" was given.\" stop end if if ( cla % patterns ( 2 )% p == OP_MATCH ) then is_exactly = . true . else if ( cla % patterns ( 2 )% p == OP_IN ) then is_exactly = . false . else write ( stderr , '(a)' ) \"Unknown operator: \" // cla % patterns ( 2 )% p end if else call print_help_find_match end if if ( size ( cla % patterns ) == 2 ) then text = '' else text = cla % patterns ( 3 )% p end if select case ( cla % sub_sub_cmd % get_name ()) case ( ENGINE_LAZY_DFA ) call do_find_match_lazy_dfa ( cla % flags , cla % patterns ( 1 )% p , text , is_exactly ) case ( ENGINE_DENSE_DFA ) call do_find_match_dense_dfa ( cla % flags , cla % patterns ( 1 )% p , text , is_exactly ) case ( ENGINE_FORGEX_API ) call do_find_match_forgex ( cla % flags , cla % patterns ( 1 )% p , text , is_exactly ) case default call print_help_find_match end select end subroutine cla__do_find_subc","tags":"","loc":"proc/cla__do_find_subc.html"},{"title":"cla__get_patterns – Forgex—Fortran Regular Expression","text":"private  subroutine cla__get_patterns(cla, offset) Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla integer, intent(in) :: offset Source Code subroutine cla__get_patterns ( cla , offset ) implicit none class ( cla_t ), intent ( inout ) :: cla integer , intent ( in ) :: offset integer :: i , j , k integer , allocatable :: idx (:) j = 0 outer : do i = offset , cla % arg_info % argc ! if ( i <= maxval ( cla % flag_idx )) then do k = 1 , ubound ( cla % flags , dim = 1 ) if ( i == cla % flag_idx ( k )) cycle outer end do end if j = j + 1 if (. not . allocated ( idx )) then idx = [ i ] cycle end if idx = [ idx , i ] end do outer if ( j == 0 ) return allocate ( cla % patterns ( j )) do i = 1 , j cla % patterns ( i )% p = cla % arg_info % arg ( idx ( i ))% v end do end subroutine cla__get_patterns","tags":"","loc":"proc/cla__get_patterns.html"},{"title":"cla__init_debug_subc – Forgex—Fortran Regular Expression","text":"private  subroutine cla__init_debug_subc(cla) Prepare subcommands for the debug command. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla","tags":"","loc":"proc/cla__init_debug_subc.html"},{"title":"cla__init_find_match_subsubc – Forgex—Fortran Regular Expression","text":"private  subroutine cla__init_find_match_subsubc(cla) Prepare sub-subcommands for the match subcommand. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__init_find_match_subsubc ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla allocate ( cla % sub_cmd % subc ( NUM_SUBSUBC_MATCH )) cla % sub_cmd % subc ( 1 ) = ENGINE_LAZY_DFA cla % sub_cmd % subc ( 2 ) = ENGINE_DENSE_DFA cla % sub_cmd % subc ( 3 ) = ENGINE_FORGEX_API end subroutine cla__init_find_match_subsubc","tags":"","loc":"proc/cla__init_find_match_subsubc.html"},{"title":"cla__init_find_subc – Forgex—Fortran Regular Expression","text":"private  subroutine cla__init_find_subc(cla) Prepare subcommands for the find command. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__init_find_subc ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla allocate ( cla % cmd % subc ( NUM_SUBC_FIND )) cla % cmd % subc ( 1 ) = SUBC_MATCH end subroutine cla__init_find_subc","tags":"","loc":"proc/cla__init_find_subc.html"},{"title":"cla__initialize – Forgex—Fortran Regular Expression","text":"private  subroutine cla__initialize(cla) Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__initialize ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla call get_arg_command_line ( cla % arg_info % argc , cla % arg_info % arg , cla % arg_info % entire ) cla % flags = . false . cla % flag_idx = - 1 call init_flags call init_commands end subroutine cla__initialize","tags":"","loc":"proc/cla__initialize.html"},{"title":"cla__read_command – Forgex—Fortran Regular Expression","text":"private  subroutine cla__read_command(cla) Read the first argument and match it with registered commands. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__read_command ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla character (:), allocatable :: cmd if ( ubound ( cla % arg_info % arg , dim = 1 ) < 1 ) then cmd = \"\" return end if cmd = trim ( cla % arg_info % arg ( 1 )% v ) if ( cmd . in . all_cmds ) then call cla % cmd % set_name ( cmd ) else call cla % cmd % set_name ( \"\" ) end if end subroutine cla__read_command","tags":"","loc":"proc/cla__read_command.html"},{"title":"cla__read_sub_subcommand – Forgex—Fortran Regular Expression","text":"private  subroutine cla__read_sub_subcommand(cla) Read the third argument and match it with registered sub-subcommands. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__read_sub_subcommand ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla character (:), allocatable :: cmd integer :: i if ( cla % arg_info % argc < 3 ) return cmd = trim ( cla % arg_info % arg ( 3 )% v ) do i = 1 , size ( cla % sub_cmd % subc ) if ( cmd == cla % sub_cmd % subc ( i )) then call cla % sub_sub_cmd % set_name ( cmd ) return end if end do end subroutine cla__read_sub_subcommand","tags":"","loc":"proc/cla__read_sub_subcommand.html"},{"title":"cla__read_subcommand – Forgex—Fortran Regular Expression","text":"private  subroutine cla__read_subcommand(cla) Read the second argument and match it with registered subcommands. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__read_subcommand ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla character (:), allocatable :: cmd integer :: i cmd = trim ( cla % arg_info % arg ( 2 )% v ) do i = 1 , size ( cla % cmd % subc ) if ( cmd == cla % cmd % subc ( i )) then call cla % sub_cmd % set_name ( cmd ) return end if end do end subroutine cla__read_subcommand","tags":"","loc":"proc/cla__read_subcommand.html"},{"title":"init_commands – Forgex—Fortran Regular Expression","text":"private  subroutine init_commands() Arguments None Source Code subroutine init_commands () implicit none call register_cmd ( all_cmds ( 1 ), CMD_DEBUG ) call register_cmd ( all_cmds ( 2 ), CMD_FIND ) end subroutine init_commands","tags":"","loc":"proc/init_commands.html"},{"title":"init_flags – Forgex—Fortran Regular Expression","text":"private  subroutine init_flags() Uses forgex_enums_m This subroutine registers all the flags forgex-cli accepts for the flag_t type array all_flags . Arguments None Source Code subroutine init_flags () use :: forgex_enums_m implicit none call register_flag ( all_flags ( FLAG_HELP ), 'help' , '--help' , '-h' ) call register_flag ( all_flags ( FLAG_VERBOSE ), 'verbose' , '--verbose' , '-v' ) call register_flag ( all_flags ( FLAG_NO_TABLE ), 'no-table' , '--no-table' ) call register_flag ( all_flags ( FLAG_TABLE_ONLY ), 'table-only' , '--table-only' ) call register_flag ( all_flags ( FLAG_NO_LITERAL ), 'no-literal-optimize' , '--disable-literal-optimize' ) end subroutine init_flags","tags":"","loc":"proc/init_flags.html"},{"title":"mem_dfa_graph – Forgex—Fortran Regular Expression","text":"public  function mem_dfa_graph(graph) result(res) Uses forgex_lazy_dfa_graph_m Arguments Type Intent Optional Attributes Name type(dfa_graph_t), intent(in) :: graph Return Value integer Source Code function mem_dfa_graph ( graph ) result ( res ) use :: forgex_lazy_dfa_graph_m implicit none type ( dfa_graph_t ), intent ( in ) :: graph integer :: res , sum_node , sum_tra , i , j res = 16 ! 4 int32 sum_node = 0 do i = 1 , graph % dfa_top - 1 sum_node = sum_node + 6 * 4 ! 3 int32, 3 logical if ( allocated ( graph % nodes ( i )% nfa_set % vec )) then sum_node = sum_node + size ( graph % nodes ( i )% nfa_set % vec ) * 4 ! logical vector end if sum_tra = 0 inner : do j = 1 , graph % nodes ( i )% get_tra_top () sum_tra = sum_tra + 8 + 4 * 2 ! segment + 2 int32 if (. not . allocated ( graph % nodes ( i )% transition )) cycle inner if ( allocated ( graph % nodes ( i )% transition ( j )% nfa_set % vec )) then sum_tra = sum_tra + size ( graph % nodes ( i )% transition ( j )% nfa_set % vec ) * 4 end if end do inner sum_node = sum_node + sum_tra end do res = res + sum_node res = res + ( ubound ( graph % nodes , dim = 1 ) - graph % dfa_top ) * 6 * 4 ! 3 int32, 3 logical end function mem_dfa_graph","tags":"","loc":"proc/mem_dfa_graph.html"},{"title":"mem_nfa_graph – Forgex—Fortran Regular Expression","text":"public  function mem_nfa_graph(graph) result(res) Uses forgex_nfa_graph_m Arguments Type Intent Optional Attributes Name type(nfa_graph_t), intent(in) :: graph Return Value integer Source Code function mem_nfa_graph ( graph ) result ( res ) use :: forgex_nfa_graph_m implicit none type ( nfa_graph_t ), intent ( in ) :: graph integer :: res , sum_node , sum_tra , i , j res = 12 ! 3 int32 sum_node = 0 do i = NFA_STATE_BASE , graph % nfa_top sum_node = sum_node + 5 * 4 ! 5 int32 sum_tra = 0 if (. not . allocated ( graph % nodes ( i )% forward )) cycle b : do j = lbound ( graph % nodes ( i )% forward , dim = 1 ), ubound ( graph % nodes ( i )% forward , dim = 1 ) if (. not . allocated ( graph % nodes ( i )% forward )) cycle b sum_tra = sum_tra + 4 * 4 ! 3 int32, 1 logical if ( allocated ( graph % nodes ( i )% forward ( j )% c )) then sum_tra = sum_tra + 8 * size ( graph % nodes ( i )% forward ( j )% c ) end if end do b sum_node = sum_node + sum_tra * 2 ! forward and backward end do res = res + sum_node res = res + ( ubound ( graph % nodes , dim = 1 ) - graph % nfa_top ) * 5 ! 5 int32 end function mem_nfa_graph","tags":"","loc":"proc/mem_nfa_graph.html"},{"title":"mem_tape – Forgex—Fortran Regular Expression","text":"public  function mem_tape(tape) result(res) Uses forgex_syntax_tree_node_m Arguments Type Intent Optional Attributes Name type(tape_t), intent(in) :: tape Return Value integer Source Code function mem_tape ( tape ) result ( res ) use :: forgex_syntax_tree_node_m implicit none type ( tape_t ), intent ( in ) :: tape integer :: res res = len ( tape % str ) res = res + 12 end function mem_tape","tags":"","loc":"proc/mem_tape.html"},{"title":"mem_tree – Forgex—Fortran Regular Expression","text":"public  function mem_tree(tree) result(res) Uses forgex_syntax_tree_node_m Arguments Type Intent Optional Attributes Name type(tree_node_t), intent(in) :: tree (:) Return Value integer Source Code function mem_tree ( tree ) result ( res ) use :: forgex_syntax_tree_node_m implicit none type ( tree_node_t ), intent ( in ) :: tree (:) integer :: res , sum_c , i res = size ( tree , dim = 1 ) * 6 * 4 ! 5 int32, 1 logical sum_c = 0 do i = lbound ( tree , dim = 1 ), ubound ( tree , dim = 1 ) if ( allocated ( tree ( i )% c )) then sum_c = sum_c + size ( tree ( i )% c ) * 8 ! 8bytes per segment end if end do res = res + sum_c end function mem_tree","tags":"","loc":"proc/mem_tree.html"},{"title":"get_flag_index – Forgex—Fortran Regular Expression","text":"public  function get_flag_index(arg, flags) result(res) Arguments Type Intent Optional Attributes Name type( arg_element_t ), intent(in) :: arg type( flag_t ), intent(in) :: flags (:) Return Value integer Source Code function get_flag_index ( arg , flags ) result ( res ) implicit none type ( arg_element_t ), intent ( in ) :: arg type ( flag_t ), intent ( in ) :: flags (:) integer :: res integer :: i res = - 1 do i = 1 , NUM_FLAGS if ( arg % v == flags ( i )% long_f . or . arg % v == flags ( i )% short_f ) then res = i return end if end do end function get_flag_index","tags":"","loc":"proc/get_flag_index.html"},{"title":"get_os_type – Forgex—Fortran Regular Expression","text":"public  function get_os_type() result(res) Uses forgex_enums_m forgex Todo Arguments None Return Value integer Source Code function get_os_type () result ( res ) use :: forgex , only : operator (. in .) use :: forgex_enums_m implicit none integer :: res integer , save :: res_save logical , save :: is_first = . true . character ( LEN_ENV_VAR ) :: val1 , val2 integer :: len1 , len2 , stat1 , stat2 if (. not . is_first ) then res = res_save return end if res = OS_UNKNOWN call get_environment_variable ( name = 'OS' , value = val1 , length = len1 , status = stat1 ) if ( stat1 == 0 . and . len1 > 0 ) then if ( \"Windows_NT\" . in . val1 ) then res_save = OS_WINDOWS res = res_save is_first = . false . return end if end if call get_environment_variable ( name = 'OSTYPE' , value = val2 , length = len2 , status = stat2 ) if ( stat2 == 0 . and . len2 > 0 ) then !! @todo end if end function get_os_type","tags":"","loc":"proc/get_os_type.html"},{"title":"text_highlight_green – Forgex—Fortran Regular Expression","text":"public  function text_highlight_green(string, from, to) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer(kind=int32), intent(in) :: from integer(kind=int32), intent(in) :: to Return Value character(len=:), allocatable Source Code function text_highlight_green ( string , from , to ) result ( res ) implicit none character ( * ), intent ( in ) :: string integer ( int32 ), intent ( in ) :: from , to character (:), allocatable :: res character ( 5 ) :: green = char ( 27 ) // \"[32m\" character ( 5 ) :: hend = char ( 27 ) // \"[39m\" character ( 4 ) :: bold = char ( 27 ) // \"[1m\" character ( 4 ) :: bend = char ( 27 ) // \"[0m\" res = '' if ( from > 0 . and . to > 0 . and . from <= to . and . len ( string ) > 0 ) then res = string ( 1 : from - 1 ) // green // bold // string ( from : to ) // bend // hend // string ( to + 1 : len ( string )) else res = string end if end function text_highlight_green","tags":"","loc":"proc/text_highlight_green.html"},{"title":"does_command_exist – Forgex—Fortran Regular Expression","text":"private pure function does_command_exist(arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg character(len=LEN_CMD), intent(in) :: cmd_list (:) Return Value logical Source Code pure function does_command_exist ( arg , cmd_list ) result ( res ) implicit none character ( * ), intent ( in ) :: arg character ( LEN_CMD ), intent ( in ) :: cmd_list (:) logical :: res integer :: i res = . false . do i = lbound ( cmd_list , dim = 1 ), ubound ( cmd_list , dim = 1 ) res = res . or . trim ( arg ) == trim ( cmd_list ( i )) if ( res ) return end do end function does_command_exist","tags":"","loc":"proc/does_command_exist.html"},{"title":"does_command_exist_type_cmd – Forgex—Fortran Regular Expression","text":"private pure function does_command_exist_type_cmd(arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( cmd_t ), intent(in) :: cmd_list (:) Return Value logical Source Code pure function does_command_exist_type_cmd ( arg , cmd_list ) result ( res ) implicit none character ( * ), intent ( in ) :: arg type ( cmd_t ), intent ( in ) :: cmd_list (:) logical :: res integer :: i res = . false . do i = lbound ( cmd_list , dim = 1 ), ubound ( cmd_list , dim = 1 ) res = res . or . trim ( arg ) == trim ( cmd_list ( i )% get_name ()) if ( res ) return end do end function does_command_exist_type_cmd","tags":"","loc":"proc/does_command_exist_type_cmd.html"},{"title":"does_flag_exist – Forgex—Fortran Regular Expression","text":"private pure function does_flag_exist(arg, flag_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( flag_t ), intent(in) :: flag_list (:) Return Value logical Source Code pure function does_flag_exist ( arg , flag_list ) result ( res ) implicit none character ( * ), intent ( in ) :: arg type ( flag_t ), intent ( in ) :: flag_list (:) logical :: res integer :: i res = . false . do i = lbound ( flag_list , dim = 1 ), ubound ( flag_list , dim = 1 ) res = res & . or . trim ( arg ) == trim ( flag_list ( i )% short_f ) & . or . trim ( arg ) == trim ( flag_list ( i )% long_f ) if ( res ) return end do end function does_flag_exist","tags":"","loc":"proc/does_flag_exist.html"},{"title":"is_arg_contained_in_flags – Forgex—Fortran Regular Expression","text":"private  function is_arg_contained_in_flags(arg, flags) result(res) Arguments Type Intent Optional Attributes Name type( arg_element_t ), intent(in) :: arg type( flag_t ), intent(in) :: flags (:) Return Value logical Source Code function is_arg_contained_in_flags ( arg , flags ) result ( res ) implicit none type ( arg_element_t ), intent ( in ) :: arg type ( flag_t ), intent ( in ) :: flags (:) logical :: res integer :: i res = . false . do i = 1 , ubound ( flags , dim = 1 ) res = res & . or . flags ( i )% long_f == arg % v & . or . flags ( i )% short_f == arg % v if ( res ) return end do end function is_arg_contained_in_flags","tags":"","loc":"proc/is_arg_contained_in_flags.html"},{"title":"get_arg_command_line – Forgex—Fortran Regular Expression","text":"public  subroutine get_arg_command_line(argc, arg, entire) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: argc type( arg_element_t ), intent(inout), allocatable :: arg (:) character(len=:), intent(inout), allocatable :: entire Source Code subroutine get_arg_command_line ( argc , arg , entire ) implicit none integer ( int32 ), intent ( inout ) :: argc ! argc type ( arg_element_t ), allocatable , intent ( inout ) :: arg (:) character (:), allocatable , intent ( inout ) :: entire integer :: i , len_ith , entire_len argc = command_argument_count () call get_command ( length = entire_len ) allocate ( character ( entire_len ) :: entire ) call get_command ( command = entire ) allocate ( arg ( 0 : argc )) do i = 0 , argc ! Get length of i-th command line argmuemnt. call get_command_argument ( number = i , length = len_ith ) ! Allocate str(i)%v of the same length as the i-th argument. allocate ( character ( len_ith ) :: arg ( i )% v ) ! Get the value of the i-th argument as a string. call get_command_argument ( number = i , value = arg ( i )% v ) end do end subroutine get_arg_command_line","tags":"","loc":"proc/get_arg_command_line.html"},{"title":"info – Forgex—Fortran Regular Expression","text":"public  subroutine info(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Source Code subroutine info ( str ) implicit none character ( * ), intent ( in ) :: str write ( stderr , '(a)' ) \"[info]: \" // str end subroutine info","tags":"","loc":"proc/info.html"},{"title":"register_cmd – Forgex—Fortran Regular Expression","text":"public  subroutine register_cmd(cmd, name) Arguments Type Intent Optional Attributes Name type( cmd_t ), intent(inout) :: cmd character(len=*), intent(in) :: name Source Code subroutine register_cmd ( cmd , name ) implicit none type ( cmd_t ), intent ( inout ) :: cmd character ( * ), intent ( in ) :: name call cmd % set_name ( name ) end subroutine register_cmd","tags":"","loc":"proc/register_cmd.html"},{"title":"register_flag – Forgex—Fortran Regular Expression","text":"public  subroutine register_flag(flag, name, long, short) Arguments Type Intent Optional Attributes Name type( flag_t ), intent(inout) :: flag character(len=*), intent(in) :: name character(len=*), intent(in) :: long character(len=*), intent(in), optional :: short","tags":"","loc":"proc/register_flag.html"},{"title":"right_justify – Forgex—Fortran Regular Expression","text":"public  subroutine right_justify(array) Uses forgex_cli_parameters_m Arguments Type Intent Optional Attributes Name character(len=NUM_DIGIT_KEY), intent(inout) :: array (:)","tags":"","loc":"proc/right_justify.html"},{"title":"operator(.in.) – Forgex—Fortran Regular Expression","text":"public interface operator(.in.) Module Procedures private pure function does_flag_exist (arg, flag_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( flag_t ), intent(in) :: flag_list (:) Return Value logical private pure function does_command_exist (arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg character(len=LEN_CMD), intent(in) :: cmd_list (:) Return Value logical private pure function does_command_exist_type_cmd (arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( cmd_t ), intent(in) :: cmd_list (:) Return Value logical private  function is_arg_contained_in_flags (arg, flags) result(res) Arguments Type Intent Optional Attributes Name type( arg_element_t ), intent(in) :: arg type( flag_t ), intent(in) :: flags (:) Return Value logical","tags":"","loc":"interface/operator(.in.).html"},{"title":"forgex_cli_time_measurement_m – Forgex—Fortran Regular Expression","text":"This module provides procedures to measure the time it takes to execute.\ncf. https://qiita.com/implicit_none/items/86c9117990798c1e8b3b Uses forgex_enums_m forgex_cli_utils_m iso_c_binding forgex_cli_parameters_m iso_fortran_env Variables Type Visibility Attributes Name Initial real(kind=real64), private :: begin_s real(kind=real64), private :: end_s integer(kind=c_long_long), private :: frequency logical(kind=c_bool), private :: is_succeeded = .false. logical(kind=c_bool), private :: is_supported = .false. real(kind=real64), private :: last_s integer(kind=c_long_long), private :: time_begin_qhc integer(kind=c_long_long), private :: time_end_qhc Interfaces interface For Windows, use high-resolution system call for timing. private  function QueryPerformanceCounter(PerformanceCount_count) result(is_succeeded_c) bind(c, name=\"QueryPerformanceCounter\") Arguments Type Intent Optional Attributes Name integer(kind=c_long_long), intent(out) :: PerformanceCount_count Return Value logical(kind=c_bool) interface For Windows, use high-resolution system call for timing. private  function QueryPerformanceFrequency(Frequency_countPerSec) result(is_supported_c) bind(c, name=\"QueryPerformanceFrequency\") Arguments Type Intent Optional Attributes Name integer(kind=c_long_long), intent(out) :: Frequency_countPerSec Return Value logical(kind=c_bool) Functions public  function get_lap_time_in_appropriate_unit (lap_time) result(res) This function takes a real number of seconds, converts it to the appropriate\nunits, and returns a string with the unit for output. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: lap_time Return Value character(len=NUM_DIGIT_TIME) public  function time_lap () result(res) This function is for timing purposes and returns the lap time\nsince the last call of time_begin or time_lap . Arguments None Return Value real(kind=real64) Subroutines public  subroutine time_begin () This subroutine is for timing purpose and starts a stopwatch. Arguments None","tags":"","loc":"module/forgex_cli_time_measurement_m.html"},{"title":"forgex_cli_find_m – Forgex—Fortran Regular Expression","text":"Uses forgex_enums_m forgex_cli_utils_m forgex_cli_time_measurement_m forgex_cli_parameters_m iso_fortran_env forgex_cli_help_messages_m Subroutines public  subroutine do_find_match_dense_dfa (flags, pattern, text, is_exactly) Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern character(len=*), intent(in) :: text logical, intent(in) :: is_exactly public  subroutine do_find_match_forgex (flags, pattern, text, is_exactly) Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern character(len=*), intent(in) :: text logical, intent(in) :: is_exactly public  subroutine do_find_match_lazy_dfa (flags, pattern, text, is_exactly) Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern character(len=*), intent(in) :: text logical, intent(in) :: is_exactly private  subroutine runner_do_matching_exactly (automaton, text, res, prefix, suffix, flag_no_literal_optimize, runs_engine) Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: text logical, intent(inout) :: res character(len=*), intent(in) :: prefix character(len=*), intent(in) :: suffix logical, intent(in) :: flag_no_literal_optimize logical, intent(inout) :: runs_engine private  subroutine runner_do_matching_including (automaton, text, from, to, prefix, suffix, flag_no_literal_optimize, runs_engine) Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: text integer(kind=int32), intent(inout) :: from integer(kind=int32), intent(inout) :: to character(len=*), intent(in) :: prefix character(len=*), intent(in) :: suffix logical, intent(in) :: flag_no_literal_optimize logical, intent(inout) :: runs_engine","tags":"","loc":"module/forgex_cli_find_m.html"},{"title":"forgex_cli_api_internal_no_opts_m – Forgex—Fortran Regular Expression","text":"Uses forgex_parameters_m forgex_utf8_m forgex_automaton_m Subroutines public  subroutine do_matching_exactly_no_literal_opts (automaton, string, res) This subroutine is intended to be called from the forgex_cli_find_m module. Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: string logical, intent(inout) :: res public  subroutine do_matching_including_no_literal_opts (automaton, string, from, to) This procedure reads a text, performs regular expression matching using an automaton,\nand stores the string index in the argument if it contains a match. Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: string integer, intent(inout) :: from integer, intent(inout) :: to","tags":"","loc":"module/forgex_cli_api_internal_no_opts_m.html"},{"title":"forgex_cli_parameters_m – Forgex—Fortran Regular Expression","text":"Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: CMD_DEBUG = \"debug\" Name of the subcommand debug. character(len=*), public, parameter :: CMD_FIND = \"find\" Name of the subcommand find. character(len=*), public, parameter :: CRLF = char(13)//char(10) Line ending characters for Windows OS character(len=*), public, parameter :: ENGINE_DENSE_DFA = \"dense\" character(len=*), public, parameter :: ENGINE_FORGEX_API = \"forgex\" character(len=*), public, parameter :: ENGINE_LAZY_DFA = \"lazy-dfa\" character(len=*), public, parameter :: FOOTER = \"===================================\" character(len=*), public, parameter :: HEADER_DFA = \"=============== DFA ===============\" character(len=*), public, parameter :: HEADER_NFA = \"========== Thompson NFA ===========\" Headers character(len=*), public, parameter :: INVALID_FLAG = \"INVALID\" String to indicate invalidity if no short flag is present. integer, public, parameter :: LEN_CMD = 16 Length integer, public, parameter :: LEN_ENV_VAR = 255 Maximum length of an environment variable's value. character(len=*), public, parameter :: LF = char(10) Line Feed. integer, public, parameter :: NUM_CMD = 2 Number of sub-command that forgec-cli accepts. integer, public, parameter :: NUM_DIGIT_KEY = 32 Maximum langth of table field name. integer, public, parameter :: NUM_DIGIT_TIME = 13 Number of digits for time display. integer, public, parameter :: NUM_FLAGS = 5 Number of flags (without value) that forgex-cli accepts. integer, public, parameter :: NUM_SUBC_DEBUG = 2 The number of sub-subcommands that debug accepts. integer, public, parameter :: NUM_SUBC_FIND = 1 integer, public, parameter :: NUM_SUBSUBC_MATCH = 3 character(len=*), public, parameter :: OP_IN = \".in.\" character(len=*), public, parameter :: OP_MATCH = \".match.\" Name of the sub-subcommand lazy dfa character(len=*), public, parameter :: SUBC_AST = \"ast\" Name of the sub-subcommand ast. character(len=*), public, parameter :: SUBC_MATCH = \"match\" character(len=*), public, parameter :: SUBC_THOMPSON = \"thompson\" Name of the sub-subcommand thompson. integer, public, parameter :: TREE_BUFF_LEN = 2**16 The buffer length of displaying the AST. character(len=*), public, parameter :: fmt_out_char = \"(a, 1x, a)\" character(len=*), public, parameter :: fmt_out_int = \"(a, i10)\" Output format for displaying an integer in tables. character(len=*), public, parameter :: fmt_out_logi = \"(a, l10)\" character(len=*), public, parameter :: fmt_out_ratio = \"(a, i10, '/', i0)\" character(len=*), public, parameter :: fmt_out_time = \"(a, a15)\" character(len=*), public, parameter :: fmta = \"(a)\" Format for outputting text only. character(len=*), public, parameter :: not_running = \"not running\"","tags":"","loc":"module/forgex_cli_parameters_m.html"},{"title":"forgex_cli_type_m – Forgex—Fortran Regular Expression","text":"Uses forgex_cli_parameters_m Derived Types type, public :: arg_element_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: v type, public :: arg_t Components Type Visibility Attributes Name Initial type( arg_element_t ), public, allocatable :: arg (:) integer, public :: argc character(len=:), public, allocatable :: entire type, public :: cmd_t Components Type Visibility Attributes Name Initial character(len=LEN_CMD), public, allocatable :: subc (:) character(len=LEN_CMD), private :: name = '' Type-Bound Procedures procedure, public :: get_name => cmd__get_name procedure, public :: set_name => cmd__set_name type, public :: flag_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_f character(len=32), public :: name character(len=:), public, allocatable :: short_f type, public :: pattern_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: p Functions private pure function cmd__get_name (self) result(res) Arguments Type Intent Optional Attributes Name class( cmd_t ), intent(in) :: self Return Value character(len=:), allocatable Subroutines private pure subroutine cmd__set_name (self, name) Arguments Type Intent Optional Attributes Name class( cmd_t ), intent(inout) :: self character(len=*), intent(in) :: name","tags":"","loc":"module/forgex_cli_type_m.html"},{"title":"forgex_cli_help_messages_m – Forgex—Fortran Regular Expression","text":"Uses forgex_cli_parameters_m iso_fortran_env Variables Type Visibility Attributes Name Initial integer(kind=int32), private, parameter :: CMD_DESC_SIZ = 109 integer(kind=int32), private, parameter :: CMD_SIZ = 26 integer(kind=int32), private, parameter :: LINE_SIZ = 128 Subroutines public  subroutine print_help () Arguments None public  subroutine print_help_debug () Arguments None public  subroutine print_help_debug_ast () Arguments None public  subroutine print_help_debug_thompson () Arguments None public  subroutine print_help_find () Arguments None public  subroutine print_help_find_match () Arguments None public  subroutine print_help_find_match_dense_dfa () Arguments None public  subroutine print_help_find_match_forgex_api () Arguments None public  subroutine print_help_find_match_lazy_dfa () Arguments None private  subroutine generate_and_output (header, usage, choice, cmd, cmd_desc, desc) Arguments Type Intent Optional Attributes Name character(len=LINE_SIZ), intent(in) :: header character(len=LINE_SIZ), intent(in) :: usage (:) character(len=*), intent(in) :: choice character(len=CMD_SIZ), intent(in) :: cmd (:) character(len=CMD_DESC_SIZ), intent(in) :: cmd_desc (:) character(len=LINE_SIZ), intent(in), optional :: desc (:)","tags":"","loc":"module/forgex_cli_help_messages_m.html"},{"title":"forgex_cli_debug_m – Forgex—Fortran Regular Expression","text":"Uses forgex_enums_m forgex_cli_utils_m forgex_cli_time_measurement_m forgex_cli_parameters_m iso_fortran_env forgex_cli_help_messages_m Subroutines public  subroutine do_debug_ast (flags, pattern) Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern public  subroutine do_debug_thompson (flags, pattern) Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern","tags":"","loc":"module/forgex_cli_debug_m.html"},{"title":"forgex_cli_cla_m – Forgex—Fortran Regular Expression","text":"Uses forgex_cli_type_m forgex forgex_cli_utils_m forgex_cli_parameters_m iso_fortran_env forgex_cli_help_messages_m Variables Type Visibility Attributes Name Initial type( cmd_t ), public :: all_cmds (NUM_CMD) type( flag_t ), public :: all_flags (NUM_FLAGS) Derived Types type, public :: cla_t Components Type Visibility Attributes Name Initial type( arg_t ), public :: arg_info type( cmd_t ), public :: cmd integer, public :: flag_idx (NUM_FLAGS) logical, public :: flags (NUM_FLAGS) type( pattern_t ), public, allocatable :: patterns (:) type( cmd_t ), public :: sub_cmd type( cmd_t ), public :: sub_sub_cmd Type-Bound Procedures procedure, public :: collect_flags => cla__collect_flags procedure, public :: do_debug => cla__do_debug_subc procedure, public :: do_find => cla__do_find_subc procedure, public :: get_patterns => cla__get_patterns procedure, public :: init => cla__initialize procedure, public :: init_debug => cla__init_debug_subc procedure, public :: init_find => cla__init_find_subc procedure, public :: init_find_match => cla__init_find_match_subsubc procedure, public :: read_cmd => cla__read_command procedure, public :: read_subc => cla__read_subcommand procedure, public :: read_subsubc => cla__read_sub_subcommand Subroutines private  subroutine cla__collect_flags (cla) Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__do_debug_subc (cla) Processes the debug command, reads a subcommand, and calls the corresponding procedure. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__do_find_subc (cla) Processes the debug command, reads a subcommand and a sub-subcommand,\nand calls the corresponding procedure. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__get_patterns (cla, offset) Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla integer, intent(in) :: offset private  subroutine cla__init_debug_subc (cla) Prepare subcommands for the debug command. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__init_find_match_subsubc (cla) Prepare sub-subcommands for the match subcommand. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__init_find_subc (cla) Prepare subcommands for the find command. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__initialize (cla) Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__read_command (cla) Read the first argument and match it with registered commands. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__read_sub_subcommand (cla) Read the third argument and match it with registered sub-subcommands. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__read_subcommand (cla) Read the second argument and match it with registered subcommands. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine init_commands () Arguments None private  subroutine init_flags () This subroutine registers all the flags forgex-cli accepts for the flag_t type array all_flags . Arguments None","tags":"","loc":"module/forgex_cli_cla_m.html"},{"title":"forgex_cli_memory_calculation_m – Forgex—Fortran Regular Expression","text":"Uses forgex_parameters_m Functions public  function mem_dfa_graph (graph) result(res) Arguments Type Intent Optional Attributes Name type(dfa_graph_t), intent(in) :: graph Return Value integer public  function mem_nfa_graph (graph) result(res) Arguments Type Intent Optional Attributes Name type(nfa_graph_t), intent(in) :: graph Return Value integer public  function mem_tape (tape) result(res) Arguments Type Intent Optional Attributes Name type(tape_t), intent(in) :: tape Return Value integer public  function mem_tree (tree) result(res) Arguments Type Intent Optional Attributes Name type(tree_node_t), intent(in) :: tree (:) Return Value integer","tags":"","loc":"module/forgex_cli_memory_calculation_m.html"},{"title":"forgex_cli_utils_m – Forgex—Fortran Regular Expression","text":"Uses forgex_cli_parameters_m iso_fortran_env forgex_cli_type_m Interfaces public        interface operator(.in.) private pure function does_flag_exist (arg, flag_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( flag_t ), intent(in) :: flag_list (:) Return Value logical private pure function does_command_exist (arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg character(len=LEN_CMD), intent(in) :: cmd_list (:) Return Value logical private pure function does_command_exist_type_cmd (arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( cmd_t ), intent(in) :: cmd_list (:) Return Value logical private  function is_arg_contained_in_flags (arg, flags) result(res) Arguments Type Intent Optional Attributes Name type( arg_element_t ), intent(in) :: arg type( flag_t ), intent(in) :: flags (:) Return Value logical Functions public  function get_flag_index (arg, flags) result(res) Arguments Type Intent Optional Attributes Name type( arg_element_t ), intent(in) :: arg type( flag_t ), intent(in) :: flags (:) Return Value integer public  function get_os_type () result(res) Read more… Arguments None Return Value integer public  function text_highlight_green (string, from, to) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer(kind=int32), intent(in) :: from integer(kind=int32), intent(in) :: to Return Value character(len=:), allocatable private pure function does_command_exist (arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg character(len=LEN_CMD), intent(in) :: cmd_list (:) Return Value logical private pure function does_command_exist_type_cmd (arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( cmd_t ), intent(in) :: cmd_list (:) Return Value logical private pure function does_flag_exist (arg, flag_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( flag_t ), intent(in) :: flag_list (:) Return Value logical private  function is_arg_contained_in_flags (arg, flags) result(res) Arguments Type Intent Optional Attributes Name type( arg_element_t ), intent(in) :: arg type( flag_t ), intent(in) :: flags (:) Return Value logical Subroutines public  subroutine get_arg_command_line (argc, arg, entire) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: argc type( arg_element_t ), intent(inout), allocatable :: arg (:) character(len=:), intent(inout), allocatable :: entire public  subroutine info (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str public  subroutine register_cmd (cmd, name) Arguments Type Intent Optional Attributes Name type( cmd_t ), intent(inout) :: cmd character(len=*), intent(in) :: name public  subroutine register_flag (flag, name, long, short) Arguments Type Intent Optional Attributes Name type( flag_t ), intent(inout) :: flag character(len=*), intent(in) :: name character(len=*), intent(in) :: long character(len=*), intent(in), optional :: short public  subroutine right_justify (array) Arguments Type Intent Optional Attributes Name character(len=NUM_DIGIT_KEY), intent(inout) :: array (:)","tags":"","loc":"module/forgex_cli_utils_m.html"},{"title":"cli_time_measurement_m.F90 – Forgex—Fortran Regular Expression","text":"This file provides procedures for time measurement. Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_time_measurement_m module is a part of Forgex. ! !! This file provides procedures for time measurement. ! !> This module provides procedures to measure the time it takes to execute. module forgex_cli_time_measurement_m use , intrinsic :: iso_fortran_env , only : real64 , stderr => error_unit use , intrinsic :: iso_c_binding , only : c_long_long , c_bool !$ use :: omp_lib use :: forgex_cli_parameters_m , only : NUM_DIGIT_TIME use :: forgex_cli_utils_m , only : get_os_type use :: forgex_enums_m , only : OS_WINDOWS implicit none private public :: time_begin , time_lap public :: get_lap_time_in_appropriate_unit real ( real64 ) :: begin_s , last_s , end_s integer ( c_long_long ) :: time_begin_qhc , time_end_qhc , frequency logical ( c_bool ) :: is_supported = . false . logical ( c_bool ) :: is_succeeded = . false . !> For Windows, use high-resolution system call for timing. interface function QueryPerformanceCounter ( PerformanceCount_count ) result ( is_succeeded_c ) & bind ( c , name = \"QueryPerformanceCounter\" ) use , intrinsic :: iso_c_binding implicit none integer ( c_long_long ), intent ( out ) :: PerformanceCount_count logical ( c_bool ) :: is_succeeded_c end function QueryPerformanceCounter function QueryPerformanceFrequency ( Frequency_countPerSec ) result ( is_supported_c ) & bind ( c , name = \"QueryPerformanceFrequency\" ) use , intrinsic :: iso_c_binding implicit none integer ( c_long_long ), intent ( out ) :: Frequency_countPerSec logical ( c_bool ) :: is_supported_c end function QueryPerformanceFrequency end interface !! cf. https://qiita.com/implicit_none/items/86c9117990798c1e8b3b contains !> This subroutine is for timing purpose and starts a stopwatch. subroutine time_begin () implicit none if ( get_os_type () == OS_WINDOWS ) then is_supported = QueryPerformanceFrequency ( frequency ) if ( is_supported ) then is_succeeded = QueryPerformanceCounter ( time_begin_qhc ) else !$ begin_s = omp_get_wtime() !$ last_s = begin_s !$ return call use_cpu_time_begin end if else !$ begin_s = omp_get_wtime() !$ last_s = begin_s !$ return call use_cpu_time_begin end if contains subroutine use_cpu_time_begin implicit none begin_s = 0 d0 last_s = 0 d0 end_s = 0 d0 call cpu_time ( begin_s ) last_s = begin_s end subroutine use_cpu_time_begin end subroutine time_begin !> This function is for timing purposes and returns the lap time !> since the last call of `time_begin` or `time_lap`. function time_lap () result ( res ) implicit none real ( real64 ) :: res if ( get_os_type () == OS_WINDOWS ) then if ( is_supported ) then is_succeeded = QueryPerformanceCounter ( time_end_qhc ) res = dble ( time_end_qhc - time_begin_qhc ) / dble ( frequency ) time_begin_qhc = time_end_qhc else !$ end_s = omp_get_wtime() !$ res = end_s - last_s !$ last_s = end_s !$ return call use_cpu_time_end end if else !$ end_s = omp_get_wtime() !$ res = end_s - last_s !$ last_s = end_s !$ return call use_cpu_time_end end if contains subroutine use_cpu_time_end implicit none call cpu_time ( end_s ) res = end_s - last_s last_s = end_s end subroutine use_cpu_time_end end function time_lap !> This function takes a real number of seconds, converts it to the appropriate !> units, and returns a string with the unit for output. function get_lap_time_in_appropriate_unit ( lap_time ) result ( res ) implicit none real ( real64 ), intent ( in ) :: lap_time character ( NUM_DIGIT_TIME ) :: res character ( 3 ) :: unit real ( real64 ) :: multiplied unit = 's' if ( lap_time >= 6 d1 ) then unit = 'm' multiplied = lap_time / 6 d1 else if ( lap_time >= 1 d0 ) then unit = 's' multiplied = lap_time else if ( lap_time >= 1 d - 3 ) then unit = 'ms' multiplied = lap_time * 1 d3 else if ( lap_time >= 1 d - 6 ) then if ( get_os_type () == OS_WINDOWS ) then unit = 'us' else unit = 'μs' end if multiplied = lap_time * 1 d6 else unit = 'ns' multiplied = lap_time * 1 d9 end if write ( res , '(f10.1, a)' ) multiplied , unit end function get_lap_time_in_appropriate_unit end module forgex_cli_time_measurement_m","tags":"","loc":"sourcefile/cli_time_measurement_m.f90.html"},{"title":"cli_find_m.f90 – Forgex—Fortran Regular Expression","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_find_m module is a part of Forgex. ! module forgex_cli_find_m use , intrinsic :: iso_fortran_env , stdout => output_unit use :: forgex_cli_parameters_m use :: forgex_enums_m use :: forgex_cli_time_measurement_m use :: forgex_cli_help_messages_m use :: forgex_cli_utils_m , only : right_justify implicit none private public :: do_find_match_forgex public :: do_find_match_lazy_dfa public :: do_find_match_dense_dfa contains subroutine do_find_match_forgex ( flags , pattern , text , is_exactly ) use :: forgex , only : regex , operator (. in .), operator (. match .) use :: forgex_parameters_m , only : INVALID_CHAR_INDEX use :: forgex_cli_time_measurement_m use :: forgex_cli_utils_m , only : text_highlight_green implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern , text logical , intent ( in ) :: is_exactly real ( real64 ) :: lap logical :: res character (:), allocatable :: res_string integer :: from , to , unused res_string = '' from = INVALID_CHAR_INDEX to = INVALID_CHAR_INDEX call time_begin () if ( is_exactly ) then res = pattern . match . text else res = pattern . in . text end if lap = time_lap () ! Invoke regex subroutine to highlight matched substring. call regex ( pattern , text , res_string , unused , from , to ) output : block character ( NUM_DIGIT_KEY ) :: pattern_key , text_key character ( NUM_DIGIT_KEY ) :: total_time , matching_result character ( NUM_DIGIT_KEY ) :: buf ( 4 ) pattern_key = \"pattern:\" text_key = \"text:\" total_time = \"time:\" matching_result = \"result:\" if ( flags ( FLAG_NO_TABLE )) then write ( stdout , * ) res else buf = [ pattern_key , text_key , total_time , matching_result ] call right_justify ( buf ) write ( stdout , '(a, 1x, a)' ) trim ( buf ( 1 )), trim ( adjustl ( pattern )) write ( stdout , '(a, 1x, a)' ) trim ( buf ( 2 )), '\"' // text_highlight_green ( text , from , to ) // '\"' write ( stdout , fmt_out_time ) trim ( buf ( 3 )), get_lap_time_in_appropriate_unit ( lap ) write ( stdout , fmt_out_logi ) trim ( buf ( 4 )), res end if end block output end subroutine do_find_match_forgex subroutine do_find_match_lazy_dfa ( flags , pattern , text , is_exactly ) use :: forgex_automaton_m use :: forgex_syntax_tree_graph_m use :: forgex_syntax_tree_optimize_m use :: forgex_cli_memory_calculation_m use :: forgex_api_internal_m use :: forgex_nfa_state_set_m use :: forgex_cli_utils_m use :: forgex_utility_m , only : is_there_caret_at_the_top , is_there_dollar_at_the_end use :: forgex_parameters_m , only : ACCEPTED_EMPTY implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern character ( * ), intent ( in ) :: text logical , intent ( in ) :: is_exactly type ( tree_t ) :: tree type ( automaton_t ) :: automaton integer :: uni , ierr , i character (:), allocatable :: dfa_for_print , prefix , suffix , entire character ( 256 ) :: line real ( real64 ) :: lap1 , lap2 , lap3 , lap4 , lap5 logical :: res , flag_runs_engine , flag_fixed_string integer :: from , to dfa_for_print = '' lap1 = 0 d0 lap2 = 0 d0 lap3 = 0 d0 lap4 = 0 d0 lap5 = 0 d0 from = 0 to = 0 prefix = '' suffix = '' entire = '' flag_fixed_string = . false . flag_runs_engine = . false . if ( flags ( FLAG_HELP ) . or . pattern == '' ) call print_help_find_match_lazy_dfa call time_begin () call tree % build ( trim ( pattern )) lap1 = time_lap () call time_begin () if (. not . flags ( FLAG_NO_LITERAL )) then entire = get_entire_literal ( tree ) if ( entire /= '' ) flag_fixed_string = . true . if (. not . flag_fixed_string ) then prefix = get_prefix_literal ( tree ) suffix = get_suffix_literal ( tree ) end if end if lap5 = time_lap () if (. not . flag_fixed_string ) then call automaton % preprocess ( tree ) lap2 = time_lap () call automaton % init () lap3 = time_lap () end if if ( is_exactly ) then if ( flag_fixed_string ) then if ( len ( text ) == len ( entire )) then res = text == entire end if else call runner_do_matching_exactly ( automaton , text , res , prefix , suffix , flags ( FLAG_NO_LITERAL ), flag_runs_engine ) end if lap4 = time_lap () if ( res ) then from = 1 to = len ( text ) end if else block if ( flag_fixed_string ) then from = index ( text , entire ) if ( from > 0 ) to = from + len ( entire ) - 1 else call runner_do_matching_including ( automaton , text , from , to , & prefix , suffix , flags ( FLAG_NO_LITERAL ), flag_runs_engine ) end if if ( from > 0 . and . to > 0 ) then res = . true . else if ( from == ACCEPTED_EMPTY . and . to == ACCEPTED_EMPTY ) then res = . true . else res = . false . end if lap4 = time_lap () end block end if open ( newunit = uni , status = 'scratch' ) write ( uni , fmta ) HEADER_NFA call automaton % nfa % print ( uni , automaton % nfa_exit ) write ( uni , fmta ) HEADER_DFA call automaton % print_dfa ( uni ) rewind ( uni ) ierr = 0 do while ( ierr == 0 ) read ( uni , fmta , iostat = ierr ) line if ( ierr /= 0 ) exit if ( get_os_type () == OS_WINDOWS ) then dfa_for_print = dfa_for_print // trim ( line ) // CRLF else dfa_for_print = dfa_for_print // trim ( line ) // LF end if end do close ( uni ) output : block character ( NUM_DIGIT_KEY ) :: pattern_key , text_key character ( NUM_DIGIT_KEY ) :: parse_time , extract_time character ( NUM_DIGIT_KEY ) :: nfa_time , dfa_init_time , matching_time , memory character ( NUM_DIGIT_KEY ) :: runs_engine_key character ( NUM_DIGIT_KEY ) :: tree_count character ( NUM_DIGIT_KEY ) :: nfa_count character ( NUM_DIGIT_KEY ) :: dfa_count , matching_result character ( NUM_DIGIT_KEY ) :: cbuff ( 13 ) = '' integer :: memsiz pattern_key = \"pattern:\" text_key = \"text:\" parse_time = \"parse time:\" extract_time = \"extract literal time:\" runs_engine_key = \"runs engine:\" nfa_time = \"compile nfa time:\" dfa_init_time = \"dfa initialize time:\" matching_time = \"search time:\" memory = \"memory (estimated):\" matching_result = \"matching result:\" tree_count = \"tree node count:\" nfa_count = \"nfa states:\" dfa_count = \"dfa states:\" if ( flag_fixed_string ) then memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) else memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) + mem_nfa_graph ( automaton % nfa ) & + mem_dfa_graph ( automaton % dfa ) + 4 * 3 end if if ( allocated ( automaton % entry_set % vec )) then memsiz = memsiz + size ( automaton % entry_set % vec , dim = 1 ) end if if ( allocated ( automaton % all_segments )) then memsiz = memsiz + size ( automaton % all_segments , dim = 1 ) * 8 end if if ( flags ( FLAG_VERBOSE )) then cbuff = [ pattern_key , text_key , parse_time , extract_time , runs_engine_key , & nfa_time , dfa_init_time , matching_time , matching_result , memory , tree_count , & nfa_count , dfa_count ] call right_justify ( cbuff ) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 1 )), trim ( adjustl ( pattern )) ! write(stdout, '(a, 1x, a)') trim(cbuff(2)), '\"'//text//'\"' write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 2 )), '\"' // text_highlight_green ( text , from , to ) // '\"' write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 5 )), flag_runs_engine if ( flag_runs_engine . or . . not . flag_fixed_string ) then write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap3 ) else write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), not_running write ( stdout , fmt_out_char ) trim ( cbuff ( 7 )), not_running end if write ( stdout , fmt_out_time ) trim ( cbuff ( 8 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 9 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 10 )), memsiz write ( stdout , fmt_out_ratio ) trim ( cbuff ( 11 )), tree % top , size ( tree % nodes , dim = 1 ) write ( stdout , fmt_out_ratio ) trim ( cbuff ( 12 )), automaton % nfa % nfa_top , automaton % nfa % nfa_limit write ( stdout , fmt_out_ratio ) trim ( cbuff ( 13 )), automaton % dfa % dfa_top , automaton % dfa % dfa_limit else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff (:) = [ pattern_key , text_key , parse_time , extract_time , runs_engine_key , nfa_time , dfa_init_time , & matching_time , matching_result , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 3 )] call right_justify ( cbuff ) write ( stdout , '(a,1x,a)' ) trim ( cbuff ( 1 )), pattern ! write(stdout, '(a,1x,a)') trim(cbuff(2)), \"'\"//text//\"'\" write ( stdout , '(a,1x,a)' ) trim ( cbuff ( 2 )), \"'\" // text_highlight_green ( text , from , to ) // \"'\" write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 5 )), flag_runs_engine if ( flag_runs_engine . or . . not . flag_fixed_string ) then write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap3 ) else write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), not_running write ( stdout , fmt_out_char ) trim ( cbuff ( 7 )), not_running end if write ( stdout , fmt_out_time ) trim ( cbuff ( 8 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 9 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 10 )), memsiz end if if ( flags ( FLAG_TABLE_ONLY ) . or . . not . flag_runs_engine . or . flag_fixed_string ) then call automaton % free return end if write ( stdout , * ) \"\" write ( stdout , fmta , advance = 'no' ) trim ( dfa_for_print ) write ( stdout , fmta ) FOOTER end block output call automaton % free end subroutine do_find_match_lazy_dfa subroutine do_find_match_dense_dfa ( flags , pattern , text , is_exactly ) use :: forgex_automaton_m use :: forgex_syntax_tree_graph_m use :: forgex_cli_memory_calculation_m use :: forgex_cli_time_measurement_m use :: forgex_dense_dfa_m use :: forgex_nfa_state_set_m use :: forgex_cli_utils_m use :: forgex_utility_m implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern character ( * ), intent ( in ) :: text logical , intent ( in ) :: is_exactly type ( tree_t ) :: tree type ( automaton_t ) :: automaton integer :: uni , ierr , i character (:), allocatable :: dfa_for_print character ( 256 ) :: line real ( real64 ) :: lap1 , lap2 , lap3 , lap4 , lap5 logical :: res integer :: from , to from = 0 to = 0 if ( flags ( FLAG_HELP ) . or . pattern == '' ) call print_help_find_match_dense_dfa if ( flags ( FLAG_NO_LITERAL )) call info ( \"No literal search optimization is implemented in dense DFA.\" ) call time_begin () ! call build_syntax_tree(trim(pattern), tape, tree, root) call tree % build ( trim ( pattern )) lap1 = time_lap () call automaton % preprocess ( tree ) lap2 = time_lap () ! build nfa call automaton % init () lap3 = time_lap () ! automaton initialize call construct_dense_dfa ( automaton , automaton % initial_index ) lap4 = time_lap () ! compile nfa to dfa if ( is_exactly ) then res = match_dense_dfa_exactly ( automaton , text ) if ( res ) then from = 1 to = len ( text ) end if else block call match_dense_dfa_including ( automaton , char ( 10 ) // text // char ( 10 ), from , to ) if ( is_there_caret_at_the_top ( pattern )) then from = from else from = from - 1 end if if ( is_there_dollar_at_the_end ( pattern )) then to = to - 2 else to = to - 1 end if if ( from > 0 . and . to > 0 ) then res = . true . else res = . false . end if end block end if lap5 = time_lap () ! search time open ( newunit = uni , status = 'scratch' ) write ( uni , fmta ) HEADER_NFA call automaton % nfa % print ( uni , automaton % nfa_exit ) write ( uni , fmta ) HEADER_DFA call automaton % print_dfa ( uni ) rewind ( uni ) ierr = 0 dfa_for_print = '' do while ( ierr == 0 ) read ( uni , fmta , iostat = ierr ) line if ( ierr /= 0 ) exit if ( get_os_type () == OS_WINDOWS ) then dfa_for_print = dfa_for_print // trim ( line ) // CRLF else dfa_for_print = dfa_for_print // trim ( line ) // LF end if end do close ( uni ) output : block character ( NUM_DIGIT_KEY ) :: pattern_key , text_key character ( NUM_DIGIT_KEY ) :: parse_time , nfa_time , dfa_init_time , dfa_compile_time , matching_time character ( NUM_DIGIT_KEY ) :: memory character ( NUM_DIGIT_KEY ) :: tree_count , nfa_count , dfa_count character ( NUM_DIGIT_KEY ) :: matching_result character ( NUM_DIGIT_KEY ) :: cbuff ( 12 ) = '' integer :: memsiz pattern_key = \"pattern:\" text_key = \"text:\" parse_time = \"parse time:\" nfa_time = \"compile nfa time:\" dfa_init_time = \"dfa initialize time:\" dfa_compile_time = \"compile dfa time:\" matching_time = \"search time:\" memory = \"memory (estimated):\" matching_result = \"matching result:\" tree_count = \"tree node count:\" nfa_count = \"nfa states:\" dfa_count = \"dfa states:\" memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) + mem_nfa_graph ( automaton % nfa ) & + mem_dfa_graph ( automaton % dfa ) + 4 * 3 if ( allocated ( automaton % entry_set % vec )) then memsiz = memsiz + size ( automaton % entry_set % vec , dim = 1 ) end if if ( allocated ( automaton % all_segments )) then memsiz = memsiz + size ( automaton % all_segments , dim = 1 ) * 8 end if if ( flags ( FLAG_VERBOSE )) then cbuff = [ pattern_key , text_key , parse_time , nfa_time , dfa_init_time , dfa_compile_time , matching_time ,& matching_result , memory , tree_count , nfa_count , dfa_count ] call right_justify ( cbuff ) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 1 )), trim ( adjustl ( pattern )) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 2 )), \"'\" // text_highlight_green ( text , from , to ) // \"'\" write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 5 )), get_lap_time_in_appropriate_unit ( lap3 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 8 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 9 )), memsiz write ( stdout , fmt_out_ratio ) trim ( cbuff ( 10 )), tree % top , size ( tree % nodes , dim = 1 ) write ( stdout , fmt_out_ratio ) trim ( cbuff ( 11 )), automaton % nfa % nfa_top , automaton % nfa % nfa_limit write ( stdout , fmt_out_ratio ) trim ( cbuff ( 12 )), automaton % dfa % dfa_top , automaton % dfa % dfa_limit else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff = [ pattern_key , text_key , parse_time , nfa_time , dfa_init_time , dfa_compile_time , matching_time ,& matching_result , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 3 )] call right_justify ( cbuff ) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 1 )), trim ( adjustl ( pattern )) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 2 )), \"'\" // text_highlight_green ( text , from , to ) // \"'\" write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 5 )), get_lap_time_in_appropriate_unit ( lap3 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 8 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 9 )), memsiz end if if ( flags ( FLAG_TABLE_ONLY )) then call automaton % free () return end if write ( stdout , * ) \"\" write ( stdout , fmta , advance = 'no' ) trim ( dfa_for_print ) write ( stdout , fmta ) FOOTER end block output call automaton % free () end subroutine do_find_match_dense_dfa subroutine runner_do_matching_exactly ( automaton , text , res , prefix , suffix , flag_no_literal_optimize , runs_engine ) use :: forgex_automaton_m use :: forgex_syntax_tree_optimize_m use :: forgex_cli_api_internal_no_opts_m use :: forgex_api_internal_m implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: text logical , intent ( inout ) :: res logical , intent ( inout ) :: runs_engine logical , intent ( in ) :: flag_no_literal_optimize character ( * ), intent ( in ) :: prefix , suffix if ( flag_no_literal_optimize ) then call do_matching_exactly_no_literal_opts ( automaton , text , res ) runs_engine = . true . else call do_matching_exactly ( automaton , text , res , prefix , suffix , runs_engine ) end if end subroutine runner_do_matching_exactly subroutine runner_do_matching_including ( automaton , text , from , to , prefix , suffix , flag_no_literal_optimize , runs_engine ) use :: forgex_syntax_tree_optimize_m use :: forgex_automaton_m use :: forgex_api_internal_m use :: forgex_cli_api_internal_no_opts_m implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: text integer ( int32 ), intent ( inout ) :: from , to character ( * ), intent ( in ) :: prefix , suffix logical , intent ( in ) :: flag_no_literal_optimize logical , intent ( inout ) :: runs_engine if ( flag_no_literal_optimize ) then call do_matching_including_no_literal_opts ( automaton , text , from , to ) runs_engine = . true . else call do_matching_including ( automaton , text , from , to , prefix , suffix , runs_engine ) end if end subroutine runner_do_matching_including end module forgex_cli_find_m","tags":"","loc":"sourcefile/cli_find_m.f90.html"},{"title":"cli_api_internal_no_opts_m.f90 – Forgex—Fortran Regular Expression","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_api_internal_no_opts_m module is a part of Forgex. ! module forgex_cli_api_internal_no_opts_m use :: forgex_automaton_m use :: forgex_parameters_m use :: forgex_utf8_m implicit none contains !> This procedure reads a text, performs regular expression matching using an automaton, !> and stores the string index in the argument if it contains a match. subroutine do_matching_including_no_literal_opts ( automaton , string , from , to ) use :: forgex_utility_m implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: string integer , intent ( inout ) :: from , to integer :: cur_i , dst_i ! current and destination index of DFA nodes integer :: ci ! character index integer :: next_ci ! next character index integer :: max_match ! maximum value of match attempts integer :: start ! starting character index integer :: i character (:), allocatable :: str str = string from = 0 to = 0 str = char ( 0 ) // string // char ( 0 ) cur_i = automaton % initial_index if ( cur_i == DFA_NOT_INIT ) then error stop \"DFA have not been initialized.\" end if if ( len ( string ) <= 1 . and . string == '' ) then if ( automaton % dfa % nodes ( cur_i )% accepted ) then from = ACCEPTED_EMPTY to = ACCEPTED_EMPTY end if return end if loop_init : block i = 1 start = i end block loop_init do while ( start < len ( str )) max_match = 0 ci = start cur_i = automaton % initial_index ! Traverse the DFA with the input string from the current starting position of ``cur_i`. do while ( cur_i /= DFA_INVALID_INDEX ) if ( automaton % dfa % nodes ( cur_i )% accepted . and . ci /= start ) then max_match = ci end if if ( ci > len ( str )) exit next_ci = idxutf8 ( str , ci ) + 1 call automaton % construct ( cur_i , dst_i , str ( ci : next_ci - 1 )) cur_i = dst_i ci = next_ci end do ! Update match position if a match is found. if ( max_match > 0 ) then from = start - 1 if ( from == 0 ) from = 1 ! handle leading NULL character. if ( max_match >= len ( str )) then to = len ( string ) else to = max_match - 2 end if return end if start = idxutf8 ( str , start ) + 1 ! Bruteforce searching end do end subroutine do_matching_including_no_literal_opts !> This subroutine is intended to be called from the `forgex_cli_find_m` module. subroutine do_matching_exactly_no_literal_opts ( automaton , string , res ) implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: string logical , intent ( inout ) :: res integer :: cur_i , dst_i ! current and destination index of DFA nodes integer :: ci ! character index integer :: next_ci ! next character index integer :: max_match ! character (:), allocatable :: str ! Initialize `cur_i` with automaton's initial index. cur_i = automaton % initial_index ! If the DFA have not been initialized, abort the program. if ( cur_i == DFA_NOT_INIT ) then error stop \"DFA have not been initialized.\" end if ! If the input string is an empty string, returns a logical value ! indicating whether the current state is accepting or not. if ( len ( string ) == 0 ) then res = automaton % dfa % nodes ( cur_i )% accepted return end if ! Initialize counter variables. max_match = 0 ci = 1 str = char ( 0 ) // string // char ( 0 ) ! Loop and proceed with matching unless the current index is DFA_INVALID_INDEX. do while ( cur_i /= DFA_INVALID_INDEX ) ! If the current state acceptable, the value of `max_match` is updated with `i`. if ( automaton % dfa % nodes ( cur_i )% accepted ) then max_match = ci end if if ( ci > len ( str )) exit ! Get the index of the next character and assign it to `next_ci`. next_ci = idxutf8 ( str , ci ) + 1 ! Lazy evaluation is performed by calling this procedure here. ! The index of destination DFA node is stored in the `dst_i` variable. call automaton % construct ( cur_i , dst_i , str ( ci : next_ci - 1 )) ! If there is mismatch in the first byte of the NULL character, try again with the second byte. if ( dst_i == DFA_INVALID_INDEX . and . ci == 1 ) then ci = 2 next_ci = idxutf8 ( str , ci ) + 1 call automaton % construct ( cur_i , dst_i , str ( ci : next_ci - 1 )) end if ! update counters cur_i = dst_i ci = next_ci end do ! If the maximum index of the match is one larger than length of the string, ! this function returns true, otherwise it returns false. if ( max_match >= len ( string ) + 2 ) then res = . true . else res = . false . end if end subroutine do_matching_exactly_no_literal_opts end module forgex_cli_api_internal_no_opts_m","tags":"","loc":"sourcefile/cli_api_internal_no_opts_m.f90.html"},{"title":"cli_parameter_m.f90 – Forgex—Fortran Regular Expression","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_parameter_m module is a part of Forgex. ! module forgex_cli_parameters_m implicit none private !> Number of flags (without value) that forgex-cli accepts. integer , parameter , public :: NUM_FLAGS = 5 !> Number of sub-command that forgec-cli accepts. integer , parameter , public :: NUM_CMD = 2 !> Length integer , parameter , public :: LEN_CMD = 16 !> Number of digits for time display. integer , parameter , public :: NUM_DIGIT_TIME = 13 !> Maximum langth of table field name. integer , parameter , public :: NUM_DIGIT_KEY = 32 !> Maximum length of an environment variable's value. integer , parameter , public :: LEN_ENV_VAR = 255 !> The buffer length of displaying the AST. integer , parameter , public :: TREE_BUFF_LEN = 2 ** 16 !---------------------------------------------------------------------! !> Name of the subcommand debug. character ( * ), parameter , public :: CMD_DEBUG = \"debug\" !> The number of sub-subcommands that debug accepts. integer , parameter , public :: NUM_SUBC_DEBUG = 2 !> Name of the sub-subcommand ast. character ( * ), parameter , public :: SUBC_AST = \"ast\" !> Name of the sub-subcommand thompson. character ( * ), parameter , public :: SUBC_THOMPSON = \"thompson\" !---------------------------------------------------------------------! !> Name of the subcommand find. character ( * ), parameter , public :: CMD_FIND = \"find\" integer , parameter , public :: NUM_SUBC_FIND = 1 character ( * ), parameter , public :: SUBC_MATCH = \"match\" integer , parameter , public :: NUM_SUBSUBC_MATCH = 3 character ( * ), parameter , public :: ENGINE_LAZY_DFA = \"lazy-dfa\" character ( * ), parameter , public :: ENGINE_DENSE_DFA = \"dense\" character ( * ), parameter , public :: ENGINE_FORGEX_API = \"forgex\" !---------------------------------------------------------------------! !> Name of the sub-subcommand lazy dfa character ( * ), parameter , public :: OP_MATCH = \".match.\" character ( * ), parameter , public :: OP_IN = \".in.\" !> String to indicate invalidity if no short flag is present. character ( * ), parameter , public :: INVALID_FLAG = \"INVALID\" !> Output format for displaying an integer in tables. character ( * ), parameter , public :: fmt_out_int = \"(a, i10)\" character ( * ), parameter , public :: fmt_out_ratio = \"(a, i10, '/', i0)\" character ( * ), parameter , public :: fmt_out_char = \"(a, 1x, a)\" character ( * ), parameter , public :: fmt_out_time = \"(a, a15)\" character ( * ), parameter , public :: fmt_out_logi = \"(a, l10)\" character ( * ), parameter , public :: not_running = \"not running\" !> Format for outputting text only. character ( * ), parameter , public :: fmta = \"(a)\" !> Line ending characters for Windows OS character ( * ), parameter , public :: CRLF = char ( 13 ) // char ( 10 ) !> Line Feed. character ( * ), parameter , public :: LF = char ( 10 ) !> Headers character ( * ), parameter , public :: HEADER_NFA = \"========== Thompson NFA ===========\" character ( * ), parameter , public :: HEADER_DFA = \"=============== DFA ===============\" character ( * ), parameter , public :: FOOTER = \"===================================\" end module forgex_cli_parameters_m","tags":"","loc":"sourcefile/cli_parameter_m.f90.html"},{"title":"cli_type_m.f90 – Forgex—Fortran Regular Expression","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_type_m module is a part of Forgex. ! module forgex_cli_type_m use :: forgex_cli_parameters_m implicit none private type , public :: arg_element_t character (:), allocatable :: v end type arg_element_t type , public :: arg_t integer :: argc type ( arg_element_t ), allocatable :: arg (:) character (:), allocatable :: entire end type arg_t type , public :: pattern_t character (:), allocatable :: p end type pattern_t type , public :: cmd_t ! command type character ( LEN_CMD ), private :: name = '' character ( LEN_CMD ), allocatable :: subc (:) ! sub-command contains procedure :: get_name => cmd__get_name procedure :: set_name => cmd__set_name end type cmd_t ! option flags, such as '--help', '-h' type , public :: flag_t character ( 32 ) :: name character (:), allocatable :: long_f , short_f end type flag_t contains pure function cmd__get_name ( self ) result ( res ) implicit none class ( cmd_t ), intent ( in ) :: self character (:), allocatable :: res res = trim ( self % name ) end function cmd__get_name pure subroutine cmd__set_name ( self , name ) implicit none class ( cmd_t ), intent ( inout ) :: self character ( * ), intent ( in ) :: name self % name = name end subroutine cmd__set_name end module forgex_cli_type_m","tags":"","loc":"sourcefile/cli_type_m.f90.html"},{"title":"cli_help_messages_m.f90 – Forgex—Fortran Regular Expression","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_help_messages_m module is a part of Forgex. ! module forgex_cli_help_messages_m use , intrinsic :: iso_fortran_env , only : stderr => error_unit , int32 use :: forgex_cli_parameters_m , only : fmta implicit none private public :: print_help public :: print_help_debug public :: print_help_debug_ast public :: print_help_debug_thompson public :: print_help_find public :: print_help_find_match public :: print_help_find_match_dense_dfa public :: print_help_find_match_lazy_dfa public :: print_help_find_match_forgex_api integer ( int32 ), parameter :: LINE_SIZ = 128 integer ( int32 ), parameter :: CMD_SIZ = 26 integer ( int32 ), parameter :: CMD_DESC_SIZ = 109 contains subroutine generate_and_output ( header , usage , choice , cmd , cmd_desc , desc ) implicit none character ( LINE_SIZ ), intent ( in ) :: header character ( LINE_SIZ ), intent ( in ) :: usage (:) character ( * ), intent ( in ) :: choice character ( CMD_SIZ ), intent ( in ) :: cmd (:) ! command character ( CMD_DESC_SIZ ), intent ( in ) :: cmd_desc (:) ! description character ( LINE_SIZ ), intent ( in ), optional :: desc (:) character ( LINE_SIZ ), allocatable :: buff (:) integer :: num_line , i , offset if ( present ( desc )) then num_line = 3 + size ( desc ) + size ( usage ) + 2 + size ( cmd ) else num_line = 3 + size ( usage ) + 2 + size ( cmd ) end if ! header + blank + DESC + blank+ USAGE + size(usage) + blank + COMMANDS + size(cmd) allocate ( buff ( num_line )) buff (:) = \"\" buff ( 1 ) = header ! buff(2) blank offset = 2 if ( present ( desc )) then do i = 1 , size ( desc ) buff ( i + offset ) = desc ( i ) end do offset = offset + size ( desc ) endif offset = offset + 1 buff ( offset ) = \"USAGE:\" do i = 1 , size ( usage ) buff ( i + offset ) = \"   \" // trim ( usage ( i )) end do offset = offset + size ( usage ) buff ( offset + 2 ) = trim ( choice ) // \":\" offset = offset + 2 do i = 1 , size ( cmd ) buff ( i + offset ) = \"   \" // cmd ( i ) // \" \" // cmd_desc ( i ) enddo do i = 1 , num_line write ( stderr , fmta ) trim ( buff ( i )) end do stop end subroutine generate_and_output subroutine print_help implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 2 ) character ( CMD_DESC_SIZ ) :: cdesc ( 2 ) header = \"A tool for interacting with Forgex on the command line.\" usage ( 1 ) = \"forgex-cli <command> ...\" cmd ( 1 ) = \"debug\" cdesc ( 1 ) = \"Print the debug representation from Forgex's regex engine.\" cmd ( 2 ) = \"find\" cdesc ( 2 ) = \"Search for a string using one of the regular expression engines.\" call generate_and_output ( header , usage , \"COMMANDS\" , cmd , cdesc ) end subroutine print_help subroutine print_help_debug implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 2 ) character ( CMD_DESC_SIZ ) :: cdesc ( 2 ) header = \"Prints the debug representation provided by Forgex.\" usage ( 1 ) = \"forgex-cli debug <command> ...\" cmd ( 1 ) = \"ast\" cdesc ( 1 ) = \"Print the debug representation of an AST.\" cmd ( 2 ) = \"thompson\" cdesc ( 2 ) = \"Print the debug representation of a Thompson NFA.\" call generate_and_output ( header , usage , \"COMMANDS\" , cmd , cdesc ) end subroutine print_help_debug !=====================================================================! subroutine print_help_debug_ast implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: op ( 3 ) character ( CMD_DESC_SIZ ) :: odesc ( 3 ) header = \"Print the debug representation of an abstract syntax tree (AST).\" usage ( 1 ) = \"forgex-cli debug ast <pattern>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Passing this flag suppresses the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine subroutine print_help_debug_thompson implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: op ( 3 ) character ( CMD_DESC_SIZ ) :: odesc ( 3 ) header = \"Print the debug representaion of a Thompson NFA.\" usage ( 1 ) = \"forgex-cli debug thompson <pattern>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Suppresses the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_debug_thompson !=====================================================================! subroutine print_help_find implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 1 ) character ( CMD_DESC_SIZ ) :: cdesc ( 1 ) header = \"Executes a search.\" usage ( 1 ) = \"forgex-cli find <command> ...\" cmd ( 1 ) = \"match\" cdesc ( 1 ) = \"Search for full matches.\" call generate_and_output ( header , usage , \"COMMANDS\" , cmd , cdesc ) end subroutine print_help_find subroutine print_help_find_match implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 3 ) character ( CMD_DESC_SIZ ) :: cdesc ( 3 ) header = \"Executes a search for full matches.\" usage ( 1 ) = \"forgex-cli find match <engine>\" cmd ( 1 ) = \"dense\" cdesc ( 1 ) = \"Search with the fully-compiled DFA regex engine.\" cmd ( 2 ) = \"lazy-dfa\" cdesc ( 2 ) = \"Search with the lazy DFA regex engine.\" cmd ( 3 ) = \"forgex\" cdesc ( 3 ) = \"Search with the top-level API regex engine.\" call generate_and_output ( header , usage , \"ENGINES\" , cmd , cdesc ) end subroutine print_help_find_match subroutine print_help_find_match_lazy_dfa implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 2 ) character ( CMD_SIZ ) :: op ( 4 ) character ( CMD_DESC_SIZ ) :: odesc ( 4 ) header = \"Executes a search for matches using a lazy DFA regex engine.\" usage ( 1 ) = \"forgex-cli debug lazy-dfa <pattern> .match. <text>\" usage ( 2 ) = \"forgex-cli debug lazy-dfa <pattern> .in. <text>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Suppress the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only. \" op ( 4 ) = \"--disable-literal-optimize\" odesc ( 4 ) = \"Disable literals search optimization.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_find_match_lazy_dfa subroutine print_help_find_match_dense_dfa implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 2 ) character ( CMD_SIZ ) :: op ( 3 ) character ( CMD_DESC_SIZ ) :: odesc ( 3 ) header = \"Execute a search for matches using a fully-compiled DFA regex engine.\" usage ( 1 ) = \"forgex-cli find match dense <pattern> .match. <text>\" usage ( 2 ) = \"forgex-cli find match dense <pattern> .in. <text>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Suppress the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only. \" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_find_match_dense_dfa subroutine print_help_find_match_forgex_api implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 2 ) character ( CMD_SIZ ) :: op ( 1 ) character ( CMD_DESC_SIZ ) :: odesc ( 1 ) header = \"Executes a search for matches using the top-level API regex engine.\" usage ( 1 ) = \"forgex-cli find match forgex <pattern> .match. <text>\" usage ( 2 ) = \"forgex-cli find match forgex <pattern> .in. <text>\" op ( 1 ) = \"--no-table\" odesc ( 1 ) = \"Suppress the output of the property information table.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_find_match_forgex_api end module forgex_cli_help_messages_m","tags":"","loc":"sourcefile/cli_help_messages_m.f90.html"},{"title":"cli_debug_m.f90 – Forgex—Fortran Regular Expression","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_debug_m module is a part of Forgex. ! module forgex_cli_debug_m use , intrinsic :: iso_fortran_env , only : int32 , real64 , stderr => error_unit , stdout => output_unit use :: forgex_cli_time_measurement_m , only : time_begin , time_lap , get_lap_time_in_appropriate_unit use :: forgex_cli_parameters_m , only : NUM_DIGIT_KEY , fmt_out_time , fmt_out_int , fmt_out_ratio , & fmt_out_logi , fmta , fmt_out_char , CRLF , LF , HEADER_DFA , HEADER_NFA , FOOTER use :: forgex_enums_m , only : FLAG_HELP , FLAG_NO_TABLE , FLAG_VERBOSE , FLAG_TABLE_ONLY , OS_WINDOWS use :: forgex_cli_utils_m , only : get_os_type , right_justify use :: forgex_cli_help_messages_m , only : print_help_debug_ast , print_help_debug_thompson implicit none private public :: do_debug_ast public :: do_debug_thompson contains subroutine do_debug_ast ( flags , pattern ) use :: forgex_syntax_tree_graph_m use :: forgex_syntax_tree_optimize_m use :: forgex_cli_memory_calculation_m implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern type ( tree_t ) :: tree integer :: root integer :: uni , ierr , siz character (:), allocatable :: buff character (:), allocatable :: ast , prefix , suffix , entire !, middle real ( real64 ) :: lap1 , lap2 if ( flags ( FLAG_HELP )) call print_help_debug_ast call time_begin call tree % build ( trim ( pattern )) lap1 = time_lap () entire = get_entire_literal ( tree ) prefix = get_prefix_literal ( tree ) ! middle = get_middle_literal(tree) suffix = get_suffix_literal ( tree ) lap2 = time_lap () open ( newunit = uni , status = 'scratch' ) call tree % print ( uni ) inquire ( unit = uni , size = siz ) allocate ( character ( siz + 2 ) :: buff ) rewind ( uni ) read ( uni , fmta , iostat = ierr ) buff close ( uni ) ast = trim ( buff ) output : block character ( NUM_DIGIT_KEY ) :: parse_time , literal_time , tree_count , tree_allocated , & memory , literal_pre , literal_post , literal_all , literal_mid character ( NUM_DIGIT_KEY ) :: cbuff ( 9 ) integer :: i parse_time = \"parse time:\" literal_time = \"extract time:\" tree_count = \"tree node count:\" tree_allocated = \"tree node allocated:\" literal_all = \"extracted literal:\" literal_pre = \"extracted prefix:\" literal_mid = \"extracted middle:\" literal_post = \"extracted suffix:\" memory = \"memory (estimated):\" if ( flags ( FLAG_VERBOSE )) then cbuff = [ parse_time , literal_time , literal_all , literal_pre , literal_mid , literal_post , & memory , tree_count , tree_allocated ] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_char ) trim ( cbuff ( 3 )), entire write ( stdout , fmt_out_char ) trim ( cbuff ( 4 )), prefix ! write(stdout, fmt_out_char) trim(cbuff(5)), middle write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), suffix write ( stdout , fmt_out_int ) trim ( cbuff ( 7 )), mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) write ( stdout , fmt_out_int ) trim ( cbuff ( 8 )), root write ( stdout , fmt_out_int ) trim ( cbuff ( 9 )), size ( tree % nodes , dim = 1 ) else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff = [ parse_time , literal_time , literal_all , literal_pre , literal_mid , & literal_post , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 2 )] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_char ) trim ( cbuff ( 3 )), entire write ( stdout , fmt_out_char ) trim ( cbuff ( 4 )), prefix ! write(stdout, fmt_out_char) trim(cbuff(5)), middle write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), suffix write ( stdout , fmt_out_int ) trim ( cbuff ( 7 )), mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) end if end block output if ( flags ( FLAG_TABLE_ONLY )) return write ( stdout , fmta ) ast end subroutine do_debug_ast subroutine do_debug_thompson ( flags , pattern ) use :: forgex_cli_memory_calculation_m use :: forgex_automaton_m use :: forgex_syntax_tree_graph_m implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern type ( tree_t ) :: tree type ( automaton_t ) :: automaton integer :: root integer :: uni , ierr , i character (:), allocatable :: nfa character ( 256 ) :: line real ( real64 ) :: lap1 , lap2 nfa = '' if ( flags ( FLAG_HELP )) call print_help_debug_thompson if ( pattern == '' ) call print_help_debug_thompson call time_begin () ! call build_syntax_tree(trim(pattern), tree%tape, tree, root) call tree % build ( trim ( pattern )) lap1 = time_lap () call automaton % nfa % build ( tree , automaton % nfa_entry , automaton % nfa_exit , automaton % all_segments ) lap2 = time_lap () open ( newunit = uni , status = 'scratch' ) call automaton % nfa % print ( uni , automaton % nfa_exit ) rewind ( uni ) ierr = 0 do while ( ierr == 0 ) read ( uni , fmta , iostat = ierr ) line if ( ierr /= 0 ) exit if ( get_os_type () == OS_WINDOWS ) then nfa = nfa // trim ( line ) // CRLF else nfa = nfa // trim ( line ) // LF end if end do close ( uni ) output : block character ( NUM_DIGIT_KEY ) :: parse_time , nfa_time , memory , nfa_count , nfa_allocated , tree_count , tree_allocated character ( NUM_DIGIT_KEY ) :: cbuff ( 7 ) = '' integer :: memsiz parse_time = \"parse time:\" nfa_time = \"compile nfa time:\" memory = \"memory (estimated):\" nfa_count = \"nfa states:\" nfa_allocated = \"nfa states allocated:\" tree_count = \"tree node count:\" tree_allocated = \"tree node allocated:\" memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) & + mem_nfa_graph ( automaton % nfa ) + 4 * 3 if ( allocated ( automaton % entry_set % vec )) then memsiz = memsiz + size ( automaton % entry_set % vec , dim = 1 ) end if if ( allocated ( automaton % all_segments )) then memsiz = memsiz + size ( automaton % all_segments , dim = 1 ) * 8 end if if ( flags ( FLAG_VERBOSE )) then cbuff = [ parse_time , nfa_time , memory , tree_count , tree_allocated , nfa_count , nfa_allocated ] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_int ) trim ( cbuff ( 3 )), memsiz write ( stdout , fmt_out_int ) trim ( cbuff ( 4 )), root write ( stdout , fmt_out_int ) trim ( cbuff ( 5 )), size ( tree % nodes , dim = 1 ) write ( stdout , fmt_out_int ) trim ( cbuff ( 6 )), automaton % nfa % nfa_top write ( stdout , fmt_out_int ) trim ( cbuff ( 7 )), automaton % nfa % nfa_limit else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff (:) = [ parse_time , nfa_time , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 4 )] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_int ) trim ( cbuff ( 3 )), memsiz end if if ( flags ( FLAG_TABLE_ONLY )) return write ( stdout , * ) \"\" write ( stdout , fmta ) HEADER_NFA write ( stdout , fmta ) trim ( nfa ) write ( stdout , fmta ) \"Note: all segments of NFA were disjoined with overlapping portions.\" write ( stdout , fmta ) FOOTER end block output end subroutine do_debug_thompson !=====================================================================! end module forgex_cli_debug_m","tags":"","loc":"sourcefile/cli_debug_m.f90.html"},{"title":"cli_cla_m.f90 – Forgex—Fortran Regular Expression","text":"This file includes to handle command line arguments for the tool of forgex-cli. Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_cla_m module is a part of Forgex. ! !! This file includes to handle command line arguments for the tool of forgex-cli. !> module forgex_cli_cla_m use , intrinsic :: iso_fortran_env , only : int32 , real64 , stderr => error_unit use :: forgex , only : operator (. match .) use :: forgex_cli_parameters_m use :: forgex_cli_type_m , only : flag_t , cmd_t , pattern_t , arg_t , arg_element_t use :: forgex_cli_utils_m , only : get_flag_index , operator (. in .), register_flag , register_cmd , & get_arg_command_line use :: forgex_cli_help_messages_m , only : print_help_debug , print_help_debug_ast , & print_help_debug_thompson , print_help_find_match_lazy_dfa , & print_help_find , print_help_find_match , print_help_find_match_lazy_dfa , & print_help_find_match_dense_dfa , print_help_find_match_forgex_api implicit none private type ( flag_t ), public :: all_flags ( NUM_FLAGS ) type ( cmd_t ), public :: all_cmds ( NUM_CMD ) ! The type which represents command line arguments type , public :: cla_t type ( arg_t ) :: arg_info type ( cmd_t ) :: cmd , sub_cmd , sub_sub_cmd type ( pattern_t ), allocatable :: patterns (:) logical :: flags ( NUM_FLAGS ) integer :: flag_idx ( NUM_FLAGS ) contains procedure :: init => cla__initialize procedure :: read_cmd => cla__read_command procedure :: read_subc => cla__read_subcommand procedure :: read_subsubc => cla__read_sub_subcommand procedure :: collect_flags => cla__collect_flags procedure :: get_patterns => cla__get_patterns procedure :: init_debug => cla__init_debug_subc procedure :: init_find => cla__init_find_subc procedure :: init_find_match => cla__init_find_match_subsubc procedure :: do_debug => cla__do_debug_subc procedure :: do_find => cla__do_find_subc end type cla_t contains !=====================================================================! !> This subroutine registers all the flags forgex-cli accepts for the `flag_t` type array `all_flags`. subroutine init_flags () use :: forgex_enums_m implicit none call register_flag ( all_flags ( FLAG_HELP ), 'help' , '--help' , '-h' ) call register_flag ( all_flags ( FLAG_VERBOSE ), 'verbose' , '--verbose' , '-v' ) call register_flag ( all_flags ( FLAG_NO_TABLE ), 'no-table' , '--no-table' ) call register_flag ( all_flags ( FLAG_TABLE_ONLY ), 'table-only' , '--table-only' ) call register_flag ( all_flags ( FLAG_NO_LITERAL ), 'no-literal-optimize' , '--disable-literal-optimize' ) end subroutine init_flags subroutine init_commands () implicit none call register_cmd ( all_cmds ( 1 ), CMD_DEBUG ) call register_cmd ( all_cmds ( 2 ), CMD_FIND ) end subroutine init_commands !=====================================================================! !> Prepare subcommands for the `debug` command. subroutine cla__init_debug_subc ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla allocate ( cla % cmd % subc ( NUM_SUBC_DEBUG )) cla % cmd % subc ( 1 ) = SUBC_AST cla % cmd % subc ( 2 ) = SUBC_THOMPSON end subroutine !> Prepare subcommands for the `find` command. subroutine cla__init_find_subc ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla allocate ( cla % cmd % subc ( NUM_SUBC_FIND )) cla % cmd % subc ( 1 ) = SUBC_MATCH end subroutine cla__init_find_subc !---------------------------------! !> Prepare sub-subcommands for the `match` subcommand. subroutine cla__init_find_match_subsubc ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla allocate ( cla % sub_cmd % subc ( NUM_SUBSUBC_MATCH )) cla % sub_cmd % subc ( 1 ) = ENGINE_LAZY_DFA cla % sub_cmd % subc ( 2 ) = ENGINE_DENSE_DFA cla % sub_cmd % subc ( 3 ) = ENGINE_FORGEX_API end subroutine cla__init_find_match_subsubc !=====================================================================! !> Read the first argument and match it with registered commands. subroutine cla__read_command ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla character (:), allocatable :: cmd if ( ubound ( cla % arg_info % arg , dim = 1 ) < 1 ) then cmd = \"\" return end if cmd = trim ( cla % arg_info % arg ( 1 )% v ) if ( cmd . in . all_cmds ) then call cla % cmd % set_name ( cmd ) else call cla % cmd % set_name ( \"\" ) end if end subroutine cla__read_command !> Read the second argument and match it with registered subcommands. subroutine cla__read_subcommand ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla character (:), allocatable :: cmd integer :: i cmd = trim ( cla % arg_info % arg ( 2 )% v ) do i = 1 , size ( cla % cmd % subc ) if ( cmd == cla % cmd % subc ( i )) then call cla % sub_cmd % set_name ( cmd ) return end if end do end subroutine cla__read_subcommand !> Read the third argument and match it with registered sub-subcommands. subroutine cla__read_sub_subcommand ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla character (:), allocatable :: cmd integer :: i if ( cla % arg_info % argc < 3 ) return cmd = trim ( cla % arg_info % arg ( 3 )% v ) do i = 1 , size ( cla % sub_cmd % subc ) if ( cmd == cla % sub_cmd % subc ( i )) then call cla % sub_sub_cmd % set_name ( cmd ) return end if end do end subroutine cla__read_sub_subcommand !=====================================================================! !> Processes the `debug` command, reads a subcommand, and calls the corresponding procedure. subroutine cla__do_debug_subc ( cla ) use :: forgex_cli_debug_m implicit none class ( cla_t ), intent ( inout ) :: cla integer :: pattern_offset pattern_offset = 3 call cla % init_debug () call cla % read_subc () if ( cla % sub_cmd % get_name () == '' ) then call print_help_debug end if call cla % get_patterns ( pattern_offset ) ! Handle errors when a pattern does not exist. if (. not . allocated ( cla % patterns )) then select case ( cla % sub_cmd % get_name ()) case ( SUBC_AST ) call print_help_debug_ast case ( SUBC_THOMPSON ) call print_help_debug_thompson case default call print_help_debug end select end if if ( size ( cla % patterns ) > 1 ) then write ( stderr , '(a, i0, a)' ) \"Only single pattern is expected, but \" , size ( cla % patterns ), \" were given.\" stop end if select case ( cla % sub_cmd % get_name ()) case ( SUBC_AST ) call do_debug_ast ( cla % flags , cla % patterns ( 1 )% p ) case ( SUBC_THOMPSON ) call do_debug_thompson ( cla % flags , cla % patterns ( 1 )% p ) end select end subroutine cla__do_debug_subc !> Processes the `debug` command, reads a subcommand and a sub-subcommand, !> and calls the corresponding procedure. subroutine cla__do_find_subc ( cla ) use :: forgex_cli_find_m implicit none class ( cla_t ), intent ( inout ) :: cla logical :: is_exactly integer :: pattern_offset character (:), allocatable :: text pattern_offset = 4 call cla % init_find () call cla % read_subc () if ( cla % sub_cmd % get_name () == '' ) then call print_help_find else if ( cla % sub_cmd % get_name () == SUBC_MATCH ) then call cla % init_find_match () endif call cla % read_subsubc () if ( cla % sub_sub_cmd % get_name () == '' ) then select case ( cla % sub_cmd % get_name ()) case ( SUBC_MATCH ) call print_help_find_match end select end if call cla % get_patterns ( pattern_offset ) if (. not . allocated ( cla % patterns )) then select case ( cla % sub_sub_cmd % get_name ()) case ( ENGINE_LAZY_DFA ) call print_help_find_match_lazy_dfa case ( ENGINE_DENSE_DFA ) call print_help_find_match_dense_dfa case ( ENGINE_FORGEX_API ) call print_help_find_match_forgex_api end select end if if ( cla % sub_sub_cmd % get_name () == ENGINE_LAZY_DFA & . or . cla % sub_sub_cmd % get_name () == ENGINE_DENSE_DFA & . or . cla % sub_sub_cmd % get_name () == ENGINE_FORGEX_API ) then if ( size ( cla % patterns ) /= 3 . and . size ( cla % patterns ) /= 2 ) then write ( stderr , \"(a, i0, a)\" ) \"Three arguments are expected, but \" , size ( cla % patterns ), \" were given.\" stop else if ( cla % patterns ( 2 )% p /= OP_MATCH . and . cla % patterns ( 2 )% p /= OP_IN ) then write ( stderr , \"(a)\" ) \"Operator \" // OP_MATCH // \" or \" // OP_IN // \" are expected, but \" // cla % patterns ( 2 )% p // \" was given.\" stop end if if ( cla % patterns ( 2 )% p == OP_MATCH ) then is_exactly = . true . else if ( cla % patterns ( 2 )% p == OP_IN ) then is_exactly = . false . else write ( stderr , '(a)' ) \"Unknown operator: \" // cla % patterns ( 2 )% p end if else call print_help_find_match end if if ( size ( cla % patterns ) == 2 ) then text = '' else text = cla % patterns ( 3 )% p end if select case ( cla % sub_sub_cmd % get_name ()) case ( ENGINE_LAZY_DFA ) call do_find_match_lazy_dfa ( cla % flags , cla % patterns ( 1 )% p , text , is_exactly ) case ( ENGINE_DENSE_DFA ) call do_find_match_dense_dfa ( cla % flags , cla % patterns ( 1 )% p , text , is_exactly ) case ( ENGINE_FORGEX_API ) call do_find_match_forgex ( cla % flags , cla % patterns ( 1 )% p , text , is_exactly ) case default call print_help_find_match end select end subroutine cla__do_find_subc !=====================================================================!s subroutine cla__get_patterns ( cla , offset ) implicit none class ( cla_t ), intent ( inout ) :: cla integer , intent ( in ) :: offset integer :: i , j , k integer , allocatable :: idx (:) j = 0 outer : do i = offset , cla % arg_info % argc ! if ( i <= maxval ( cla % flag_idx )) then do k = 1 , ubound ( cla % flags , dim = 1 ) if ( i == cla % flag_idx ( k )) cycle outer end do end if j = j + 1 if (. not . allocated ( idx )) then idx = [ i ] cycle end if idx = [ idx , i ] end do outer if ( j == 0 ) return allocate ( cla % patterns ( j )) do i = 1 , j cla % patterns ( i )% p = cla % arg_info % arg ( idx ( i ))% v end do end subroutine cla__get_patterns subroutine cla__collect_flags ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla type ( arg_element_t ), allocatable :: input_flags (:) integer :: n , i , j , k integer , allocatable :: indices (:) character ( * ), parameter :: pattern_long = \"(--)(\\w+-?)+\" character ( * ), parameter :: pattern_short = \"-\\w+\" n = cla % arg_info % argc allocate ( input_flags ( n )) allocate ( indices ( n )) indices (:) = 0 ! Scan all command line arguments j = 0 do i = 1 , n if (( pattern_long . match . cla % arg_info % arg ( i )% v ) & . or . ( pattern_short . match . cla % arg_info % arg ( i )% v )) then ! If the CLA in question is a flag, register the CLA to input_flags array ! and record the index in indices array. j = j + 1 ! increment input_flags ( j )% v = cla % arg_info % arg ( i )% v indices ( j ) = i end if end do ! If there are no flags, return immediately. if ( j == 0 ) return ! Register flags to cla object, ! stop the program if invalid flags are found. do k = 1 , j if ( input_flags ( k ) . in . all_flags ) then i = get_flag_index ( input_flags ( k ), all_flags ) cla % flags ( i ) = . true . cla % flag_idx ( i ) = indices ( k ) else write ( stderr , fmta ) \"invalid option \" // \"'\" // input_flags ( k )% v // \"'\" stop end if end do end subroutine subroutine cla__initialize ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla call get_arg_command_line ( cla % arg_info % argc , cla % arg_info % arg , cla % arg_info % entire ) cla % flags = . false . cla % flag_idx = - 1 call init_flags call init_commands end subroutine cla__initialize end module forgex_cli_cla_m","tags":"","loc":"sourcefile/cli_cla_m.f90.html"},{"title":"cli_memory_calculation_m.f90 – Forgex—Fortran Regular Expression","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_memory_calculation_m module is a part of Forgex. ! module forgex_cli_memory_calculation_m use :: forgex_parameters_m , only : NFA_STATE_BASE implicit none private public :: mem_tape public :: mem_tree public :: mem_nfa_graph public :: mem_dfa_graph contains function mem_tape ( tape ) result ( res ) use :: forgex_syntax_tree_node_m implicit none type ( tape_t ), intent ( in ) :: tape integer :: res res = len ( tape % str ) res = res + 12 end function mem_tape function mem_tree ( tree ) result ( res ) use :: forgex_syntax_tree_node_m implicit none type ( tree_node_t ), intent ( in ) :: tree (:) integer :: res , sum_c , i res = size ( tree , dim = 1 ) * 6 * 4 ! 5 int32, 1 logical sum_c = 0 do i = lbound ( tree , dim = 1 ), ubound ( tree , dim = 1 ) if ( allocated ( tree ( i )% c )) then sum_c = sum_c + size ( tree ( i )% c ) * 8 ! 8bytes per segment end if end do res = res + sum_c end function mem_tree function mem_nfa_graph ( graph ) result ( res ) use :: forgex_nfa_graph_m implicit none type ( nfa_graph_t ), intent ( in ) :: graph integer :: res , sum_node , sum_tra , i , j res = 12 ! 3 int32 sum_node = 0 do i = NFA_STATE_BASE , graph % nfa_top sum_node = sum_node + 5 * 4 ! 5 int32 sum_tra = 0 if (. not . allocated ( graph % nodes ( i )% forward )) cycle b : do j = lbound ( graph % nodes ( i )% forward , dim = 1 ), ubound ( graph % nodes ( i )% forward , dim = 1 ) if (. not . allocated ( graph % nodes ( i )% forward )) cycle b sum_tra = sum_tra + 4 * 4 ! 3 int32, 1 logical if ( allocated ( graph % nodes ( i )% forward ( j )% c )) then sum_tra = sum_tra + 8 * size ( graph % nodes ( i )% forward ( j )% c ) end if end do b sum_node = sum_node + sum_tra * 2 ! forward and backward end do res = res + sum_node res = res + ( ubound ( graph % nodes , dim = 1 ) - graph % nfa_top ) * 5 ! 5 int32 end function mem_nfa_graph function mem_dfa_graph ( graph ) result ( res ) use :: forgex_lazy_dfa_graph_m implicit none type ( dfa_graph_t ), intent ( in ) :: graph integer :: res , sum_node , sum_tra , i , j res = 16 ! 4 int32 sum_node = 0 do i = 1 , graph % dfa_top - 1 sum_node = sum_node + 6 * 4 ! 3 int32, 3 logical if ( allocated ( graph % nodes ( i )% nfa_set % vec )) then sum_node = sum_node + size ( graph % nodes ( i )% nfa_set % vec ) * 4 ! logical vector end if sum_tra = 0 inner : do j = 1 , graph % nodes ( i )% get_tra_top () sum_tra = sum_tra + 8 + 4 * 2 ! segment + 2 int32 if (. not . allocated ( graph % nodes ( i )% transition )) cycle inner if ( allocated ( graph % nodes ( i )% transition ( j )% nfa_set % vec )) then sum_tra = sum_tra + size ( graph % nodes ( i )% transition ( j )% nfa_set % vec ) * 4 end if end do inner sum_node = sum_node + sum_tra end do res = res + sum_node res = res + ( ubound ( graph % nodes , dim = 1 ) - graph % dfa_top ) * 6 * 4 ! 3 int32, 3 logical end function mem_dfa_graph end module forgex_cli_memory_calculation_m","tags":"","loc":"sourcefile/cli_memory_calculation_m.f90.html"},{"title":"cli_utils_m.f90 – Forgex—Fortran Regular Expression","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_utils_m module is a part of Forgex. ! module forgex_cli_utils_m use , intrinsic :: iso_fortran_env , only : int32 , real64 , stderr => error_unit use :: forgex_cli_parameters_m , only : LEN_ENV_VAR , NUM_FLAGS , INVALID_FLAG , LEN_CMD use forgex_cli_type_m , only : arg_element_t , flag_t , cmd_t implicit none private public :: right_justify public :: operator (. in .) interface operator (. in .) module procedure :: does_flag_exist module procedure :: does_command_exist module procedure :: does_command_exist_type_cmd module procedure :: is_arg_contained_in_flags end interface public :: get_arg_command_line public :: get_flag_index public :: register_flag public :: register_cmd public :: get_os_type public :: info public :: text_highlight_green contains function get_os_type () result ( res ) use :: forgex , only : operator (. in .) use :: forgex_enums_m implicit none integer :: res integer , save :: res_save logical , save :: is_first = . true . character ( LEN_ENV_VAR ) :: val1 , val2 integer :: len1 , len2 , stat1 , stat2 if (. not . is_first ) then res = res_save return end if res = OS_UNKNOWN call get_environment_variable ( name = 'OS' , value = val1 , length = len1 , status = stat1 ) if ( stat1 == 0 . and . len1 > 0 ) then if ( \"Windows_NT\" . in . val1 ) then res_save = OS_WINDOWS res = res_save is_first = . false . return end if end if call get_environment_variable ( name = 'OSTYPE' , value = val2 , length = len2 , status = stat2 ) if ( stat2 == 0 . and . len2 > 0 ) then !! @todo end if end function get_os_type function get_flag_index ( arg , flags ) result ( res ) implicit none type ( arg_element_t ), intent ( in ) :: arg type ( flag_t ), intent ( in ) :: flags (:) integer :: res integer :: i res = - 1 do i = 1 , NUM_FLAGS if ( arg % v == flags ( i )% long_f . or . arg % v == flags ( i )% short_f ) then res = i return end if end do end function get_flag_index function is_arg_contained_in_flags ( arg , flags ) result ( res ) implicit none type ( arg_element_t ), intent ( in ) :: arg type ( flag_t ), intent ( in ) :: flags (:) logical :: res integer :: i res = . false . do i = 1 , ubound ( flags , dim = 1 ) res = res & . or . flags ( i )% long_f == arg % v & . or . flags ( i )% short_f == arg % v if ( res ) return end do end function is_arg_contained_in_flags subroutine get_arg_command_line ( argc , arg , entire ) implicit none integer ( int32 ), intent ( inout ) :: argc ! argc type ( arg_element_t ), allocatable , intent ( inout ) :: arg (:) character (:), allocatable , intent ( inout ) :: entire integer :: i , len_ith , entire_len argc = command_argument_count () call get_command ( length = entire_len ) allocate ( character ( entire_len ) :: entire ) call get_command ( command = entire ) allocate ( arg ( 0 : argc )) do i = 0 , argc ! Get length of i-th command line argmuemnt. call get_command_argument ( number = i , length = len_ith ) ! Allocate str(i)%v of the same length as the i-th argument. allocate ( character ( len_ith ) :: arg ( i )% v ) ! Get the value of the i-th argument as a string. call get_command_argument ( number = i , value = arg ( i )% v ) end do end subroutine get_arg_command_line !=====================================================================! pure function does_command_exist ( arg , cmd_list ) result ( res ) implicit none character ( * ), intent ( in ) :: arg character ( LEN_CMD ), intent ( in ) :: cmd_list (:) logical :: res integer :: i res = . false . do i = lbound ( cmd_list , dim = 1 ), ubound ( cmd_list , dim = 1 ) res = res . or . trim ( arg ) == trim ( cmd_list ( i )) if ( res ) return end do end function does_command_exist pure function does_command_exist_type_cmd ( arg , cmd_list ) result ( res ) implicit none character ( * ), intent ( in ) :: arg type ( cmd_t ), intent ( in ) :: cmd_list (:) logical :: res integer :: i res = . false . do i = lbound ( cmd_list , dim = 1 ), ubound ( cmd_list , dim = 1 ) res = res . or . trim ( arg ) == trim ( cmd_list ( i )% get_name ()) if ( res ) return end do end function does_command_exist_type_cmd pure function does_flag_exist ( arg , flag_list ) result ( res ) implicit none character ( * ), intent ( in ) :: arg type ( flag_t ), intent ( in ) :: flag_list (:) logical :: res integer :: i res = . false . do i = lbound ( flag_list , dim = 1 ), ubound ( flag_list , dim = 1 ) res = res & . or . trim ( arg ) == trim ( flag_list ( i )% short_f ) & . or . trim ( arg ) == trim ( flag_list ( i )% long_f ) if ( res ) return end do end function does_flag_exist subroutine register_flag ( flag , name , long , short ) implicit none type ( flag_t ), intent ( inout ) :: flag character ( * ), intent ( in ) :: name character ( * ), intent ( in ) :: long character ( * ), intent ( in ), optional :: short flag % name = name flag % long_f = long if ( present ( short )) then flag % short_f = short else flag % short_f = INVALID_FLAG end if end subroutine subroutine register_cmd ( cmd , name ) implicit none type ( cmd_t ), intent ( inout ) :: cmd character ( * ), intent ( in ) :: name call cmd % set_name ( name ) end subroutine register_cmd subroutine right_justify ( array ) use :: forgex_cli_parameters_m , only : NUM_DIGIT_KEY implicit none character ( NUM_DIGIT_KEY ), intent ( inout ) :: array (:) character ( NUM_DIGIT_KEY ), allocatable :: buff (:) integer :: i , max_len allocate ( buff ( size ( array , dim = 1 ))) buff (:) = array (:) max_len = 0 do i = 1 , size ( buff ) max_len = max ( max_len , len_trim ( adjustl ( buff ( i )))) end do ! right justify do i = 1 , size ( buff ) buff ( i ) = adjustl ( array ( i )) buff ( i ) = repeat ( ' ' , max_len - len_trim ( buff ( i ))) // buff ( i ) end do array (:) = buff (:) end subroutine subroutine info ( str ) implicit none character ( * ), intent ( in ) :: str write ( stderr , '(a)' ) \"[info]: \" // str end subroutine info function text_highlight_green ( string , from , to ) result ( res ) implicit none character ( * ), intent ( in ) :: string integer ( int32 ), intent ( in ) :: from , to character (:), allocatable :: res character ( 5 ) :: green = char ( 27 ) // \"[32m\" character ( 5 ) :: hend = char ( 27 ) // \"[39m\" character ( 4 ) :: bold = char ( 27 ) // \"[1m\" character ( 4 ) :: bend = char ( 27 ) // \"[0m\" res = '' if ( from > 0 . and . to > 0 . and . from <= to . and . len ( string ) > 0 ) then res = string ( 1 : from - 1 ) // green // bold // string ( from : to ) // bend // hend // string ( to + 1 : len ( string )) else res = string end if end function text_highlight_green end module forgex_cli_utils_m","tags":"","loc":"sourcefile/cli_utils_m.f90.html"},{"title":"Documentation – Forgex—Fortran Regular Expression","text":"Documentation of Forgex These pages explain the usage and development of Forgex. This documentation is available in English and Japanese, but currently work in progress. Please select a topic from the content list on the left.","tags":"","loc":"page/index.html"},{"title":"English – Forgex—Fortran Regular Expression","text":"Readme Forgex—Fortran Regular Expression—is a regular expression engine written entirely in Fortran. This project is managed by Fortran Package Manager (FPM) , providing basic processing of regular expression, and as a freely available under the MIT license.\nThe engine's core algorithm uses a deterministic finite automaton (DFA) approach. This choice have been focused on runtime performance. Features Metacharacter | Vertical bar for alternation, * Asterisk, match zero or more, + Plus, match one or more, ? Question, match zero or one, \\ escape metacharacter, . match any character. Character class character class [a-z] inverted character class [&#94;a-z] character class on UTF-8 codeset [α-ωぁ-ん] Note that inverted class does not match the control characters. Range of repetition {num} , {,max} , {min,} , {min, max} ,\nwhere num and max must NOT be zero. Anchor &#94; , matches the beginning of a line $ , matches the end of a line Shorthand \\t , tab character \\n , new line character (LF or CRLF) \\r , return character (CR) \\s , blank character (white space, TAB, CR, LF, FF, \"Zenkaku\" space U+3000) \\S , non-blank character \\w , ( [a-zA-Z0-9_] ) \\W , ( [&#94;a-zA-Z0-9_] ) \\d , digit character ( [0-9] ) \\D , non-digit character ( [&#94;0-9] ) Documentation The documentation is available in English and Japanese at https://shinobuamasaki.github.io/forgex . Usage Build Operation has been confirmed with the following compilers: GNU Fortran ( gfortran ) v13.2.1 Intel Fortran Compiler ( ifx ) 2024.0.0 20231017 It is assumed that you will use the Fortran Package Manager( fpm ). First of all, add the following to your project's fpm.toml : [dependencies] forgex = { git = \"https://github.com/shinobuamasaki/forgex\" } APIs When you write use forgex at the header on your program, .in. and .match. operators, regex subroutine, and regex_f function are introduced. program main use :: forgex implicit none The .in. operator returns true if the pattern is contained in the string. block character (:), allocatable :: pattern , str pattern = 'foo(bar|baz)' str = \"foobarbaz\" print * , pattern . in . str ! T str = \"foofoo\" print * , pattern . in . str ! F end block The .match. operator returns true if the pattern exactly matches the string. block character (:), allocatable :: pattern , str pattern = '\\d{3}-\\d{4}' str = '100-0001' print * , pattern . match . str ! T str = '1234567' print * , pattern . match . str ! F end block The regex is a subroutine that returns the substring of a string that matches pattern as intent(out) argument. block character (:), allocatable :: pattern , str , res integer :: length pattern = 'foo(bar|baz)' str = 'foobarbaz' call regex ( pattern , str , res ) print * , res ! foobar ! call regex(pattern, str, res, length) ! the value 6 stored in optional `length` variable. end block By using the from / to arugments, you can extract substrings from the given string. block character (:), allocatable :: pattern , str , res integer :: from , to pattern = '[d-f]{3}' str = 'abcdefghi' call regex ( pattern , str , res , from = from , to = to ) print * , res ! def ! The `from` and `to` variables store the indices of the start and end points ! of the matched part of the string `str`, respectively. ! Cut out before the matched part. print * , str ( 1 : from - 1 ) ! abc ! Cut out the matched part that equivalent to the result argument of the `regex` subrouine. print * , str ( from : to ) ! def ! Cut out after the matched part. print * , str ( to + 1 : len ( str )) ! ghi end block The interface of regex subroutine is following: interface regex module procedure :: subroutine__regex end interface pure subroutine subroutine__regex ( pattern , text , res , length , from , to ) implicit none character ( * ), intent ( in ) :: pattern , text character (:), allocatable , intent ( inout ) :: res integer , optional , intent ( inout ) :: length , from , to If you want to the matched character string as the return value of the function,\nconsider using regex_f defined in the forgex module. interface regex_f module procedure :: function__regex end interface regex_f pure function function__regex ( pattern , text ) result ( res ) implicit none character ( * ), intent ( in ) :: pattern , text character (:), allocatable :: res UTF-8 String matching UTF-8 string can be matched using regular expression patterns just like ASCII strings.\nThe following example demonstrates matching Chinese characters.\nIn this example, the length variable stores the byte length, and in this case there 10 3-byte characters, so the length is 30. block character (:), allocatable :: pattern , str integer :: length pattern = \"夢.{1,7}胡蝶\" str = \"昔者莊周夢爲胡蝶　栩栩然胡蝶也\" print * , pattern . in . str ! T call regex ( pattern , str , res , length ) print * , res ! 夢爲胡蝶　栩栩然胡蝶 print * , length ! 30 (is 3-byte * 10 characters) end block Command Line Interface Tool Version 3.2 introduces a command line tool that is called forgex-cli and uses the Forgex engine for debugging, testing, and benchmarking regex matches. It performs matching with commands such as the one shown in below, and outputs the results directly to standard output. For detailed information, please refer to the documentation. Command: forgex-cli find match lazy-dfa '([a-z]*g+)n?' .match. 'assign' If you run it through fpm run : fpm run forgex-cli --profile release -- find match lazy-dfa '([a-z]*g+)n?' .match. 'assign' Output: pattern: ([ a - z ] * g + ) n ? text: ' assign ' parse time : 46.5 us compile nfa time : 74.9 us dfa initialize time : 78.4 us search time : 661.7 us matching result: T memory ( estimated ) : 10380 ========== Thompson NFA =========== state 1 : ( ? , 5 ) state 2 : < Accepted > state 3 : ( n , 2 )( ? , 2 ) state 4 : ( g , 7 ) state 5 : ([ \"a\" - \"f\" ], 6 )( g , 6 )([ \"h\" - \"m\" ], 6 )( n , 6 )([ \"o\" - \"z\" ], 6 )( ? , 4 ) state 6 : ( ? , 5 ) state 7 : ( ? , 8 ) state 8 : ( g , 9 )( ? , 3 ) state 9 : ( ? , 8 ) =============== DFA =============== 1 : [ \"a\" - \"f\" ] => 2 2 : [ \"o\" - \"z\" ] => 2 [ \"h\" - \"m\" ] => 2 g => 3 3 A: n => 4 4 A: state 1 = ( 1 4 5 ) state 2 = ( 4 5 6 ) state 3 A = ( 2 3 4 5 6 7 8 ) state 4 A = ( 2 4 5 6 ) =================================== Notes A program built by gfortran on Windows and macOC may crash if an allocatable character is used in an OpenMP parallel block. If you use the command line tool with PowerShell on Windows, use UTF-8 as your system locale to properly input and output Unicode characters. To do Add Unicode escape sequence \\p{...} Deal with invalid byte strings in UTF-8 ✅️ Optimize by literal searching method ✅️ Add a CLI tool for debugging and benchmarking ✅️ Make all operators pure elemental attribute ✅️ Publish the documentation ✅️ Support UTF-8 basic feature ✅️ Construct DFA on-the-fly ✅️ Support CMake building Parallelize on matching Code Convention All code contained herein shall be written with a three-space indentation. Acknowledgements For the algorithm of the power set construction method and syntax analysis, I referred to Russ Cox's article and Yoshiyuki Kondo's book.\nThe implementation of the priority queue was based on the code written by ue1221 .\nThe idea of applying the .in. operator to strings was inspired by kazulagi's one.\nThe command-line interface design of forgex-cli was inspired in part by the package regex-cli of Rust language. References Russ Cox \"Regular Expression Matching Can Be Simple And Fast\" , 2007 近藤嘉雪 (Yoshiyuki Kondo), \"定本 Cプログラマのためのアルゴリズムとデータ構造\", 1998, SB Creative. ue1221/fortran-utilities Haruka Tomobe (kazulagi), https://github.com/kazulagi , his article in Japanese rust-lang/regex/regex-cli License Forgex is as a freely available under the MIT license. See LICENSE .","tags":"","loc":"page/English/index.html"},{"title":"CLI Tool – Forgex—Fortran Regular Expression","text":"Forgex on Command Line Summary In this project, some test cases to check behavior of the regular expression engine are located in the test/ directory. We can  promptly run the tests with the command fpm test .  In addition, for testing and benchmarking regular expression matches, Forgex provides a command line tool forgex-cli , available from version 3.2. For instance, if you want to see whether the pattern ((a|b)*)* matches the text ababab , execute the following command: % forgex-cli find match lazy-dfa '((a|b)*)*' .match. 'ababab' and you will get the following output on your terminal: pattern: ((a|b)*)*\n               text: 'ababab'\n         parse time:        32.6μs\n   compile nfa time:        49.5μs\ndfa initialize time:        55.7μs\n        search time:       643.7μs\n    matching result:         T\n memory (estimated):      6781\n\n========== Thompson NFA ===========\nstate    1: (?, 3)\nstate    2: <Accepted>\nstate    3: (?, 5)(?, 2)\nstate    4: (?, 3)\nstate    5: ([\"a\"-\"b\"], 6)(?, 4)\nstate    6: (?, 5)\n=============== DFA ===============\n   1A: [\"a\"-\"b\"]=>2\n   2A: [\"a\"-\"b\"]=>2\nstate    1A = ( 1 2 3 4 5 )\nstate    2A = ( 2 3 4 5 6 )\n=================================== In this case, the output consists of a table showing the engine's performance, including execution time and memory usage, along with information about the automata (an NFA and a DFA compiled from it) that was built by Forgex. This command can also be run using fpm run as follows: % fpm run forgex-cli --proflie release -- find match lazy-dfa '((a|b)*)*' .match. 'ababab' You can use this tool to debug, test, and benchmark regular expression matching. The following sections provide detailed instructions on how to use this command and what its output is. Usage Currently, the commands debug and find are available. forgex-cli debug This command provides information on the process of parsing regular expressions into an abstract syntax tree (AST) and compiling the AST into an NFA. Below is the help message for the debug command. % forgex-cli debug --help Prints the debug representation provided by Forgex. USAGE : forgex - cli debug < command > ... COMMANDS : ast Print the debug representation of an AST . thompson Print the debug representation of a Thompson NFA . If you specify the ast subcommand with any regex pattern Forgex accepts, you can get a representation of a nested syntax tree using parentheses. % forgex-cli debug ast \"(a|b)+c?\" parse time : 38 . 0μ s memory ( estimated ): 860 ( concatenate ( concatenate ( or \"a\" \"b\" ) ( closure ( or \"a\" \"b\" ))) ( or \"c\" EMPTY )) Alternatively, if you use the thompson subcommand, the NFA compiled from the AST is displayed. % forgex-cli debug thompson \"([a-z]*d)+e?\" parse time : 36 . 0μ s compile nfa time : 29 . 0μ s memory ( estimated ): 12796 ========== Thompson NFA ========== = state 1: (?, 6) state 2: < Accepted > state 3: (e, 2)(?, 2) state 4: (?, 8) state 5: (d, 4) state 6: ([\"a\"-\"c\"], 7)(d, 7)(e, 7)([\"f\"-\"z\"], 7)(?, 5) state 7: (?, 6) state 8: (?, 11)(?, 3) state 9: (?, 8) state 10: (d, 9) state 11: ([\"a\"-\"c\"], 12)(d, 12)(e, 12)([\"f\"-\"z\"], 12)(?, 10) state 12: (?, 11) Note : all segments of NFA were disjoined with overlapping portions . ================================== = In the section labeled \"Thompson NFA\", the NFA is written with one state and its transitions, whether single or multiple, each on a single line. State 2, with <Accepted> marked on the right, is special and represents an accepted state of the NFA. Each transition is represented by a character and the destination state number in parentheses, such as (e, 2) on state 3. When multiple consecutive characters in the character code table have the same transition destination, they are aggregated and expressed in square brackets like [\"a\"-\"c\"] on states 6 and 11. This is called a segment in the Forgex internal implementation, and is mainly used to improve memory usage efficiency. A transition indicated by ? in the character part is a special transition called an ε-transition, which does not consume an input character. Note As mentioned in the penultimate line of the output, the character segments used for the transitions in the input pattern are split into overlapping parts, e.g. ([\"a\"-\"c\"], 7)(d, 7)(e, 7)([\"f\"-\"z\"], 7) in the state 6 . This is called \"disjoining\" in Forgex development, and is necessary for appropriately assigning transitions to states when constructing a DFA from an NFA using the power set construction method. forgex-cli find This command performs matching on the input pattern and string. Below is the help message for the find command and the match subcommand. % forgex-cli find --help Executes a search. USAGE : forgex - cli find < command > ... COMMANDS : match Search for full matches . % forgex-cli find match --help Executes a search for full matches. USAGE : forgex - cli find match < engine > ENGINES : dense Search with the fully - compiled DFA regex engine . lazy - dfa Search with the lazy DFA regex engine . forgex Search with the top - level API regex engine . Specify the match subcommand after the find command, followed by the regular expression engine to use for matching. Currently, the engine can be selected from dense , lazy-dfa , or forgex . The dense engine pre-builds and uses a fully compiled DFA from the NFA for matching. The lazy-dfa engine builds a DFA on-the-fly from the NFA for matching. If you specify forgex , matching will be performed using the Forgex API module. The internal implementation is lazy DFA, but only the overall time spent using the API is measured. Once you have selected one of the three engines, you can execute the command by specifying a pattern and string using the .in. or .match. operator, just like you would write normal Fortran code using the Forgex API. If you omit the right operand, it will output the result of matching against an empty string. % forgex-cli find match dense '(a|b)*c?' .match. 'ababac' pattern : ( a | b ) * c ? text : 'ababac' parse time : 24 . 0μ s compile nfa time : 19 . 0μ s dfa initialize time: 9.0μs compile dfa time : 37 . 0μ s search time : 56 . 0μ s matching result : T memory ( estimated ): 5812 ========== Thompson NFA ========== = state 1: (?, 4) state 2: < Accepted > state 3: (c, 2)(?, 2) state 4: ([\"a\"-\"b\"], 5)(?, 3) state 5: (?, 4) ============== = DFA ============== = 1 A : c = > 2 [ \"a\" - \"b\" ]= > 2 2 A : c = > 2 [ \"a\" - \"b\" ]= > 2 state 1A = ( 1 2 3 4 ) state 2A = ( 2 3 4 5 ) ================================== = The NFA display is the same as that of the forgex-cli debug command. The output of the DFA is divided into upper and lower parts. The upper part lists the DFA state numbers and DFA transitions. The lower part shows a set of NFA states constructed for each DFA state using the power set construction method. Here if A is written after the DFA state number, it means that the DFA state is an accepting state. Performance Information Table Forgex performance table, including execution time, memory usage, and results, is shown with every forgex-cli command example in the previous section. In this section, we'll explain what each table entry means, but first a quick rundown of the option flags available with forgex-cli. When you run the forgex-cli command, you can specify several option flags. For example, running find match lazy-dfa --help will display the following help message: % forgex-cli find match lazy-dfa --help Executes a search for matches using a lazy DFA regex engine. USAGE : forgex - cli find match lazy - dfa < pattern > . match . < text > forgex - cli find match lazy - dfa < pattern > . in . < text > OPTIONS : -- verbose Print more information . -- no - table Suppresses the output of the property information table . -- table - only Print the property information table only . Each item listed in the OPTIONS section mean: --verbose : This option provides more detailed information in the properties table, offering deeper insights into matching process. --no-table : This option suppresses the properties table, allowing the output to focus exclusively on the structure of the NFA and DFA automata generated during the matching process. --table-only : This option limits the output to just properties table, omitting details about the NFA nad DFA, which may be useful when you need a quick overview of performance metrics. Here we will look at an example using the --table-only option flag to output only property information. First, below is a example of the command forgex-cli find match lazy-dfa : % forgex-cli find match lazy-dfa \"([a-z]*g)+n?\" .match. \"assign\" pattern : ([ a - z ] * g ) + n ? text : 'assign' parse time : 29 . 0μ s compile nfa time : 28 . 0μ s dfa initialize time: 3.0μs search time : 144 . 0μ s matching result : T memory ( estimated ): 13736 pattern and text show the pattern and string that were specified when the command was executed. Below that, the measured times are shown: parse time shows the time to build an AST from the specified regular expression, compile nfa time shows the time to compile an NFA from it, dfa initialize time shows the time to initialize the DFA to prepare before characters are entered, and search time is the time it takes for the DFA engine to execute after receiving an input character, i.e., the time it takes to make a match. The lazy-dfa engine waits for character input and builds the DFA, so initialize time and search time are measured. matching result is a logical value indicating the result of the actual matching. memory (estimated) shows the static size of memory in bytes calculated from memory allocation information of AST, NFA, and DFA objects at the end of matching execution. On the other hand, dense engine outputs a table which is different to above. For example: % forgex-cli find match dense \"([a-z]*g)+n?\" .match. \"assign\" --table-only Project is up to date pattern : ([ a - z ] * g ) + n ? text : 'assign' parse time : 16 . 0μ s compile nfa time : 29 . 0μ s dfa initialize time: 4.0μs compile dfa time : 35 . 0μ s search time : 47 . 0μ s matching result : T memory ( estimated ): 15480 compile dfa time is measured on the dense engine. Note that the memory usage of the dense engine is equal to or more than that of the lazy-dfa engine. What will be displayed if you specify forgex as the engine of the command? % forgex-cli find match forgex \"([a-z]*g)+n?\" .match. \"assign\" pattern : ([ a - z ] * g ) + n ? text : \"assign\" time : 229 . 0μ s result : T In this case, the only performance information provided is the time measured before and after the API call. This is because in Forgex version 3 and later, all procedures that compose the API ( .in. and .match. operators) have the pure attribute, which means that operations with side effects, such as internal time measurement, cannot be performed. If you use the --verbose flag with any engine other than forgex , you can get detailed information about how many AST, NFA and DFA objects were used. % forgex-cli find match lazy-dfa \"([a-z]*g)+n?\" .match. \"assign\" --verbose --table-only pattern : ([ a - z ] * g ) + n ? text : \"assign\" parse time : 21 . 0μ s compile nfa time : 32 . 0μ s dfa initialize time: 3.0μs dfa matching time : 149 . 0μ s matching result : T memory ( estimated ): 13736 tree node count : 10 / 32 nfa states : 12 / 16 dfa states : 5 / 16 For each of tree node count , nfa states , and dfa states , the denominator represents the allocated memory, while the numerator shows the amount actually used. Note The counts of tree node count and nfa states are the same for the dense engine and the lazy-dfa engine, but the count of dfa states may be larger for lazy-dfa than for dense . Conclusion The forgec-cli tool provides a command line interface for testing, debugging, and benchmarking regular expression engines. With features that support engines like dense , lazy-dfa , and forgex , users can analyze regex matching in different contexts and performance scenarios. Key Points: 1. Engine Options and Performance Insights: The dense engine utilizes a fully compiled DFA for fast matching, but it may cosume more memory. Additionally, for certain complex regular expressions, the DFA construction can be quite time-comsuming, which might affect overall performance. The lazy-dfa engine constructs the DFA on-the-fly, offering a more memory-efficient approach at the cost of potentially longer search times. The forgex engine provides a top-level API for regex operations, but its performance metrics are limited to overall execution time due to its pure attribute. 2. Command Usage: forgex-cli debug helps visualize the parsing and compilation process with ast and thompson subcommands. forgex-cli find performs regex matching and provides detailed performance and memory usage statistics. The --verbose flag offers additional information about the matching process, while the --table-only flag allows you to focus specifically on performance metrics by filtering out other details. 3. Performance Metrics: Users can access detailed breakdonws of execution times, memory usage, and internal state counts for different engines. For the lazy-dfa engine, additional into NFA nad DFA objects' memory usage can be obtained, highlighting the efficency and trade-offs of the engine's on-the-fly DFA construction. Overall, forgex-cli aims to be a versatile tool for evaluating regular expression performance, providing engine choices and detailed diagnostics that help understand the regular expression matching process. However, it is important to note that for certain types of regular expressions, especially complex ones, building a DFA in a dense engine can be very time and memory consuming. This is why the internal implementation of the Forgex API uses Lazy DFA. Acknowledgements The command line interface design for this application was inspired by the Rust language's regex-cli .","tags":"","loc":"page/English/forgex_on_command_line_en.html"},{"title":"Terms related to Forgex – Forgex—Fortran Regular Expression","text":"Terms related to Forgex This page provides details of terms used in the development of Forgex. Contents ASCII Code Point DFA Disjoin Lazy DFA NFA Powerset Construction Segment Segment Sorting Subset Construction Tape Unicode UCS-4 UTF-8 Details ASCII ASCII is an acronym for \"American Standard Code for Information Interchange\", a set of rules\nestablished in 1963 that defines the relationship between the numbers 0 to 127 and which\nletters and symbols correspond to them.\nThe first 32 characters (0-31 in decimal, and so on) are reserved as control characters,\nand the last 96 characters (32-127) are printable characters.\nThe printable characters contain the Latin alphabet used in the United States, with numbers 65-90\ncorresponding to uppercase letters A-Z, and numbers 97-122 corresponding to lowercase letter a-z.\nThe others are symbols such as \"$\", \"#\", and \"|\". In Fortran, you can obtain this correspondence using the intrinsic procedures char() and ichar() .\nFor example, if you give the char argument the number 70, it will return the letter 'F',\nand conversely, if you give the ichar argument the letter 'o', it will return the integer 111. In the development of Forgex, we use the UTF-8 codeset, which includes ASCII as a subset, to process\nregular expression patterns that span the entire character set, where a contiguous subset of UTF-8\nis called a Segment. See also, Segment , Unicode , UTF-8 . Code Point A code point (also known as code position ) is a paricular position in table that has a scripts,\nsymbols, emojis and control character assigned to it. In Unicode, code points are expressed as a hexadecimal number following the U+ prefix,\nand range from U+0000 to U+10FFFF.\nFor example, the code point of the Latin letter 'A' is U+0041.\nSimilarly, the kanji character '雨' corresponds to U+96E8, and the emoji '👍' corresponds to U+1FF4D. Forgex represents Unicode code points as integer and defines the char_utf8 and ichar_utf8 procedures\nin the forgex_utf8_m module to convert to and from the corresponding UTF-8 encoding characters. See also, Unicode , UTF-8 . DFA The DFA (deterministic finite automaton) is a theoretical model of computation\nin computer science used to represent and manipulate a finite set of states with\ndeterministic transitions, where a deterministic transition is one in which the transition\nfrom state to state is uniquely determined by the input. An important aspect of to develop a regular expression processor is that the set of\nstrings that match a regular expression can be computed using a DFA (or an NFA, described below). The Forgex engine first parses a regular expression into a syntax tree, then constructs an\nNFA, which is then converted into an equivalent DFA to perform matching calculations.\nThe engine uses the powerset construction method to construct a DFA.\nHere, the NFA is dynamically converted to a DFA on-the-fly for input character.\nThis technique is called Lazy DFA construction.\nIn its implementation for executing this computation, Forgex defines the dfa_t derived-type\nusing pointers and arrays to represent the directed graph that simulates a DFA. See also, NFA , Powerset Construction , Lazy DFA . Disjoin In the development of Forgex, disjoin refers to a a set of operations that are performed on\na set of segments to eliminate crossing segments between multiple segments. As a premise, Forgex represents a set of inputs that share a common transition as a segment.\nIn this case, if crossing segments are contained in the set, the Forgex implementation of\npowerset construction cannot construct a DFA equivalent to the original NFA.\nTherefore, we need to perform a disjoin operation to convert the set of crossing segments\ninto a set of non-crossing segments by spliting them at their crossing point. The disjoin operation is defined as public procedures in the forgex_segment_disjoin_m module,\nand in particular the disjoin_kernel procedure within it plays an important role. See also, Segment , `forgex_segment_disjoin_m ,  ref. (1) . Lazy DFA Unlike traditional DFA construction methods, Lazy DFA is a technique that generates\ntransition as needed by lazy evaluation.\nThis technique is used to efficiently handle large automaton by computing and storing\nthe transitions from the NFA each time an input is given, reducing memory usage.\nCompared to traditional DFA that are pre-calculates everything, for pattens that require\na large DFA, such as a{1,100}*b , it is possible to avoid pre-calculating the entire DFA,\nthereby saving memory space. See also, DFA , Powerset Construction . NFA The NFA (Non-deterministic finite automaton) is a theoretical model of computation in\ncomputer science used to represent and manipulate a finite set of states with non-deterministic\ntransition. A non-deterministic transition is one in where the transition from state to state\nis not uniquely determined for each input. This includes a transition that do not consume\nany input string (called ε-transition). Like the DFA, the NFA can process regular expressions, but due to its non-determinism, \nthere is not a single transition from state to state, so a technique called backtracking must be used to effectively simulate it. Although we will not go into details here, engines\nthat use backtracking in NFA can have a wide range of functionalities, but it is difficult to\nachieve high-speed processing for all patterns. In other words, an NFA engine has weaknesses\nin some kind of patterns. Forgex focuses on high runtime performance, which is the main requirement of Fortran users.\nTherefore, instead of using NFAs directly for matching, it converts them into eqivalent\nDFAs for matching.\nThe NFA before conversion is represented by the nfa_t derived-type.\nFor the details of that conversion, you can see the Powerset Construction section. See also, DFA , Powerset Construction . Powerset Construction The powerset construction method, also known as the subset construction method, is a process\nto convert an NFA into a DFA.\nThis method allows us to convert automata with non-deterministic properties into equivalent DFAs,\ni.e. it accepts the same input strings. This approach is powerful in that it gives us a deterministic state machine.\nIt has drawbacks, however, as the potentially exponential growth in the number of DFA states\nconstructed by the transformation.\nThis problem is a kind of problem called combinatiorial explosion.\nFortunately, Forgex version 2.0 and later introduces a lazy DFA construction method that can dynamically\ngenerate a DFA state for the input characters, so we don't need to worry about this problem here. cf. Powerset construction - Wikipedia cf. Combinatorial explosion - Wikipedia See also, Lazy DFA . Segment A segment is a contiguous interval, the subset of an entire character encoding set,\ndefined by two numbers: a start and an end.\nAssigning each input single character to a transition in the simulation of a state machine would consume\na lot of memory, especially when processing character classes, so Forgex uses a method of associating\nsuch intervals with a transition.\nThis approach also introduces new problems; see the Disjoin explanation for more details. In Forgex's segment implementation, the segment_t derived-type is defined as follows: type , public :: segment_t integer ( int32 ) :: min = UTF8_CODE_EMPTY ! = 0 integer ( int32 ) :: max = UTF8_CODE_EMPTY ! = 0 contains procedure :: validate => segment_is_valid end type The segment_t type has two component of min and max , and a type-bound procedures, validate .\nThe min is the smallest number of characters in the interval, and max is the largest number.\nThe validate procedure checks whether the min component is smaller than or equal to max .\nIf min and max are equal, the segment refers to exactly one character. See also, Disjoin , Seguent Sorting . Segment Sorting Sorting segments is a process required by disjoining of a set of segments, and the sorting\nprocedure defined in forgex_sort_m is called by the disjoin_kernel in forgex_segment_disjoin_m .\nThe currently implemented algorithm is bubble sort. This algorithm is used because the\nnumber of elements to be sorted is small, and its contribution to the overall performance is\nrelatively minor.\nHowever, we plan to change it to insertion sort in the near future. See also, Disjoin , Segment , forgex_sort_m , forgex_segment_disjoin_m . Subset Construction See Powerset Construction . Tape In the Forgex context, a Tape mimics a storage medium (such as a magnetic tape) with sequential data access\nand a read header.\nIt is defined in the syntax analysis module ( forgex_syntax_tree_m ) as the tape_t derived type. \nThis type contains information about the entire input pattern string (like a rolled magnetic tape) and\nthe index number (read header).\nThe developers of Forgex can use the currently read character and tokens through the type-bound procedure. See also, ( forgex_syntax_tree_m ), tape_t Unicode Unicode is one of the character encoding standards, which enables consistent representation and handling of text\nacross different languages and platforms.\nIt assigns a unique number (code point) to every character and symbol, covering a wide range of\nscripts, symbols, and even emojis.\nUnicode characters are encoded using common encoding schemes like UTF-8, UTF-16, and UTF-32 into byte strings,\nensuring compatibility across different platforms. Even in Fortran programming, many compilers allow us to handle Unicode characters by setting the terminal and\nsource file encoding to UTF-8. Note In the case of Microsoft's Windows operating system, the system's standard character encoding\nmay not be UTF-8, so users may need to change the settings appropriately. See also, Code Point , UTF-8 UCS-4 UCS-4 (Universal Coded Character Set 4), or the nearly equivalent UTF-32 (defined in ISO/IEC 10646),\nis a fixed-length encoding scheme that assigns a 32-bit (4 bytes) binary string to each Unicode code point.\nIn some Fortran 2003 conforming compilers, we can use these fixed-length 4-byte characters by specifying the kind type parameter in a character type declaration as the return value of selected_char_kind('ISO_10646') .\nFor example, GNU Fortran Compiler supports this.\nForgex currently does not provide support for UCS-4 string processing. cf. UTF-32 - Wikipedia See also, Unicode , UTF-8 UTF-8 UTF-8 (UCS Transformation Format 8, or Unicode Transformation Format-8) is a character encoding\nscheme that maps Unicode characters to binary strings of variable length, from 1 to 4 bytes.\nTo maintain compatibility with ASCII characters, the ASCII characters part is represented in 1 byte, and other\ncharacters are represented in 2-4 bytes.\nForgex processes UTF-8 encoded character strings using the procedures defined in the forgex_utf8_m module. See also, forgex_utf8_m . Refereces How to implement regular expression NFA with character ranges? - Stack Overflow , 2013 Using Unicode Characters in Fortran - Fortran-lang Discourse","tags":"","loc":"page/English/terms_related_to_forgex_en.html"},{"title":"Japanese/日本語 – Forgex—Fortran Regular Expression","text":"Readme Forgexは、すべてFortranで書かれた正規表現エンジンです。 このプロジェクトは Fortranパッケージマネージャー で管理され、\n正規表現の基本的な処理を提供し、 MITライセンス のもとで利用可能なフリーソフトウェアです。\nエンジンの核となるアルゴリズムには決定性有限オートマトン（Deterministic Finite Automaton, DFA）を使用しています。\nこの選択は実行時パフォーマンスを重視したものです。 機能 Forgexが処理を受け付ける正規表現の記法は以下の通りです。 メタキャラクター | 選言（alternation）のバーティカルバー * ゼロ回以上にマッチするアスタリスク + 一回以上にマッチするプラス記号 ? ゼロ回または一回にマッチするクエスチョンマーク \\ メタキャラクターのエスケープ . 任意の一文字にマッチするピリオド 文字クラス 文字クラス（例： [a-z] ） 否定クラス（例: [&#94;a-z] ） Unicode文字クラス（例: [α-ωぁ-ん] ） 否定クラスは制御文字にはマッチしないことに注意してください。 繰り返し回数の指定 {num} , {,max} , {min,} , {min, max} ,\nここで num と max は0（ゼロ）以外の自然数を指定します。 アンカー &#94; , 行頭にマッチ $ , 行末にマッチ 略記法 \\t , タブ文字 \\n , 改行文字 (LFまたはCRLF) \\r , 復帰文字 (CR) \\s , 空白文字 (半角スペース, タブ文字, CR, LF, FF, 全角スペース U+3000) \\S , 非空白文字 \\w , ラテン文字アルファベット、半角数字及びアンダースコア( [a-zA-Z0-9_] ) \\W , \\w の否定クラス( [&#94;a-zA-Z0-9_] ) \\d , 半角数字 ( [0-9] ) \\D , 非半角数字 ( [&#94;0-9] ) ドキュメント ドキュメントは英語と日本語で次のリンクから利用可能です。 https://shinobuamasaki.github.io/forgex . 使用方法 動作確認は以下のコンパイラーで行っています。 GNU Fortran ( gfortran ) v13.2.1 Intel Fortran Compiler ( ifx ) 2024.0.0 20231017 以下では、ビルドとAPIの使い方について解説しますが、Fortranパッケージマネージャー（ fpm ）を利用することを前提とします。 ビルド まず初めに、あなたのプロジェクトの fpm.toml に以下の記述を追加します。 [dependencies] forgex = { git = \"https://github.com/shinobuamasaki/forgex\" , tag = \"v2.0\" } APIの使い方 そのプロジェクトのプログラムのヘッダーに use forgex と記述すると、 .in. と .match. の演算子、 regex サブルーチンと regex_f 関数が導入され、 use 文の有効なスコープでこれらの4つを使用することができます。 program main use :: forgex implicit none .in. 演算子は、文字列型を引数にとり、第一引数のパターンが、第二引数の文字列に含まれる場合に真を返します。 block character (:), allocatable :: pattern , str pattern = 'foo(bar|baz)' str = \"foobarbaz\" print * , pattern . in . str ! T str = \"foofoo\" print * , pattern . in . str ! F end block .match. 演算子は、同様に指定されたパターンが、厳密に文字列と一致する場合に真を返します。 block character (:), allocatable :: pattern , str pattern = '\\d{3}-\\d{4}' str = '100-0001' print * , pattern . match . str ! T str = '1234567' print * , pattern . match . str ! F end block regex 関数は、入力文字列の中でパターンに一致した部分文字列を返します。 block character ( : ), allocatable :: pattern , str , res integer :: length pattern = 'foo(bar|baz)' str = 'foobarbaz' call regex ( pattern , str , res ) print * , res ! foobar ! call regex ( pattern , str , res , length ) ! the value 6 stored in optional `length` variable . end block オプショナル引数の from / to を使用すると、与えた文字列から添字を指定して部分文字列を切り出すことができます。 block character (:), allocatable :: pattern , str , res integer :: from , to pattern = '[d-f]{3}' str = 'abcdefghi' call regex ( pattern , str , res , from = from , to = to ) print * , res ! def ! The `from` and `to` variables store the indices of the start and end points ! of the matched part of the string `str`, respectively. ! Cut out before the matched part. print * , str ( 1 : from - 1 ) ! abc ! Cut out the matched part that equivalent to the result of the `regex` function. print * , str ( from : to ) ! def ! Cut out after the matched part. print * , str ( to + 1 : len ( str )) ! ghi end block regex 関数の宣言部（インタフェース）は次の通りです。 interface regex module procedure :: subroutine__regex end interface pure subroutine subroutine__regex ( pattern , text , res , length , from , to ) implicit none character ( * ), intent ( in ) :: pattern , text character (:), allocatable , intent ( inout ) :: res integer , optional , intent ( inout ) :: length , from , to マッチした文字列を関数の戻り値として得たい場合には、 regex_f 関数を使用してください。 interface regex_f module procedure :: function__regex end interface regex_f pure function function__regex ( pattern , text ) result ( res ) implicit none character ( * ), intent ( in ) :: pattern , text character (:), allocatable :: res UTF-8文字列のマッチング UTF-8の文字列についても、ASCII文字と同様に正規表現のパターンで一致させることができます。\n以下の例は、漢文の一節に対してマッチングを試みています。 block character (:), allocatable :: pattern , str integer :: length pattern = \"夢.{1,7}胡蝶\" str = \"昔者莊周夢爲胡蝶　栩栩然胡蝶也\" print * , pattern . in . str ! T call regex ( pattern , str , res , length ) print * , res ! 夢爲胡蝶　栩栩然胡蝶 print * , length ! 30 (is 3-byte * 10 characters) end block この例では length 変数にバイト長が格納され、この場合は10個の3バイト文字に一致したので、その長さは30となります。 CLIツール バージョン3.2以降では、Forgexエンジンを使用したコマンドラインツール forgex-cli が提供されてり、Forgexエンジン自体のデバッグ、正規表現マッチングのテストやベンチマークのために使用することができます。\n以下のようにコマンドを実行することで、標準出力に結果を得ることができます。 使い方の詳細についてはドキュメンテーションを参照してください。 コマンド: forgex-cli find match lazy-dfa '([a-z]*g+)n?' .match. 'assign' fpm run 経由で実行する場合: fpm run forgex-cli --profile release -- find match lazy-dfa '([a-z]*g+)n?' .match. 'assign' 出力: pattern: ([ a - z ] * g + ) n ? text: ' assign ' parse time : 46.5 us compile nfa time : 74.9 us dfa initialize time : 78.4 us search time : 661.7 us matching result: T memory ( estimated ) : 10380 ========== Thompson NFA =========== state 1 : ( ? , 5 ) state 2 : < Accepted > state 3 : ( n , 2 )( ? , 2 ) state 4 : ( g , 7 ) state 5 : ([ \"a\" - \"f\" ], 6 )( g , 6 )([ \"h\" - \"m\" ], 6 )( n , 6 )([ \"o\" - \"z\" ], 6 )( ? , 4 ) state 6 : ( ? , 5 ) state 7 : ( ? , 8 ) state 8 : ( g , 9 )( ? , 3 ) state 9 : ( ? , 8 ) =============== DFA =============== 1 : [ \"a\" - \"f\" ] => 2 2 : [ \"o\" - \"z\" ] => 2 [ \"h\" - \"m\" ] => 2 g => 3 3 A: n => 4 4 A: state 1 = ( 1 4 5 ) state 2 = ( 4 5 6 ) state 3 A = ( 2 3 4 5 6 7 8 ) state 4 A = ( 2 4 5 6 ) =================================== 注意 WindowおよびmacOS環境の gfortran でコンパイルされたプログラムでは、OpenMPの並列ブロックの中で割り付け可能文字列型変数を使用すると、セグメンテーション違反などでプログラムが停止する可能性があります。 コマンドラインツール forgex-cli をWindows上のPowerShellで利用する場合、Unicode文字を正しく入出力するには、システムのロケールをUTF-8に変更する必要があります。 To Do Unicodeエスケープシーケンス \\p{...} の追加 UTF-8において無効なバイトストリームへの対処 ✅️ リテラル検索によるマッチングの最適化 ✅️ デバッグおよびベンチマーク用のCLIツールを追加 ✅️ すべてのAPI演算子に pure elemental 属性を追加 ✅️ ドキュメントの公開 ✅️ UTF-8文字の基本的なサポート ✅️ On-the-FlyのDFA構築 ✅️ CMakeによるビルドのサポート ✅️ 簡単な時間計測ツールの追加 マッチングの並列化 コーディング規約 本プロジェクトに含まれるすべてのコードは、3スペースのインデントで記述されます。 謝辞 冪集合構成法のアルゴリズムと構文解析については、Russ Cox氏の論文と近藤嘉雪氏の本を参考にしました。\n優先度付きキューの実装は、 ue1221さんのコード に基づいています。\n文字列に対して .in. 演算子を適用するというアイデアは、soybeanさんのものにインスパイアされました。 forgex-cli のコマンドラインインターフェイスの設計については、Rust言語の regex-cli を参考にしました。 参考文献 Russ Cox \"Regular Expression Matching Can Be Simple And Fast\" , 2007年 近藤嘉雪, \"定本 Cプログラマのためのアルゴリズムとデータ構造\", 1998年, SB Creative. ue1221/fortran-utilities kazulagi, @soybean , Fortranでユーザー定義演算子.in.を作る - Qiita.com , 2022年 rust-lang/regex/regex-cli ライセンス このプロジェクトはMITライセンスで提供されるフリーソフトウェアです\n（cf. LICENSE ）。","tags":"","loc":"page/Japanese/index.html"},{"title":"CLIツール – Forgex—Fortran Regular Expression","text":"コマンドラインインターフェース 概要 正規表現のテストケースのいくつかの例は test/ ディレクトリに配置されており、 fpm test コマンドで簡単に実行することができます。 これらに含まれるものの他に、正規表現のマッチングを確認したい場合には、バージョン3.2から導入されたコマンドライン・インターフェースのツール forgex-cli が利用可能です。\n例えば、 ((a|b)*)* と ababab のマッチングをテストしたい場合には、次のコマンドを実行すると以下のような出力が得られます。 % forgex-cli find match lazy-dfa '((a|b)*)*' .match. 'ababab' pattern : (( a | b ) * ) * text : ababab parse time : 32 . 6μ s compile nfa time : 49 . 5μ s dfa initialize time: 55.7μs dfa matching time : 643 . 7μ s matching result : T memory ( estimated ): 6781 ========== Thompson NFA ========== = state 1: (?, 3) state 2: < Accepted > state 3: (?, 5)(?, 2) state 4: (?, 3) state 5: ([\"a\"-\"b\"], 6)(?, 4) state 6: (?, 5) ============== = DFA ============== = 1 A : [ \"a\" - \"b\" ]= > 2 2 A : [ \"a\" - \"b\" ]= > 2 state 1A = ( 1 2 3 4 5 ) state 2A = ( 2 3 4 5 6 ) ================================== = コマンドラインの出力は、上部の実行時間などを示す表と、下部のオートマトンの状態と遷移を表す行から構成されます。\nこのツールを使用して、正規表現マッチングのベンチマークや、デバッグおよびテストを行うことができます。 現在のところ、 find と debug のコマンドが利用可能です。また、 forgex-cil のコマンドは fpm run から実行することも可能です。 % fpm run forgex-cli --profile release -- find match forgex '((a|b)*)*' .match. 'ababab' ... libforgex . a done . forgex - cli . f90 done . forgex - cli done . [ 100 %] Project compiled successfully. pattern : (( a | b ) * ) * text : ababab time : 487 . 1 us result : T forgex-cli debug コマンド 以下に、 forgex-cli debug コマンドのヘルプメッセージを示します。 % forgex-cli debug --help Prints the debug representation provided by Forgex. USAGE : forgex - cli debug < command > ... COMMANDS : ast Print the debug representation of an AST . thompson Print the debug representation of a Thompson NFA . debug コマンドでは、与えられたパターンについて、抽象構文木（AST）または非決定性有限オートマトン （NFA）を出力します。 以下は ast サブコマンドを使用して正規表現パターンから構築されたASTを出力する例です。 % forgex-cli debug ast \"((a|b)*)*\" Project is up to date parse time : 29 . 5 us memory ( estimated ): 829 ( closure ( closure ( or \"a\" \"b\" ))) 一方、ASTから変換されたNFAの構造を知りたい場合には、次のように thompson サブコマンドを実行します。 % forgex-cli debug thompson \"((a|b)*)*\" Project is up to date parse time : 26 . 5 us compile nfa time : 42 . 4 us memory ( estimated ): 6271 ========== Thompson NFA ========== = state 1: (?, 3) state 2: < Accepted > state 3: (?, 5)(?, 2) state 4: (?, 3) state 5: ([\"a\"-\"b\"], 6)(?, 4) state 6: (?, 5) Note : all segments of NFA were disjoined with overlapping portions . ================================== = このコマンドラインの出力では、それぞれのNFA状態について、左辺に状態番号と右辺にNFA遷移がセットで記述されています。 ([\"a\"-\"b\"], 6)`という遷移は「文字コード表でaからbの範囲の文字が入力された場合に第6状態へ遷移する」という意味になります。 (?, 3) のような、入力文字が ? となっているものは、ε（イプシロン）遷移と呼ばれるもので、入力文字列を消費せずに遷移可能であることを示しています。この例では受理状態を除いてε遷移が各NFA状態に含まれています。 forgex-cli find コマンド 以下に find コマンドと match サブコマンドのヘルプメッセージの出力を示します。 % forgex-cli find --help Executes a search. USAGE : forgex - cli find < command > ... COMMANDS : match Search for full matches . % forgex-cli find match --help Executes a search for full matches. USAGE : forgex - cli find match < engine > ENGINES : dense Search with the fully - compiled DFA regex engine . lazy - dfa Search with the lazy DFA regex engine . forgex Search with the top - level API regex engine . find コマンドでは match サブコマンドを指定し、その後ろにマッチングに使用する正規表現エンジンを指定します。\nエンジンは現在のところ、 lazy-dfa , dense , forgex を選択することができます。 dense エンジンは、完全にコンパイルされたDFAを使用してマッチングを行います。 lazy-dfa エンジンは、DFAをon-the-flyで構築してマッチングを行います。 forgex を指定すると、Forgexの上位APIを使用してマッチングを行います。これの内部実装は lazy-dfa ですが、APIを使用した時間のみが計測されます。 dense 、 lazy-dfa 、 forgex の3個いずれかからエンジンを決めたら、通常のFortranコードでForgexのAPIを使って書くのと同様に、 .in. 演算子または .match. 演算子を使用してパターンと文字列を指定してマッチングを行います。\nなお、演算子の右引数を省略した場合には、空文字とのマッチングを試みて結果を表示します。 % forgex-cli find match lazy-dfa \"a*b\" .match. \"ab\" pattern : a * b text : ab parse time : 24 . 6 us compile nfa time : 39 . 5 us dfa initialize time: 47.2us dfa matching time : 170 . 5 us matching result : T memory ( estimated ): 5707 ========== Thompson NFA ========== = state 1: (?, 4) state 2: < Accepted > state 3: (b, 2) state 4: (a, 5)(?, 3) state 5: (?, 4) ============== = DFA ============== = 1 : a = > 2 2 : b = > 3 3 A : state 1 = ( 1 3 4 ) state 2 = ( 3 4 5 ) state 3A = ( 2 ) ================================== = DFAの出力には、上部と下部に分けられます。\n上部では、DFA状態番号と、遅延評価により入力文字列から構成されたDFA遷移を記述しています。\n下部では、各DFA状態を冪集合構成法で構成されたNFA状態番号のセットを示しています。\nここで、DFA状態番号の後ろに A と書かれている場合、そのDFA状態が受理状態であることを意味しています。 なお、このコマンドを実行する際には、いくつかのオプションフラグを指定することができます。 % forgex-cli find match lazy-dfa --help Executes a search for matches using a lazy DFA regex engine. USAGE : forgex - cli find match lazy - dfa < pattern > . match . < text > forgex - cli find match lazy - dfa < pattern > . in . < text > OPTIONS : -- verbose Print more information . -- no - table Suppresses the output of the property information table . -- table - only Print the property information table only .","tags":"","loc":"page/Japanese/forgex_on_command_line_ja.html"},{"title":"Forgexの用語 – Forgex—Fortran Regular Expression","text":"Forgexの開発における用語 このページには、Forgexの開発に関わる用語についての解説が含まれています。 目次 ASCII コードポイント DFA Disjoin Lazy DFA NFA 冪集合構成法 セグメント セグメントのソート 部分集合構成法 テープ Unicode UCS-4 UTF-8 詳細 ASCII ASCII（American Standard Code for Information Interchange）は、1963年に制定された文字符号化に関する規則で、0から127の数字とそれらに対応する文字および記号の関係を定義しています。最初の32文字（10進数の0から31）は制御文字として予約されており、最後の96文字（32から127）は印刷可能（Printable）な文字です。印刷可能文字には、アメリカで使用されているラテン文字が含まれており、数字65～90は大文字のA~Zに対応し、数字97～122は小文字のa～zに対応します。その他は「$」、「#」、「|」などの記号です。 Fortranでは、組込み手続 char() や ichar() を使用してこの対応関係を取得することができます。例えば char の引数に数値70を指定すると文字「F」が返され、逆に ichar の引数に文字「o」を指定すると、整数111が返されます。 Forgexの開発では、ASCIIを部分集合として含むUTF-8コードセットを使用して、文字集合全体にわたる正規表現パターンを処理します。UTF-8の連続したサブセットは、その数値に対応する「セグメント」を定義し、これを使用してUTF-8文字の処理を実現しています。 cf. セグメント 、 Unicode 、 UTF-8 コードポイント（Code Point） コードポイント（コードポジションとも呼ばれる）は文字、記号、絵文字及び制御文字が割り当てられている表の中の特定の位置を指します。 Unicodeでは、コードポイントは「U+」の接頭辞に続く16進数で表現され、その範囲はU+0000からU+10FFFFです。例えば、ラテン文字「A」のコードポイントはU+0041です。同様に漢字「雨」はU+96E8に対応し、絵文字「👍」は U+1FF4D に対応します。 ForgexはUnicodeコードポイントを整数として表現し、 forgex_utf8_m モジュールで char_utf8 及び ichar_utf8 の手続を定義して、コードポイントとそれに対応するUTF-8文字との間での変換を行います。 cf. Unicode 、 UTF-8 DFA 決定性有限オートマトン（Deterministic Finite Automaton、 DFA ）は、決定論的遷移を持つ有限の状態集合について、表現及び操作するために使用される計算機科学における計算の理論モデルです。決定論的遷移とは、状態から状態への遷移が入力文字によって一意に決定されるものを指します。 正規表現処理系の開発における重要な点は、正規表現に一致する文字列集合はDFA（または後述のNFA）を使用して計算することができることです。 Forgexの正規表現エンジンは、まず正規表現のパターンから構文木を作成し、次にNFAを構築します。そしてそのNFAが等価なDFAに変換されて、マッチングの計算が行われます。このとき、構築されたNFAから冪集合構成法（後述）を使用してDFAを構築しますが、現在のバージョンのForgexでは、NFAと入力文字列に対して遅延評価（つまり入力がある前にDFA全体を構築しない）を行い、DFAを構築していきます。この手法はLazy DFAと呼ばれています。この計算を実行するためのForgexの実装では、DFAをシミュレートするラベル付き有向グラフを表すポインタと配列を使用して dfa_t 派生型を定義しています。 cf. NFA 、 冪集合構成法 、 Lazy DFA Disjoin Forgexの開発において、Disjoinとは、複数のセグメントの間で、互いに交差するセグメントをなくすために、一連のセグメントに対して行われる操作をさす。 前提として、Forgexは共通の遷移を共有する入力の集合をセグメントとして表現しています。この場合、交差するセグメントがその集合に含まれていると、Forgexの冪集合構成法の実装では、元のNFAと等価なDFAを構築することはできません。したがって、交差するセグメントの集合を交差点で分割することにより、交差しないセグメントの集合に変換する分割の操作を実行する必要があります。 Disjoinの操作は、 forgex_segment_disjoin_m モジュール内の公開手続として定義されており、特にその中で disjoin_kernel 手続が重要な役割を果たします。 cf. セグメント 、 `forgex_segment_disjoin_m 、 Lazy DFA Lazy DFAは、通常のDFA構築手法とは異なり、遅延評価によって必要に応じて遷移と遷移先を生成する手法です。この手法は、入力が与えられるたびにNFAからの遷移を計算して保存することで大規模なオートマトンを効率的に処理するために使用され、記憶領域の消費量を削減します。すべてのDFA状態を事前に計算する通常のDFA構成の場合と比較して、 a{1、100}*b などの大規模なDFAを必要とするパターンの場合についてDFA全体の事前計算を回避できるため、メモリスペースを節約することができます。 cf. DFA 、 冪集合構成法 . NFA 非決定性有限オートマトン（Non-deterministic Finite Automaton、 NFA ）は、非決定的遷移を伴う有限の状態集合について、表現及び操作するために使用される計算機科学における計算の理論モデルです。非決定的遷移とは、状態から状態への遷移が入力ごとに一意に決定されない遷移です。これには入力文字列を消費しない遷移（ε遷移）も含まれます。 DFAと同様に、NFAは正規表現を処理できますが、効果的にシミュレートするためにはバックトラックと呼ばれる手法を使用する必要があります。ここでは詳細に説明できませんが、NFAについてバックトラックを利用した正規表現処理系は幅広い機能を搭載できる一方で、すべてのパターンで高速な処理を実現することは困難です。つまり、NFAによるエンジンには苦手なパターンというものが存在しています。 Forgexは、多くのFortranユーザーが主眼においている要件である、高い実行時のパフォーマンスに重点をおいています。したがって、NFAをマッチングに直接使うのではなく、NFAと同等のDFAに変換してマッチングを行います。変換前のNFAは nfa_t 派生型として定義されています。その変換の詳細については、後述の「冪集合構成法」を参照してください。 cf. DFA 、 冪集合構成法 冪集合構成法（Powerset Construciton Method） 冪集合構成法（Powerset Construction Method）または部分集合構成法（Subset Construction Method）は、NFAをDFAをに変換する処理です。この方法を使用すると非決定的性質を持つオートマトンをそれと等価な、つまり同じ入力文字列を受理するDFAに変換することができます。 このアプローチは、決定性状態機械を構築できるという点で強力なものですが、しかしながら、変換によって構築されるDFA状態の数が指数関数的に増加する可能性があるという欠点を持ちます。この問題は組合せ爆発と呼ばれる問題の一種です。Forgexのバージョン2.0以降では入力文字に対応するDFA状態を動的に生成できるLazy DFAが導入されているので、この問題について心配する必要はありません。 cf. 部分集合構成法 - Wikipedia 、 組合せ爆発- Wikipedia セグメント（Segment） セグメント（segment）とは、文字集合全体の部分集合であり連続した区間として、開始点と終了点の2つの数字で定義されます。状態機械をシミュレートにおいて、単一の入力文字を計算するべき遷移に割り当てると、（特に文字クラスおよび否定クラスを処理する場合に）大量のメモリを消費するため、Forgexは文字集合の部分的な区間を遷移に関連付ける方法を使用して、メモリの消費を低減しています。ただし、このアプローチを導入することによって新たな問題が生じることにも注意してください。その詳細についてはDisjoinの説明を参照してください。 Forgexのセグメントの実装では、 segment_t 派生型として次のように定義されています。 type 、 public :: segment_t integer ( int32 ) :: min = UTF8_CODE_EMPTY ! = 0 integer ( int32 ) :: max = UTF8_CODE_EMPTY ! = 0 contains procedure :: validate => segment_is_valid end type segment_t 型には、 min と max の2つの成分と型束縛手続の validate が含まれます。 min は区間内で最小のコードポイント値、 max は最大のコードポイント値を保持します。手続 validate は成分 min が成分 max 以下であるかどうかを確認します。 min と max が等しい場合、そのセグメントはただ1文字のみを表現します。 cf. Disjoin 、 セグメントのソート セグメントのソート セグメントのソートには、セグメントの集合をDisjoinな状態に再構築するために必要な処理で、 forgex_sort_m モジュールで定義されたソート手順は、 forgex_segment_disjoin_m モジュールの disjoin_kernel 手続によって呼び出されます。現在実装されているアルゴリズムはバブルソートです。このアルゴリズムが使用されているのは、ソートされる要素の数が少なく、実行時間に対するこの処理の寄与が比較的小さいためです。ただし、近い将来に挿入ソートに変更することを予定しています。 cf. Disjoin 、 セグメント 、 forgex_sort_m 、 forgex_segment_disjoin_m . 部分集合構成法（Subset Construction Method） 冪集合構成法 を参照してください。 テープ（Tape） Forgexの実装において、テープ（tape）とは、シーケンシャルなデータアクセスと読み取りヘッダーを備えたストレージ（磁気テープなど）に例えて、それを模倣した派生型を使用しています。これは構文解析モジュール（ forgex_syntax_tree_m ）において tape_t 派生型として定義されています。この型には、入力パターンの文字列全体（巻かれた磁気テープの例え）とインデックス番号（読み取りヘッダーの例え）に関する情報が含まれています。Forgexの開発者は、現在読み込まれている文字とトークンを、それの型束縛手続を通じて使用することができます。 cf. forgex_syntax_tree_m 、 tape_t Unicode Unicodeは文字符号化の標準規格の一つであり、これを使用することで、さまざまな言語やプラットフォーム間でテキストの一貫した表現と処理が可能となる。すべての文字と記号に一意の番号（コードポイント）を割り当てて、広範囲の文字、記号、さらに絵文字をカバーしている。Unicode文字は、UTF-8、UTF-16、UTF-32などの共通の符号化方式を使用してバイト列にエンコードされ、様々なプラットフォーム間での互換性が確保されています。 Note MicrosoftのWindowsオペレーティングシステムの場合、システムの標準の文字コードがUTF-8でない場合があるため、ユーザーが設定を適切な変更を行う必要があるかもしれません。 cf. コードポイント 、 UTF-8 UCS-4 UCS-4（Universal Coded Character Set 4）もしくはほぼ同等のUTF-32（ISO/IEC 10646で定義されたされている）は、それぞれのUnicodeのコードポジションに32ビット（4バイト）のバイナリ列を割り当てる固定長の符号化方式です。Fortran 2003準拠のコンパイラの一部では、文字列型の宣言において型パラメーター kind を selected_char_kind('ISO_10646') の戻り値に指定することで、この固定長4バイト文字を使用することができる。例えば GNUのFortranコンパイラはこれをサポートしています。 Forgexは現在のところ、UCS-4文字列の処理をサポートしていません。 cf. Unicode 、 UTF-8 、 UTF-32 - Wikipedia UTF-8 UTF-8（UCS Transformation Format 8、または Unicode Transformation Format-8）は、Unicode文字を1バイトから4バイトの可変長バイト列に対応させる文字符号化の方式の1つです。ASCII文字との互換性を維持するために、ASCII文字の部分は1バイトで表現され、その他の文字は2バイトから4バイトで表現されます。Forgexは forgex_utf8_m モジュールで定義された手続を使用して、UTF-8で符号化された文字列を処理します。 cf. forgex_utf8_m 参考文献 How to implement regular expression NFA with character ranges? - Stack Overflow 、 2013 Using Unicode Characters in Fortran - Fortran-lang Discourse","tags":"","loc":"page/Japanese/terms_of_forgex_ja.html"}]}