var tipuesearch = {"pages":[{"title":" Forgex-CLI ","text":"Forgex-CLI This package provides a command line tool which named forgex-cli for interacting with Forgex—Fortran Regular Expression .\nThe forgex-cli command was originally part of Forgex package, but was moved to this separate repository starting with Forgex version 3.5. Installation Getting Source Code Clone the repository: git clone https://github.com/shinobuamasaki/forgex-cli Alternatively, download the latest source package: wget https://github.com/ShinobuAmasaki/forgex-cli/archive/refs/tags/v3.5.tar.gz In that case, decompress the archive file: tar xvzf v3.5.tar.gz Building Change directory to the cloned or decompressed location: cd forgex-cli Execute building with Fortran Package Manager ( fpm ): fpm build This will automatically resolve the dependency and compile forgex-cli , including forgex . Operation Check Operation of this command has been confirmed with the following compilers: GNU Fortran ( gfortran ) v13.2.1 Intel Fortran Compiler ( ifx ) 2024.0.0 20231017 It is assumed that you will use the Fortran Package Manager( fpm ). Usage This article describes basic usage of forgex-cli . Command Line Interface Currently, commands find and debug ,  and following subcommands and sub-subcommands can be executed: forgex-cli\n├── find\n│   └── match\n│       ├── lazy-dfa <pattern> <operator> <input text>\n│       ├── dense <pattern> <operator> <input text>\n│       └── forgex <pattern> <operator> <input text>\n└── debug\n    ├── ast <pattern>\n    └── thompson <pattern> Run the forgex-cli command as follows: forgex-cli <comamnd> <subcommand> ...\nfpm run -- <command> <subcommand> ... Examples find command Using the find command and the match subcommand, you can specify an engine and run benchmark tests on regular expression matching with .in. and .match. operators.\nAfter the subcommand, select the engine from, lazy-dfa , dense , forgex , and after that, specify the pattern, operator, and input string as if you were writing Fortran code using Forgex to perform matching. For instance, execute the find command: forgex-cli find match lazy-dfa '([a-z]*g+)n?' .match. 'assign' If you run it through fpm run : fpm run --profile release -- find match lazy-dfa '([a-z]*g+)n?' .match. 'assign' and you will get output similar to the following: pattern: ([ a - z ] * g + ) n ? text: ' assign ' parse time : 42.9 μ s extract literal time : 23.0 μ s runs engine: T compile nfa time : 26.5 μ s dfa initialize time : 4.6 μ s search time : 617.1 μ s matching result: T automata and tree size: 10324 bytes ========== Thompson NFA =========== state 1 : ( ? , 5 ) state 2 : < Accepted > state 3 : ( n , 2 )( ? , 2 ) state 4 : ( g , 7 ) state 5 : ([ \"a\" - \"f\" ], 6 )( g , 6 )([ \"h\" - \"m\" ], 6 )( n , 6 )([ \"o\" - \"z\" ], 6 )( ? , 4 ) state 6 : ( ? , 5 ) state 7 : ( ? , 8 ) state 8 : ( g , 9 )( ? , 3 ) state 9 : ( ? , 8 ) =============== DFA =============== 1 : [ \"a\" - \"f\" ] => 2 2 : [ \"o\" - \"z\" ] => 2 [ \"h\" - \"m\" ] => 2 g => 3 3 A: n => 4 4 A: state 1 = ( 1 4 5 ) state 2 = ( 4 5 6 ) state 3 A = ( 2 3 4 5 6 7 8 ) state 4 A = ( 2 4 5 6 ) =================================== debug Using debug command allows you to obtain information about the abstract syntax tree and the structure of the Thompson NFA. For example, execute the debug command with ast subcommand: forgex-cli debug ast 'foo[0-9]+bar' then, you will get output similar to the following: parse time : 133 . 8μs extract time : 36 . 8μs extracted literal : extracted prefix : foo extracted suffix : bar memory ( estimated ): 848 ( concatenate ( concatenate ( concatenate ( concatenate ( concatenate ( concatenate \"f\" \"o\" ) \"o\" ) ( concatenate [ \"0\" - \"9\" ; ] ( closure [ \"0\" - \"9\" ; ] ))) \"b\" ) \"a\" ) \"r\" ) Note: Notice also that the prefix and suffix literals are now extracted. Here's how to get a graph of the NFA. To get the Thompson NFA, run the following command: forgex-cli debug thompson 'foo[0-9]+bar' This will give you output like this: parse time:       144.5μs\n  compile nfa time:        57.0μs\nmemory (estimated):     11589\n\n========== Thompson NFA ===========\nstate    1: (f, 8)\nstate    2: <Accepted>\nstate    3: (r, 2)\nstate    4: (a, 3)\nstate    5: (b, 4)\nstate    6: ([\"0\"-\"9\"], 9)\nstate    7: (o, 6)\nstate    8: (o, 7)\nstate    9: (?, 10)\nstate   10: ([\"0\"-\"9\"], 11)(?, 5)\nstate   11: (?, 10)\n\nNote: all segments of NFA were disjoined with overlapping portions.\n=================================== Notes You can get information about available option flags specifying the --help command line argument. If you use this forgex-cli command with PowerShell on Windows, use UTF-8 as your system locale to properly input and output Unicode characters. To do The following features are planned to be implemented in the future: Publish the documentation Support CMake building ✅️ Add a CLI tool for debugging and benchmarking ✅️ Add Time measurement tools (basic) Code Convention All code contained herein shall be written with a three-space indentation. Acknowledgements The command-line interface design of forgex-cli was inspired in part by the package regex-cli of Rust language. References rust-lang/regex/regex-cli License Forgex-CLI is as a freely available under the MIT license. See LICENSE . Developer Info Amasaki Shinobu","tags":"home","loc":"index.html"},{"title":"cla_t – Forgex-CLI ","text":"type, public :: cla_t Components Type Visibility Attributes Name Initial type( arg_t ), public :: arg_info type( cmd_t ), public :: cmd integer, public :: flag_idx (NUM_FLAGS) logical, public :: flags (NUM_FLAGS) type( pattern_t ), public, allocatable :: patterns (:) type( cmd_t ), public :: sub_cmd type( cmd_t ), public :: sub_sub_cmd Type-Bound Procedures procedure, public :: collect_flags => cla__collect_flags private  subroutine cla__collect_flags (cla) Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: do_debug => cla__do_debug_subc private  subroutine cla__do_debug_subc (cla) Processes the debug command, reads a subcommand, and calls the corresponding procedure. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: do_find => cla__do_find_subc private  subroutine cla__do_find_subc (cla) Processes the debug command, reads a subcommand and a sub-subcommand,\nand calls the corresponding procedure. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: get_patterns => cla__get_patterns private  subroutine cla__get_patterns (cla, offset) Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla integer, intent(in) :: offset procedure, public :: init => cla__initialize private  subroutine cla__initialize (cla) Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: init_debug => cla__init_debug_subc private  subroutine cla__init_debug_subc (cla) Prepare subcommands for the debug command. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: init_find => cla__init_find_subc private  subroutine cla__init_find_subc (cla) Prepare subcommands for the find command. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: init_find_match => cla__init_find_match_subsubc private  subroutine cla__init_find_match_subsubc (cla) Prepare sub-subcommands for the match subcommand. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: read_cmd => cla__read_command private  subroutine cla__read_command (cla) Read the first argument and match it with registered commands. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: read_subc => cla__read_subcommand private  subroutine cla__read_subcommand (cla) Read the second argument and match it with registered subcommands. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla procedure, public :: read_subsubc => cla__read_sub_subcommand private  subroutine cla__read_sub_subcommand (cla) Read the third argument and match it with registered sub-subcommands. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code type , public :: cla_t type ( arg_t ) :: arg_info type ( cmd_t ) :: cmd , sub_cmd , sub_sub_cmd type ( pattern_t ), allocatable :: patterns (:) logical :: flags ( NUM_FLAGS ) integer :: flag_idx ( NUM_FLAGS ) contains procedure :: init => cla__initialize procedure :: read_cmd => cla__read_command procedure :: read_subc => cla__read_subcommand procedure :: read_subsubc => cla__read_sub_subcommand procedure :: collect_flags => cla__collect_flags procedure :: get_patterns => cla__get_patterns procedure :: init_debug => cla__init_debug_subc procedure :: init_find => cla__init_find_subc procedure :: init_find_match => cla__init_find_match_subsubc procedure :: do_debug => cla__do_debug_subc procedure :: do_find => cla__do_find_subc end type cla_t","tags":"","loc":"type/cla_t.html"},{"title":"arg_element_t – Forgex-CLI ","text":"type, public :: arg_element_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: v Source Code type , public :: arg_element_t character (:), allocatable :: v end type arg_element_t","tags":"","loc":"type/arg_element_t.html"},{"title":"arg_t – Forgex-CLI ","text":"type, public :: arg_t Components Type Visibility Attributes Name Initial type( arg_element_t ), public, allocatable :: arg (:) integer, public :: argc character(len=:), public, allocatable :: entire Source Code type , public :: arg_t integer :: argc type ( arg_element_t ), allocatable :: arg (:) character (:), allocatable :: entire end type arg_t","tags":"","loc":"type/arg_t.html"},{"title":"cmd_t – Forgex-CLI ","text":"type, public :: cmd_t Components Type Visibility Attributes Name Initial character(len=LEN_CMD), public, allocatable :: subc (:) character(len=LEN_CMD), private :: name = '' Type-Bound Procedures procedure, public :: get_name => cmd__get_name private pure function cmd__get_name (self) result(res) Arguments Type Intent Optional Attributes Name class( cmd_t ), intent(in) :: self Return Value character(len=:), allocatable procedure, public :: set_name => cmd__set_name private pure subroutine cmd__set_name (self, name) Arguments Type Intent Optional Attributes Name class( cmd_t ), intent(inout) :: self character(len=*), intent(in) :: name Source Code type , public :: cmd_t ! command type character ( LEN_CMD ), private :: name = '' character ( LEN_CMD ), allocatable :: subc (:) ! sub-command contains procedure :: get_name => cmd__get_name procedure :: set_name => cmd__set_name end type cmd_t","tags":"","loc":"type/cmd_t.html"},{"title":"flag_t – Forgex-CLI ","text":"type, public :: flag_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_f character(len=32), public :: name character(len=:), public, allocatable :: short_f Source Code type , public :: flag_t character ( 32 ) :: name character (:), allocatable :: long_f , short_f end type flag_t","tags":"","loc":"type/flag_t.html"},{"title":"pattern_t – Forgex-CLI ","text":"type, public :: pattern_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: p Source Code type , public :: pattern_t character (:), allocatable :: p end type pattern_t","tags":"","loc":"type/pattern_t.html"},{"title":"get_lap_time_in_appropriate_unit – Forgex-CLI","text":"public  function get_lap_time_in_appropriate_unit(lap_time) result(res) This function takes a real number of seconds, converts it to the appropriate\nunits, and returns a string with the unit for output. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: lap_time Return Value character(len=NUM_DIGIT_TIME) Source Code function get_lap_time_in_appropriate_unit ( lap_time ) result ( res ) implicit none real ( real64 ), intent ( in ) :: lap_time character ( NUM_DIGIT_TIME ) :: res character ( 3 ) :: unit real ( real64 ) :: multiplied unit = 's' if ( lap_time >= 6 d1 ) then unit = 'm' multiplied = lap_time / 6 d1 else if ( lap_time >= 1 d0 ) then unit = 's' multiplied = lap_time else if ( lap_time >= 1 d - 3 ) then unit = 'ms' multiplied = lap_time * 1 d3 else if ( lap_time >= 1 d - 6 ) then if ( get_os_type () == OS_WINDOWS ) then unit = 'us' else unit = 'μs' end if multiplied = lap_time * 1 d6 else unit = 'ns' multiplied = lap_time * 1 d9 end if write ( res , '(f10.1, a)' ) multiplied , unit end function get_lap_time_in_appropriate_unit","tags":"","loc":"proc/get_lap_time_in_appropriate_unit.html"},{"title":"time_lap – Forgex-CLI","text":"public  function time_lap() result(res) This function is for timing purposes and returns the lap time\nsince the last call of time_begin or time_lap . Arguments None Return Value real(kind=real64) Source Code function time_lap () result ( res ) implicit none real ( real64 ) :: res if ( get_os_type () == OS_WINDOWS ) then if ( is_supported ) then is_succeeded = QueryPerformanceCounter ( time_end_qhc ) res = dble ( time_end_qhc - time_begin_qhc ) / dble ( frequency ) time_begin_qhc = time_end_qhc else !$ end_s = omp_get_wtime() !$ res = end_s - last_s !$ last_s = end_s !$ return call use_cpu_time_end end if else !$ end_s = omp_get_wtime() !$ res = end_s - last_s !$ last_s = end_s !$ return call use_cpu_time_end end if contains subroutine use_cpu_time_end implicit none call cpu_time ( end_s ) res = end_s - last_s last_s = end_s end subroutine use_cpu_time_end end function time_lap","tags":"","loc":"proc/time_lap.html"},{"title":"time_begin – Forgex-CLI","text":"public  subroutine time_begin() This subroutine is for timing purpose and starts a stopwatch. Arguments None Source Code subroutine time_begin () implicit none if ( get_os_type () == OS_WINDOWS ) then is_supported = QueryPerformanceFrequency ( frequency ) if ( is_supported ) then is_succeeded = QueryPerformanceCounter ( time_begin_qhc ) else !$ begin_s = omp_get_wtime() !$ last_s = begin_s !$ return call use_cpu_time_begin end if else !$ begin_s = omp_get_wtime() !$ last_s = begin_s !$ return call use_cpu_time_begin end if contains subroutine use_cpu_time_begin implicit none begin_s = 0 d0 last_s = 0 d0 end_s = 0 d0 call cpu_time ( begin_s ) last_s = begin_s end subroutine use_cpu_time_begin end subroutine time_begin","tags":"","loc":"proc/time_begin.html"},{"title":"QueryPerformanceCounter – Forgex-CLI","text":"interface For Windows, use high-resolution system call for timing. private  function QueryPerformanceCounter(PerformanceCount_count) result(is_succeeded_c) bind(c, name=\"QueryPerformanceCounter\") Arguments Type Intent Optional Attributes Name integer(kind=c_long_long), intent(out) :: PerformanceCount_count Return Value logical(kind=c_bool)","tags":"","loc":"interface/queryperformancecounter.html"},{"title":"QueryPerformanceFrequency – Forgex-CLI","text":"interface For Windows, use high-resolution system call for timing. private  function QueryPerformanceFrequency(Frequency_countPerSec) result(is_supported_c) bind(c, name=\"QueryPerformanceFrequency\") Arguments Type Intent Optional Attributes Name integer(kind=c_long_long), intent(out) :: Frequency_countPerSec Return Value logical(kind=c_bool)","tags":"","loc":"interface/queryperformancefrequency.html"},{"title":"do_find_match_dense_dfa – Forgex-CLI","text":"public  subroutine do_find_match_dense_dfa(flags, pattern, text, is_exactly) Uses forgex_cli_memory_calculation_m forgex_dense_dfa_m forgex_utility_m forgex_syntax_tree_graph_m forgex_nfa_state_set_m forgex_automaton_m forgex_cli_utils_m forgex_cli_time_measurement_m Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern character(len=*), intent(in) :: text logical, intent(in) :: is_exactly Source Code subroutine do_find_match_dense_dfa ( flags , pattern , text , is_exactly ) use :: forgex_automaton_m use :: forgex_syntax_tree_graph_m use :: forgex_cli_memory_calculation_m use :: forgex_cli_time_measurement_m use :: forgex_dense_dfa_m use :: forgex_nfa_state_set_m use :: forgex_cli_utils_m use :: forgex_utility_m implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern character ( * ), intent ( in ) :: text logical , intent ( in ) :: is_exactly type ( tree_t ) :: tree type ( automaton_t ) :: automaton integer :: uni , ierr , i character (:), allocatable :: dfa_for_print character ( 256 ) :: line real ( real64 ) :: lap1 , lap2 , lap3 , lap4 , lap5 logical :: res integer :: from , to from = 0 to = 0 if ( flags ( FLAG_HELP ) . or . pattern == '' ) call print_help_find_match_dense_dfa if ( flags ( FLAG_NO_LITERAL )) call info ( \"No literal search optimization is implemented in dense DFA.\" ) call time_begin () ! call build_syntax_tree(trim(pattern), tape, tree, root) call tree % build ( trim ( pattern )) lap1 = time_lap () call automaton % preprocess ( tree ) lap2 = time_lap () ! build nfa call automaton % init () lap3 = time_lap () ! automaton initialize call construct_dense_dfa ( automaton , automaton % initial_index ) lap4 = time_lap () ! compile nfa to dfa if ( is_exactly ) then res = match_dense_dfa_exactly ( automaton , text ) if ( res ) then from = 1 to = len ( text ) end if else block call match_dense_dfa_including ( automaton , char ( 10 ) // text // char ( 10 ), from , to ) if ( is_there_caret_at_the_top ( pattern )) then from = from else from = from - 1 end if if ( is_there_dollar_at_the_end ( pattern )) then to = to - 2 else to = to - 1 end if if ( from > 0 . and . to > 0 ) then res = . true . else res = . false . end if end block end if lap5 = time_lap () ! search time open ( newunit = uni , status = 'scratch' ) write ( uni , fmta ) HEADER_NFA call automaton % nfa % print ( uni , automaton % nfa_exit ) write ( uni , fmta ) HEADER_DFA call automaton % print_dfa ( uni ) rewind ( uni ) ierr = 0 dfa_for_print = '' do while ( ierr == 0 ) read ( uni , fmta , iostat = ierr ) line if ( ierr /= 0 ) exit if ( get_os_type () == OS_WINDOWS ) then dfa_for_print = dfa_for_print // trim ( line ) // CRLF else dfa_for_print = dfa_for_print // trim ( line ) // LF end if end do close ( uni ) output : block character ( NUM_DIGIT_KEY ) :: pattern_key , text_key character ( NUM_DIGIT_KEY ) :: parse_time , nfa_time , dfa_init_time , dfa_compile_time , matching_time character ( NUM_DIGIT_KEY ) :: memory character ( NUM_DIGIT_KEY ) :: tree_count , nfa_count , dfa_count character ( NUM_DIGIT_KEY ) :: matching_result character ( NUM_DIGIT_KEY ) :: cbuff ( 12 ) = '' integer :: memsiz pattern_key = \"pattern:\" text_key = \"text:\" parse_time = \"parse time:\" nfa_time = \"compile nfa time:\" dfa_init_time = \"dfa initialize time:\" dfa_compile_time = \"compile dfa time:\" matching_time = \"search time:\" memory = \"memory (estimated):\" matching_result = \"matching result:\" tree_count = \"tree node count:\" nfa_count = \"nfa states:\" dfa_count = \"dfa states:\" memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) + mem_nfa_graph ( automaton % nfa ) & + mem_dfa_graph ( automaton % dfa ) + 4 * 3 if ( allocated ( automaton % entry_set % vec )) then memsiz = memsiz + size ( automaton % entry_set % vec , dim = 1 ) end if if ( allocated ( automaton % all_segments )) then memsiz = memsiz + size ( automaton % all_segments , dim = 1 ) * 8 end if if ( flags ( FLAG_VERBOSE )) then cbuff = [ pattern_key , text_key , parse_time , nfa_time , dfa_init_time , dfa_compile_time , matching_time ,& matching_result , memory , tree_count , nfa_count , dfa_count ] call right_justify ( cbuff ) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 1 )), trim ( adjustl ( pattern )) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 2 )), \"'\" // text_highlight_green ( text , from , to ) // \"'\" write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 5 )), get_lap_time_in_appropriate_unit ( lap3 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 8 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 9 )), memsiz write ( stdout , fmt_out_ratio ) trim ( cbuff ( 10 )), tree % top , size ( tree % nodes , dim = 1 ) write ( stdout , fmt_out_ratio ) trim ( cbuff ( 11 )), automaton % nfa % nfa_top , automaton % nfa % nfa_limit write ( stdout , fmt_out_ratio ) trim ( cbuff ( 12 )), automaton % dfa % dfa_top , automaton % dfa % dfa_limit else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff = [ pattern_key , text_key , parse_time , nfa_time , dfa_init_time , dfa_compile_time , matching_time ,& matching_result , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 3 )] call right_justify ( cbuff ) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 1 )), trim ( adjustl ( pattern )) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 2 )), \"'\" // text_highlight_green ( text , from , to ) // \"'\" write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 5 )), get_lap_time_in_appropriate_unit ( lap3 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 8 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 9 )), memsiz end if if ( flags ( FLAG_TABLE_ONLY )) then call automaton % free () return end if write ( stdout , * ) \"\" write ( stdout , fmta , advance = 'no' ) trim ( dfa_for_print ) write ( stdout , fmta ) FOOTER end block output call automaton % free () end subroutine do_find_match_dense_dfa","tags":"","loc":"proc/do_find_match_dense_dfa.html"},{"title":"do_find_match_forgex – Forgex-CLI","text":"public  subroutine do_find_match_forgex(flags, pattern, text, is_exactly) Uses forgex forgex_cli_time_measurement_m forgex_cli_utils_m forgex_parameters_m Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern character(len=*), intent(in) :: text logical, intent(in) :: is_exactly Source Code subroutine do_find_match_forgex ( flags , pattern , text , is_exactly ) use :: forgex , only : regex , operator (. in .), operator (. match .) use :: forgex_parameters_m , only : INVALID_CHAR_INDEX use :: forgex_cli_time_measurement_m use :: forgex_cli_utils_m , only : text_highlight_green implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern , text logical , intent ( in ) :: is_exactly real ( real64 ) :: lap logical :: res character (:), allocatable :: res_string integer :: from , to , unused res_string = '' from = INVALID_CHAR_INDEX to = INVALID_CHAR_INDEX call time_begin () if ( is_exactly ) then res = pattern . match . text else res = pattern . in . text end if lap = time_lap () ! Invoke regex subroutine to highlight matched substring. call regex ( pattern , text , res_string , unused , from , to ) output : block character ( NUM_DIGIT_KEY ) :: pattern_key , text_key character ( NUM_DIGIT_KEY ) :: total_time , matching_result character ( NUM_DIGIT_KEY ) :: buf ( 4 ) pattern_key = \"pattern:\" text_key = \"text:\" total_time = \"time:\" matching_result = \"result:\" if ( flags ( FLAG_NO_TABLE )) then write ( stdout , * ) res else buf = [ pattern_key , text_key , total_time , matching_result ] call right_justify ( buf ) write ( stdout , '(a, 1x, a)' ) trim ( buf ( 1 )), trim ( adjustl ( pattern )) write ( stdout , '(a, 1x, a)' ) trim ( buf ( 2 )), '\"' // text_highlight_green ( text , from , to ) // '\"' write ( stdout , fmt_out_time ) trim ( buf ( 3 )), get_lap_time_in_appropriate_unit ( lap ) write ( stdout , fmt_out_logi ) trim ( buf ( 4 )), res end if end block output end subroutine do_find_match_forgex","tags":"","loc":"proc/do_find_match_forgex.html"},{"title":"do_find_match_lazy_dfa – Forgex-CLI","text":"public  subroutine do_find_match_lazy_dfa(flags, pattern, text, is_exactly) Uses forgex_cli_memory_calculation_m forgex_api_internal_m forgex_parameters_m forgex_utility_m forgex_syntax_tree_graph_m forgex_nfa_state_set_m forgex_automaton_m forgex_cli_utils_m forgex_syntax_tree_optimize_m Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern character(len=*), intent(in) :: text logical, intent(in) :: is_exactly Source Code subroutine do_find_match_lazy_dfa ( flags , pattern , text , is_exactly ) use :: forgex_automaton_m use :: forgex_syntax_tree_graph_m use :: forgex_syntax_tree_optimize_m use :: forgex_cli_memory_calculation_m use :: forgex_api_internal_m use :: forgex_nfa_state_set_m use :: forgex_cli_utils_m use :: forgex_utility_m , only : is_there_caret_at_the_top , is_there_dollar_at_the_end use :: forgex_parameters_m , only : ACCEPTED_EMPTY implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern character ( * ), intent ( in ) :: text logical , intent ( in ) :: is_exactly type ( tree_t ) :: tree type ( automaton_t ) :: automaton integer :: uni , ierr , i character (:), allocatable :: dfa_for_print , prefix , suffix , entire character ( 256 ) :: line real ( real64 ) :: lap1 , lap2 , lap3 , lap4 , lap5 logical :: res , flag_runs_engine , flag_fixed_string integer :: from , to dfa_for_print = '' lap1 = 0 d0 lap2 = 0 d0 lap3 = 0 d0 lap4 = 0 d0 lap5 = 0 d0 from = 0 to = 0 prefix = '' suffix = '' entire = '' flag_fixed_string = . false . flag_runs_engine = . false . if ( flags ( FLAG_HELP ) . or . pattern == '' ) call print_help_find_match_lazy_dfa call time_begin () call tree % build ( trim ( pattern )) lap1 = time_lap () call time_begin () if (. not . flags ( FLAG_NO_LITERAL )) then entire = get_entire_literal ( tree ) if ( entire /= '' ) flag_fixed_string = . true . if (. not . flag_fixed_string ) then prefix = get_prefix_literal ( tree ) suffix = get_suffix_literal ( tree ) end if end if lap5 = time_lap () if (. not . flag_fixed_string ) then call automaton % preprocess ( tree ) lap2 = time_lap () call automaton % init () lap3 = time_lap () end if if ( is_exactly ) then if ( flag_fixed_string ) then if ( len ( text ) == len ( entire )) then res = text == entire end if else call runner_do_matching_exactly ( automaton , text , res , prefix , suffix , flags ( FLAG_NO_LITERAL ), flag_runs_engine ) end if lap4 = time_lap () if ( res ) then from = 1 to = len ( text ) end if else block if ( flag_fixed_string ) then from = index ( text , entire ) if ( from > 0 ) to = from + len ( entire ) - 1 else call runner_do_matching_including ( automaton , text , from , to , & prefix , suffix , flags ( FLAG_NO_LITERAL ), flag_runs_engine ) end if if ( from > 0 . and . to > 0 ) then res = . true . else if ( from == ACCEPTED_EMPTY . and . to == ACCEPTED_EMPTY ) then res = . true . else res = . false . end if lap4 = time_lap () end block end if open ( newunit = uni , status = 'scratch' ) write ( uni , fmta ) HEADER_NFA call automaton % nfa % print ( uni , automaton % nfa_exit ) write ( uni , fmta ) HEADER_DFA call automaton % print_dfa ( uni ) rewind ( uni ) ierr = 0 do while ( ierr == 0 ) read ( uni , fmta , iostat = ierr ) line if ( ierr /= 0 ) exit if ( get_os_type () == OS_WINDOWS ) then dfa_for_print = dfa_for_print // trim ( line ) // CRLF else dfa_for_print = dfa_for_print // trim ( line ) // LF end if end do close ( uni ) output : block character ( NUM_DIGIT_KEY ) :: pattern_key , text_key character ( NUM_DIGIT_KEY ) :: parse_time , extract_time character ( NUM_DIGIT_KEY ) :: nfa_time , dfa_init_time , matching_time , memory character ( NUM_DIGIT_KEY ) :: runs_engine_key character ( NUM_DIGIT_KEY ) :: tree_count character ( NUM_DIGIT_KEY ) :: nfa_count character ( NUM_DIGIT_KEY ) :: dfa_count , matching_result character ( NUM_DIGIT_KEY ) :: cbuff ( 13 ) = '' integer :: memsiz pattern_key = \"pattern:\" text_key = \"text:\" parse_time = \"parse time:\" extract_time = \"extract literal time:\" runs_engine_key = \"runs engine:\" nfa_time = \"compile nfa time:\" dfa_init_time = \"dfa initialize time:\" matching_time = \"search time:\" memory = \"memory (estimated):\" matching_result = \"matching result:\" tree_count = \"tree node count:\" nfa_count = \"nfa states:\" dfa_count = \"dfa states:\" if ( flag_fixed_string ) then memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) else memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) + mem_nfa_graph ( automaton % nfa ) & + mem_dfa_graph ( automaton % dfa ) + 4 * 3 end if if ( allocated ( automaton % entry_set % vec )) then memsiz = memsiz + size ( automaton % entry_set % vec , dim = 1 ) end if if ( allocated ( automaton % all_segments )) then memsiz = memsiz + size ( automaton % all_segments , dim = 1 ) * 8 end if if ( flags ( FLAG_VERBOSE )) then cbuff = [ pattern_key , text_key , parse_time , extract_time , runs_engine_key , & nfa_time , dfa_init_time , matching_time , matching_result , memory , tree_count , & nfa_count , dfa_count ] call right_justify ( cbuff ) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 1 )), trim ( adjustl ( pattern )) ! write(stdout, '(a, 1x, a)') trim(cbuff(2)), '\"'//text//'\"' write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 2 )), '\"' // text_highlight_green ( text , from , to ) // '\"' write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 5 )), flag_runs_engine if ( flag_runs_engine . or . . not . flag_fixed_string ) then write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap3 ) else write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), not_running write ( stdout , fmt_out_char ) trim ( cbuff ( 7 )), not_running end if write ( stdout , fmt_out_time ) trim ( cbuff ( 8 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 9 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 10 )), memsiz write ( stdout , fmt_out_ratio ) trim ( cbuff ( 11 )), tree % top , size ( tree % nodes , dim = 1 ) write ( stdout , fmt_out_ratio ) trim ( cbuff ( 12 )), automaton % nfa % nfa_top , automaton % nfa % nfa_limit write ( stdout , fmt_out_ratio ) trim ( cbuff ( 13 )), automaton % dfa % dfa_top , automaton % dfa % dfa_limit else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff (:) = [ pattern_key , text_key , parse_time , extract_time , runs_engine_key , nfa_time , dfa_init_time , & matching_time , matching_result , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 3 )] call right_justify ( cbuff ) write ( stdout , '(a,1x,a)' ) trim ( cbuff ( 1 )), pattern ! write(stdout, '(a,1x,a)') trim(cbuff(2)), \"'\"//text//\"'\" write ( stdout , '(a,1x,a)' ) trim ( cbuff ( 2 )), \"'\" // text_highlight_green ( text , from , to ) // \"'\" write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 5 )), flag_runs_engine if ( flag_runs_engine . or . . not . flag_fixed_string ) then write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap3 ) else write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), not_running write ( stdout , fmt_out_char ) trim ( cbuff ( 7 )), not_running end if write ( stdout , fmt_out_time ) trim ( cbuff ( 8 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 9 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 10 )), memsiz end if if ( flags ( FLAG_TABLE_ONLY ) . or . . not . flag_runs_engine . or . flag_fixed_string ) then call automaton % free return end if write ( stdout , * ) \"\" write ( stdout , fmta , advance = 'no' ) trim ( dfa_for_print ) write ( stdout , fmta ) FOOTER end block output call automaton % free end subroutine do_find_match_lazy_dfa","tags":"","loc":"proc/do_find_match_lazy_dfa.html"},{"title":"runner_do_matching_exactly – Forgex-CLI","text":"private  subroutine runner_do_matching_exactly(automaton, text, res, prefix, suffix, flag_no_literal_optimize, runs_engine) Uses forgex_api_internal_m forgex_syntax_tree_optimize_m forgex_automaton_m forgex_cli_api_internal_no_opts_m Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: text logical, intent(inout) :: res character(len=*), intent(in) :: prefix character(len=*), intent(in) :: suffix logical, intent(in) :: flag_no_literal_optimize logical, intent(inout) :: runs_engine Source Code subroutine runner_do_matching_exactly ( automaton , text , res , prefix , suffix , flag_no_literal_optimize , runs_engine ) use :: forgex_automaton_m use :: forgex_syntax_tree_optimize_m use :: forgex_cli_api_internal_no_opts_m use :: forgex_api_internal_m implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: text logical , intent ( inout ) :: res logical , intent ( inout ) :: runs_engine logical , intent ( in ) :: flag_no_literal_optimize character ( * ), intent ( in ) :: prefix , suffix if ( flag_no_literal_optimize ) then call do_matching_exactly_no_literal_opts ( automaton , text , res ) runs_engine = . true . else call do_matching_exactly ( automaton , text , res , prefix , suffix , runs_engine ) end if end subroutine runner_do_matching_exactly","tags":"","loc":"proc/runner_do_matching_exactly.html"},{"title":"runner_do_matching_including – Forgex-CLI","text":"private  subroutine runner_do_matching_including(automaton, text, from, to, prefix, suffix, flag_no_literal_optimize, runs_engine) Uses forgex_api_internal_m forgex_syntax_tree_optimize_m forgex_automaton_m forgex_cli_api_internal_no_opts_m Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: text integer(kind=int32), intent(inout) :: from integer(kind=int32), intent(inout) :: to character(len=*), intent(in) :: prefix character(len=*), intent(in) :: suffix logical, intent(in) :: flag_no_literal_optimize logical, intent(inout) :: runs_engine Source Code subroutine runner_do_matching_including ( automaton , text , from , to , prefix , suffix , flag_no_literal_optimize , runs_engine ) use :: forgex_syntax_tree_optimize_m use :: forgex_automaton_m use :: forgex_api_internal_m use :: forgex_cli_api_internal_no_opts_m implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: text integer ( int32 ), intent ( inout ) :: from , to character ( * ), intent ( in ) :: prefix , suffix logical , intent ( in ) :: flag_no_literal_optimize logical , intent ( inout ) :: runs_engine if ( flag_no_literal_optimize ) then call do_matching_including_no_literal_opts ( automaton , text , from , to ) runs_engine = . true . else call do_matching_including ( automaton , text , from , to , prefix , suffix , runs_engine ) end if end subroutine runner_do_matching_including","tags":"","loc":"proc/runner_do_matching_including.html"},{"title":"print_help – Forgex-CLI","text":"public  subroutine print_help() Arguments None Source Code subroutine print_help implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 2 ) character ( CMD_DESC_SIZ ) :: cdesc ( 2 ) header = \"A tool for interacting with Forgex on the command line.\" usage ( 1 ) = \"forgex-cli <command> ...\" cmd ( 1 ) = \"debug\" cdesc ( 1 ) = \"Print the debug representation from Forgex's regex engine.\" cmd ( 2 ) = \"find\" cdesc ( 2 ) = \"Search for a string using one of the regular expression engines.\" call generate_and_output ( header , usage , \"COMMANDS\" , cmd , cdesc ) end subroutine print_help","tags":"","loc":"proc/print_help.html"},{"title":"print_help_debug – Forgex-CLI","text":"public  subroutine print_help_debug() Arguments None Source Code subroutine print_help_debug implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 2 ) character ( CMD_DESC_SIZ ) :: cdesc ( 2 ) header = \"Prints the debug representation provided by Forgex.\" usage ( 1 ) = \"forgex-cli debug <command> ...\" cmd ( 1 ) = \"ast\" cdesc ( 1 ) = \"Print the debug representation of an AST.\" cmd ( 2 ) = \"thompson\" cdesc ( 2 ) = \"Print the debug representation of a Thompson NFA.\" call generate_and_output ( header , usage , \"COMMANDS\" , cmd , cdesc ) end subroutine print_help_debug","tags":"","loc":"proc/print_help_debug.html"},{"title":"print_help_debug_ast – Forgex-CLI","text":"public  subroutine print_help_debug_ast() Arguments None","tags":"","loc":"proc/print_help_debug_ast.html"},{"title":"print_help_debug_thompson – Forgex-CLI","text":"public  subroutine print_help_debug_thompson() Arguments None Source Code subroutine print_help_debug_thompson implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: op ( 3 ) character ( CMD_DESC_SIZ ) :: odesc ( 3 ) header = \"Print the debug representaion of a Thompson NFA.\" usage ( 1 ) = \"forgex-cli debug thompson <pattern>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Suppresses the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_debug_thompson","tags":"","loc":"proc/print_help_debug_thompson.html"},{"title":"print_help_find – Forgex-CLI","text":"public  subroutine print_help_find() Arguments None Source Code subroutine print_help_find implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 1 ) character ( CMD_DESC_SIZ ) :: cdesc ( 1 ) header = \"Executes a search.\" usage ( 1 ) = \"forgex-cli find <command> ...\" cmd ( 1 ) = \"match\" cdesc ( 1 ) = \"Search for full matches.\" call generate_and_output ( header , usage , \"COMMANDS\" , cmd , cdesc ) end subroutine print_help_find","tags":"","loc":"proc/print_help_find.html"},{"title":"print_help_find_match – Forgex-CLI","text":"public  subroutine print_help_find_match() Arguments None Source Code subroutine print_help_find_match implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 3 ) character ( CMD_DESC_SIZ ) :: cdesc ( 3 ) header = \"Executes a search for full matches.\" usage ( 1 ) = \"forgex-cli find match <engine>\" cmd ( 1 ) = \"dense\" cdesc ( 1 ) = \"Search with the fully-compiled DFA regex engine.\" cmd ( 2 ) = \"lazy-dfa\" cdesc ( 2 ) = \"Search with the lazy DFA regex engine.\" cmd ( 3 ) = \"forgex\" cdesc ( 3 ) = \"Search with the top-level API regex engine.\" call generate_and_output ( header , usage , \"ENGINES\" , cmd , cdesc ) end subroutine print_help_find_match","tags":"","loc":"proc/print_help_find_match.html"},{"title":"print_help_find_match_dense_dfa – Forgex-CLI","text":"public  subroutine print_help_find_match_dense_dfa() Arguments None Source Code subroutine print_help_find_match_dense_dfa implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 2 ) character ( CMD_SIZ ) :: op ( 3 ) character ( CMD_DESC_SIZ ) :: odesc ( 3 ) header = \"Execute a search for matches using a fully-compiled DFA regex engine.\" usage ( 1 ) = \"forgex-cli find match dense <pattern> .match. <text>\" usage ( 2 ) = \"forgex-cli find match dense <pattern> .in. <text>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Suppress the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only. \" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_find_match_dense_dfa","tags":"","loc":"proc/print_help_find_match_dense_dfa.html"},{"title":"print_help_find_match_forgex_api – Forgex-CLI","text":"public  subroutine print_help_find_match_forgex_api() Arguments None Source Code subroutine print_help_find_match_forgex_api implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 2 ) character ( CMD_SIZ ) :: op ( 1 ) character ( CMD_DESC_SIZ ) :: odesc ( 1 ) header = \"Executes a search for matches using the top-level API regex engine.\" usage ( 1 ) = \"forgex-cli find match forgex <pattern> .match. <text>\" usage ( 2 ) = \"forgex-cli find match forgex <pattern> .in. <text>\" op ( 1 ) = \"--no-table\" odesc ( 1 ) = \"Suppress the output of the property information table.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_find_match_forgex_api","tags":"","loc":"proc/print_help_find_match_forgex_api.html"},{"title":"print_help_find_match_lazy_dfa – Forgex-CLI","text":"public  subroutine print_help_find_match_lazy_dfa() Arguments None Source Code subroutine print_help_find_match_lazy_dfa implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 2 ) character ( CMD_SIZ ) :: op ( 4 ) character ( CMD_DESC_SIZ ) :: odesc ( 4 ) header = \"Executes a search for matches using a lazy DFA regex engine.\" usage ( 1 ) = \"forgex-cli debug lazy-dfa <pattern> .match. <text>\" usage ( 2 ) = \"forgex-cli debug lazy-dfa <pattern> .in. <text>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Suppress the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only. \" op ( 4 ) = \"--disable-literal-optimize\" odesc ( 4 ) = \"Disable literals search optimization.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_find_match_lazy_dfa","tags":"","loc":"proc/print_help_find_match_lazy_dfa.html"},{"title":"generate_and_output – Forgex-CLI","text":"private  subroutine generate_and_output(header, usage, choice, cmd, cmd_desc, desc) Arguments Type Intent Optional Attributes Name character(len=LINE_SIZ), intent(in) :: header character(len=LINE_SIZ), intent(in) :: usage (:) character(len=*), intent(in) :: choice character(len=CMD_SIZ), intent(in) :: cmd (:) character(len=CMD_DESC_SIZ), intent(in) :: cmd_desc (:) character(len=LINE_SIZ), intent(in), optional :: desc (:) Source Code subroutine generate_and_output ( header , usage , choice , cmd , cmd_desc , desc ) implicit none character ( LINE_SIZ ), intent ( in ) :: header character ( LINE_SIZ ), intent ( in ) :: usage (:) character ( * ), intent ( in ) :: choice character ( CMD_SIZ ), intent ( in ) :: cmd (:) ! command character ( CMD_DESC_SIZ ), intent ( in ) :: cmd_desc (:) ! description character ( LINE_SIZ ), intent ( in ), optional :: desc (:) character ( LINE_SIZ ), allocatable :: buff (:) integer :: num_line , i , offset if ( present ( desc )) then num_line = 3 + size ( desc ) + size ( usage ) + 2 + size ( cmd ) else num_line = 3 + size ( usage ) + 2 + size ( cmd ) end if ! header + blank + DESC + blank+ USAGE + size(usage) + blank + COMMANDS + size(cmd) allocate ( buff ( num_line )) buff (:) = \"\" buff ( 1 ) = header ! buff(2) blank offset = 2 if ( present ( desc )) then do i = 1 , size ( desc ) buff ( i + offset ) = desc ( i ) end do offset = offset + size ( desc ) endif offset = offset + 1 buff ( offset ) = \"USAGE:\" do i = 1 , size ( usage ) buff ( i + offset ) = \"   \" // trim ( usage ( i )) end do offset = offset + size ( usage ) buff ( offset + 2 ) = trim ( choice ) // \":\" offset = offset + 2 do i = 1 , size ( cmd ) buff ( i + offset ) = \"   \" // cmd ( i ) // \" \" // cmd_desc ( i ) enddo do i = 1 , num_line write ( stderr , fmta ) trim ( buff ( i )) end do stop end subroutine generate_and_output","tags":"","loc":"proc/generate_and_output.html"},{"title":"cla__collect_flags – Forgex-CLI","text":"private  subroutine cla__collect_flags(cla) Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla","tags":"","loc":"proc/cla__collect_flags.html"},{"title":"cla__do_debug_subc – Forgex-CLI","text":"private  subroutine cla__do_debug_subc(cla) Uses forgex_cli_debug_m Processes the debug command, reads a subcommand, and calls the corresponding procedure. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__do_debug_subc ( cla ) use :: forgex_cli_debug_m implicit none class ( cla_t ), intent ( inout ) :: cla integer :: pattern_offset pattern_offset = 3 call cla % init_debug () call cla % read_subc () if ( cla % sub_cmd % get_name () == '' ) then call print_help_debug end if call cla % get_patterns ( pattern_offset ) ! Handle errors when a pattern does not exist. if (. not . allocated ( cla % patterns )) then select case ( cla % sub_cmd % get_name ()) case ( SUBC_AST ) call print_help_debug_ast case ( SUBC_THOMPSON ) call print_help_debug_thompson case default call print_help_debug end select end if if ( size ( cla % patterns ) > 1 ) then write ( stderr , '(a, i0, a)' ) \"Only single pattern is expected, but \" , size ( cla % patterns ), \" were given.\" stop end if select case ( cla % sub_cmd % get_name ()) case ( SUBC_AST ) call do_debug_ast ( cla % flags , cla % patterns ( 1 )% p ) case ( SUBC_THOMPSON ) call do_debug_thompson ( cla % flags , cla % patterns ( 1 )% p ) end select end subroutine cla__do_debug_subc","tags":"","loc":"proc/cla__do_debug_subc.html"},{"title":"cla__do_find_subc – Forgex-CLI","text":"private  subroutine cla__do_find_subc(cla) Uses forgex_cli_find_m Processes the debug command, reads a subcommand and a sub-subcommand,\nand calls the corresponding procedure. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__do_find_subc ( cla ) use :: forgex_cli_find_m implicit none class ( cla_t ), intent ( inout ) :: cla logical :: is_exactly integer :: pattern_offset character (:), allocatable :: text pattern_offset = 4 call cla % init_find () call cla % read_subc () if ( cla % sub_cmd % get_name () == '' ) then call print_help_find else if ( cla % sub_cmd % get_name () == SUBC_MATCH ) then call cla % init_find_match () endif call cla % read_subsubc () if ( cla % sub_sub_cmd % get_name () == '' ) then select case ( cla % sub_cmd % get_name ()) case ( SUBC_MATCH ) call print_help_find_match end select end if call cla % get_patterns ( pattern_offset ) if (. not . allocated ( cla % patterns )) then select case ( cla % sub_sub_cmd % get_name ()) case ( ENGINE_LAZY_DFA ) call print_help_find_match_lazy_dfa case ( ENGINE_DENSE_DFA ) call print_help_find_match_dense_dfa case ( ENGINE_FORGEX_API ) call print_help_find_match_forgex_api end select end if if ( cla % sub_sub_cmd % get_name () == ENGINE_LAZY_DFA & . or . cla % sub_sub_cmd % get_name () == ENGINE_DENSE_DFA & . or . cla % sub_sub_cmd % get_name () == ENGINE_FORGEX_API ) then if ( size ( cla % patterns ) /= 3 . and . size ( cla % patterns ) /= 2 ) then write ( stderr , \"(a, i0, a)\" ) \"Three arguments are expected, but \" , size ( cla % patterns ), \" were given.\" stop else if ( cla % patterns ( 2 )% p /= OP_MATCH . and . cla % patterns ( 2 )% p /= OP_IN ) then write ( stderr , \"(a)\" ) \"Operator \" // OP_MATCH // \" or \" // OP_IN // \" are expected, but \" // cla % patterns ( 2 )% p // \" was given.\" stop end if if ( cla % patterns ( 2 )% p == OP_MATCH ) then is_exactly = . true . else if ( cla % patterns ( 2 )% p == OP_IN ) then is_exactly = . false . else write ( stderr , '(a)' ) \"Unknown operator: \" // cla % patterns ( 2 )% p end if else call print_help_find_match end if if ( size ( cla % patterns ) == 2 ) then text = '' else text = cla % patterns ( 3 )% p end if select case ( cla % sub_sub_cmd % get_name ()) case ( ENGINE_LAZY_DFA ) call do_find_match_lazy_dfa ( cla % flags , cla % patterns ( 1 )% p , text , is_exactly ) case ( ENGINE_DENSE_DFA ) call do_find_match_dense_dfa ( cla % flags , cla % patterns ( 1 )% p , text , is_exactly ) case ( ENGINE_FORGEX_API ) call do_find_match_forgex ( cla % flags , cla % patterns ( 1 )% p , text , is_exactly ) case default call print_help_find_match end select end subroutine cla__do_find_subc","tags":"","loc":"proc/cla__do_find_subc.html"},{"title":"cla__get_patterns – Forgex-CLI","text":"private  subroutine cla__get_patterns(cla, offset) Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla integer, intent(in) :: offset Source Code subroutine cla__get_patterns ( cla , offset ) implicit none class ( cla_t ), intent ( inout ) :: cla integer , intent ( in ) :: offset integer :: i , j , k integer , allocatable :: idx (:) j = 0 outer : do i = offset , cla % arg_info % argc ! if ( i <= maxval ( cla % flag_idx )) then do k = 1 , ubound ( cla % flags , dim = 1 ) if ( i == cla % flag_idx ( k )) cycle outer end do end if j = j + 1 if (. not . allocated ( idx )) then idx = [ i ] cycle end if idx = [ idx , i ] end do outer if ( j == 0 ) return allocate ( cla % patterns ( j )) do i = 1 , j cla % patterns ( i )% p = cla % arg_info % arg ( idx ( i ))% v end do end subroutine cla__get_patterns","tags":"","loc":"proc/cla__get_patterns.html"},{"title":"cla__init_debug_subc – Forgex-CLI","text":"private  subroutine cla__init_debug_subc(cla) Prepare subcommands for the debug command. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla","tags":"","loc":"proc/cla__init_debug_subc.html"},{"title":"cla__init_find_match_subsubc – Forgex-CLI","text":"private  subroutine cla__init_find_match_subsubc(cla) Prepare sub-subcommands for the match subcommand. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__init_find_match_subsubc ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla allocate ( cla % sub_cmd % subc ( NUM_SUBSUBC_MATCH )) cla % sub_cmd % subc ( 1 ) = ENGINE_LAZY_DFA cla % sub_cmd % subc ( 2 ) = ENGINE_DENSE_DFA cla % sub_cmd % subc ( 3 ) = ENGINE_FORGEX_API end subroutine cla__init_find_match_subsubc","tags":"","loc":"proc/cla__init_find_match_subsubc.html"},{"title":"cla__init_find_subc – Forgex-CLI","text":"private  subroutine cla__init_find_subc(cla) Prepare subcommands for the find command. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__init_find_subc ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla allocate ( cla % cmd % subc ( NUM_SUBC_FIND )) cla % cmd % subc ( 1 ) = SUBC_MATCH end subroutine cla__init_find_subc","tags":"","loc":"proc/cla__init_find_subc.html"},{"title":"cla__initialize – Forgex-CLI","text":"private  subroutine cla__initialize(cla) Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__initialize ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla call get_arg_command_line ( cla % arg_info % argc , cla % arg_info % arg , cla % arg_info % entire ) cla % flags = . false . cla % flag_idx = - 1 call init_flags call init_commands end subroutine cla__initialize","tags":"","loc":"proc/cla__initialize.html"},{"title":"cla__read_command – Forgex-CLI","text":"private  subroutine cla__read_command(cla) Read the first argument and match it with registered commands. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__read_command ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla character (:), allocatable :: cmd if ( ubound ( cla % arg_info % arg , dim = 1 ) < 1 ) then cmd = \"\" return end if cmd = trim ( cla % arg_info % arg ( 1 )% v ) if ( cmd . in . all_cmds ) then call cla % cmd % set_name ( cmd ) else call cla % cmd % set_name ( \"\" ) end if end subroutine cla__read_command","tags":"","loc":"proc/cla__read_command.html"},{"title":"cla__read_sub_subcommand – Forgex-CLI","text":"private  subroutine cla__read_sub_subcommand(cla) Read the third argument and match it with registered sub-subcommands. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__read_sub_subcommand ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla character (:), allocatable :: cmd integer :: i if ( cla % arg_info % argc < 3 ) return cmd = trim ( cla % arg_info % arg ( 3 )% v ) do i = 1 , size ( cla % sub_cmd % subc ) if ( cmd == cla % sub_cmd % subc ( i )) then call cla % sub_sub_cmd % set_name ( cmd ) return end if end do end subroutine cla__read_sub_subcommand","tags":"","loc":"proc/cla__read_sub_subcommand.html"},{"title":"cla__read_subcommand – Forgex-CLI","text":"private  subroutine cla__read_subcommand(cla) Read the second argument and match it with registered subcommands. Type Bound cla_t Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla Source Code subroutine cla__read_subcommand ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla character (:), allocatable :: cmd integer :: i cmd = trim ( cla % arg_info % arg ( 2 )% v ) do i = 1 , size ( cla % cmd % subc ) if ( cmd == cla % cmd % subc ( i )) then call cla % sub_cmd % set_name ( cmd ) return end if end do end subroutine cla__read_subcommand","tags":"","loc":"proc/cla__read_subcommand.html"},{"title":"init_commands – Forgex-CLI","text":"private  subroutine init_commands() Arguments None Source Code subroutine init_commands () implicit none call register_cmd ( all_cmds ( 1 ), CMD_DEBUG ) call register_cmd ( all_cmds ( 2 ), CMD_FIND ) end subroutine init_commands","tags":"","loc":"proc/init_commands.html"},{"title":"init_flags – Forgex-CLI","text":"private  subroutine init_flags() Uses forgex_enums_m This subroutine registers all the flags forgex-cli accepts for the flag_t type array all_flags . Arguments None Source Code subroutine init_flags () use :: forgex_enums_m implicit none call register_flag ( all_flags ( FLAG_HELP ), 'help' , '--help' , '-h' ) call register_flag ( all_flags ( FLAG_VERBOSE ), 'verbose' , '--verbose' , '-v' ) call register_flag ( all_flags ( FLAG_NO_TABLE ), 'no-table' , '--no-table' ) call register_flag ( all_flags ( FLAG_TABLE_ONLY ), 'table-only' , '--table-only' ) call register_flag ( all_flags ( FLAG_NO_LITERAL ), 'no-literal-optimize' , '--disable-literal-optimize' ) end subroutine init_flags","tags":"","loc":"proc/init_flags.html"},{"title":"do_matching_exactly_no_literal_opts – Forgex-CLI","text":"public  subroutine do_matching_exactly_no_literal_opts(automaton, string, res) This subroutine is intended to be called from the forgex_cli_find_m module. Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: string logical, intent(inout) :: res Source Code subroutine do_matching_exactly_no_literal_opts ( automaton , string , res ) implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: string logical , intent ( inout ) :: res integer :: cur_i , dst_i ! current and destination index of DFA nodes integer :: ci ! character index integer :: next_ci ! next character index integer :: max_match ! character (:), allocatable :: str ! Initialize `cur_i` with automaton's initial index. cur_i = automaton % initial_index ! If the DFA have not been initialized, abort the program. if ( cur_i == DFA_NOT_INIT ) then error stop \"DFA have not been initialized.\" end if ! If the input string is an empty string, returns a logical value ! indicating whether the current state is accepting or not. if ( len ( string ) == 0 ) then res = automaton % dfa % nodes ( cur_i )% accepted return end if ! Initialize counter variables. max_match = 0 ci = 1 str = char ( 0 ) // string // char ( 0 ) ! Loop and proceed with matching unless the current index is DFA_INVALID_INDEX. do while ( cur_i /= DFA_INVALID_INDEX ) ! If the current state acceptable, the value of `max_match` is updated with `i`. if ( automaton % dfa % nodes ( cur_i )% accepted ) then max_match = ci end if if ( ci > len ( str )) exit ! Get the index of the next character and assign it to `next_ci`. next_ci = idxutf8 ( str , ci ) + 1 ! Lazy evaluation is performed by calling this procedure here. ! The index of destination DFA node is stored in the `dst_i` variable. call automaton % construct ( cur_i , dst_i , str ( ci : next_ci - 1 )) ! If there is mismatch in the first byte of the NULL character, try again with the second byte. if ( dst_i == DFA_INVALID_INDEX . and . ci == 1 ) then ci = 2 next_ci = idxutf8 ( str , ci ) + 1 call automaton % construct ( cur_i , dst_i , str ( ci : next_ci - 1 )) end if ! update counters cur_i = dst_i ci = next_ci end do ! If the maximum index of the match is one larger than length of the string, ! this function returns true, otherwise it returns false. if ( max_match >= len ( string ) + 2 ) then res = . true . else res = . false . end if end subroutine do_matching_exactly_no_literal_opts","tags":"","loc":"proc/do_matching_exactly_no_literal_opts.html"},{"title":"do_matching_including_no_literal_opts – Forgex-CLI","text":"public  subroutine do_matching_including_no_literal_opts(automaton, string, from, to) Uses forgex_utility_m This procedure reads a text, performs regular expression matching using an automaton,\nand stores the string index in the argument if it contains a match. Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: string integer, intent(inout) :: from integer, intent(inout) :: to Source Code subroutine do_matching_including_no_literal_opts ( automaton , string , from , to ) use :: forgex_utility_m implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: string integer , intent ( inout ) :: from , to integer :: cur_i , dst_i ! current and destination index of DFA nodes integer :: ci ! character index integer :: next_ci ! next character index integer :: max_match ! maximum value of match attempts integer :: start ! starting character index integer :: i character (:), allocatable :: str str = string from = 0 to = 0 str = char ( 0 ) // string // char ( 0 ) cur_i = automaton % initial_index if ( cur_i == DFA_NOT_INIT ) then error stop \"DFA have not been initialized.\" end if if ( len ( string ) <= 1 . and . string == '' ) then if ( automaton % dfa % nodes ( cur_i )% accepted ) then from = ACCEPTED_EMPTY to = ACCEPTED_EMPTY end if return end if loop_init : block i = 1 start = i end block loop_init do while ( start < len ( str )) max_match = 0 ci = start cur_i = automaton % initial_index ! Traverse the DFA with the input string from the current starting position of ``cur_i`. do while ( cur_i /= DFA_INVALID_INDEX ) if ( automaton % dfa % nodes ( cur_i )% accepted . and . ci /= start ) then max_match = ci end if if ( ci > len ( str )) exit next_ci = idxutf8 ( str , ci ) + 1 call automaton % construct ( cur_i , dst_i , str ( ci : next_ci - 1 )) cur_i = dst_i ci = next_ci end do ! Update match position if a match is found. if ( max_match > 0 ) then from = start - 1 if ( from == 0 ) from = 1 ! handle leading NULL character. if ( max_match >= len ( str )) then to = len ( string ) else to = max_match - 2 end if return end if start = idxutf8 ( str , start ) + 1 ! Bruteforce searching end do end subroutine do_matching_including_no_literal_opts","tags":"","loc":"proc/do_matching_including_no_literal_opts.html"},{"title":"get_flag_index – Forgex-CLI","text":"public  function get_flag_index(arg, flags) result(res) Arguments Type Intent Optional Attributes Name type( arg_element_t ), intent(in) :: arg type( flag_t ), intent(in) :: flags (:) Return Value integer Source Code function get_flag_index ( arg , flags ) result ( res ) implicit none type ( arg_element_t ), intent ( in ) :: arg type ( flag_t ), intent ( in ) :: flags (:) integer :: res integer :: i res = - 1 do i = 1 , NUM_FLAGS if ( arg % v == flags ( i )% long_f . or . arg % v == flags ( i )% short_f ) then res = i return end if end do end function get_flag_index","tags":"","loc":"proc/get_flag_index.html"},{"title":"get_os_type – Forgex-CLI","text":"public  function get_os_type() result(res) Uses forgex forgex_enums_m Todo Arguments None Return Value integer Source Code function get_os_type () result ( res ) use :: forgex , only : operator (. in .) use :: forgex_enums_m implicit none integer :: res integer , save :: res_save logical , save :: is_first = . true . character ( LEN_ENV_VAR ) :: val1 , val2 integer :: len1 , len2 , stat1 , stat2 if (. not . is_first ) then res = res_save return end if res = OS_UNKNOWN call get_environment_variable ( name = 'OS' , value = val1 , length = len1 , status = stat1 ) if ( stat1 == 0 . and . len1 > 0 ) then if ( \"Windows_NT\" . in . val1 ) then res_save = OS_WINDOWS res = res_save is_first = . false . return end if end if call get_environment_variable ( name = 'OSTYPE' , value = val2 , length = len2 , status = stat2 ) if ( stat2 == 0 . and . len2 > 0 ) then !! @todo end if end function get_os_type","tags":"","loc":"proc/get_os_type.html"},{"title":"text_highlight_green – Forgex-CLI","text":"public  function text_highlight_green(string, from, to) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer(kind=int32), intent(in) :: from integer(kind=int32), intent(in) :: to Return Value character(len=:), allocatable Source Code function text_highlight_green ( string , from , to ) result ( res ) implicit none character ( * ), intent ( in ) :: string integer ( int32 ), intent ( in ) :: from , to character (:), allocatable :: res character ( 5 ) :: green = char ( 27 ) // \"[32m\" character ( 5 ) :: hend = char ( 27 ) // \"[39m\" character ( 4 ) :: bold = char ( 27 ) // \"[1m\" character ( 4 ) :: bend = char ( 27 ) // \"[0m\" res = '' if ( from > 0 . and . to > 0 . and . from <= to . and . len ( string ) > 0 ) then res = string ( 1 : from - 1 ) // green // bold // string ( from : to ) // bend // hend // string ( to + 1 : len ( string )) else res = string end if end function text_highlight_green","tags":"","loc":"proc/text_highlight_green.html"},{"title":"does_command_exist – Forgex-CLI","text":"private pure function does_command_exist(arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg character(len=LEN_CMD), intent(in) :: cmd_list (:) Return Value logical Source Code pure function does_command_exist ( arg , cmd_list ) result ( res ) implicit none character ( * ), intent ( in ) :: arg character ( LEN_CMD ), intent ( in ) :: cmd_list (:) logical :: res integer :: i res = . false . do i = lbound ( cmd_list , dim = 1 ), ubound ( cmd_list , dim = 1 ) res = res . or . trim ( arg ) == trim ( cmd_list ( i )) if ( res ) return end do end function does_command_exist","tags":"","loc":"proc/does_command_exist.html"},{"title":"does_command_exist_type_cmd – Forgex-CLI","text":"private pure function does_command_exist_type_cmd(arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( cmd_t ), intent(in) :: cmd_list (:) Return Value logical Source Code pure function does_command_exist_type_cmd ( arg , cmd_list ) result ( res ) implicit none character ( * ), intent ( in ) :: arg type ( cmd_t ), intent ( in ) :: cmd_list (:) logical :: res integer :: i res = . false . do i = lbound ( cmd_list , dim = 1 ), ubound ( cmd_list , dim = 1 ) res = res . or . trim ( arg ) == trim ( cmd_list ( i )% get_name ()) if ( res ) return end do end function does_command_exist_type_cmd","tags":"","loc":"proc/does_command_exist_type_cmd.html"},{"title":"does_flag_exist – Forgex-CLI","text":"private pure function does_flag_exist(arg, flag_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( flag_t ), intent(in) :: flag_list (:) Return Value logical Source Code pure function does_flag_exist ( arg , flag_list ) result ( res ) implicit none character ( * ), intent ( in ) :: arg type ( flag_t ), intent ( in ) :: flag_list (:) logical :: res integer :: i res = . false . do i = lbound ( flag_list , dim = 1 ), ubound ( flag_list , dim = 1 ) res = res & . or . trim ( arg ) == trim ( flag_list ( i )% short_f ) & . or . trim ( arg ) == trim ( flag_list ( i )% long_f ) if ( res ) return end do end function does_flag_exist","tags":"","loc":"proc/does_flag_exist.html"},{"title":"is_arg_contained_in_flags – Forgex-CLI","text":"private  function is_arg_contained_in_flags(arg, flags) result(res) Arguments Type Intent Optional Attributes Name type( arg_element_t ), intent(in) :: arg type( flag_t ), intent(in) :: flags (:) Return Value logical Source Code function is_arg_contained_in_flags ( arg , flags ) result ( res ) implicit none type ( arg_element_t ), intent ( in ) :: arg type ( flag_t ), intent ( in ) :: flags (:) logical :: res integer :: i res = . false . do i = 1 , ubound ( flags , dim = 1 ) res = res & . or . flags ( i )% long_f == arg % v & . or . flags ( i )% short_f == arg % v if ( res ) return end do end function is_arg_contained_in_flags","tags":"","loc":"proc/is_arg_contained_in_flags.html"},{"title":"get_arg_command_line – Forgex-CLI","text":"public  subroutine get_arg_command_line(argc, arg, entire) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: argc type( arg_element_t ), intent(inout), allocatable :: arg (:) character(len=:), intent(inout), allocatable :: entire Source Code subroutine get_arg_command_line ( argc , arg , entire ) implicit none integer ( int32 ), intent ( inout ) :: argc ! argc type ( arg_element_t ), allocatable , intent ( inout ) :: arg (:) character (:), allocatable , intent ( inout ) :: entire integer :: i , len_ith , entire_len argc = command_argument_count () call get_command ( length = entire_len ) allocate ( character ( entire_len ) :: entire ) call get_command ( command = entire ) allocate ( arg ( 0 : argc )) do i = 0 , argc ! Get length of i-th command line argmuemnt. call get_command_argument ( number = i , length = len_ith ) ! Allocate str(i)%v of the same length as the i-th argument. allocate ( character ( len_ith ) :: arg ( i )% v ) ! Get the value of the i-th argument as a string. call get_command_argument ( number = i , value = arg ( i )% v ) end do end subroutine get_arg_command_line","tags":"","loc":"proc/get_arg_command_line.html"},{"title":"info – Forgex-CLI","text":"public  subroutine info(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Source Code subroutine info ( str ) implicit none character ( * ), intent ( in ) :: str write ( stderr , '(a)' ) \"[info]: \" // str end subroutine info","tags":"","loc":"proc/info.html"},{"title":"register_cmd – Forgex-CLI","text":"public  subroutine register_cmd(cmd, name) Arguments Type Intent Optional Attributes Name type( cmd_t ), intent(inout) :: cmd character(len=*), intent(in) :: name Source Code subroutine register_cmd ( cmd , name ) implicit none type ( cmd_t ), intent ( inout ) :: cmd character ( * ), intent ( in ) :: name call cmd % set_name ( name ) end subroutine register_cmd","tags":"","loc":"proc/register_cmd.html"},{"title":"register_flag – Forgex-CLI","text":"public  subroutine register_flag(flag, name, long, short) Arguments Type Intent Optional Attributes Name type( flag_t ), intent(inout) :: flag character(len=*), intent(in) :: name character(len=*), intent(in) :: long character(len=*), intent(in), optional :: short","tags":"","loc":"proc/register_flag.html"},{"title":"right_justify – Forgex-CLI","text":"public  subroutine right_justify(array) Uses forgex_cli_parameters_m Arguments Type Intent Optional Attributes Name character(len=NUM_DIGIT_KEY), intent(inout) :: array (:)","tags":"","loc":"proc/right_justify.html"},{"title":"operator(.in.) – Forgex-CLI","text":"public interface operator(.in.) Module Procedures private pure function does_flag_exist (arg, flag_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( flag_t ), intent(in) :: flag_list (:) Return Value logical private pure function does_command_exist (arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg character(len=LEN_CMD), intent(in) :: cmd_list (:) Return Value logical private pure function does_command_exist_type_cmd (arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( cmd_t ), intent(in) :: cmd_list (:) Return Value logical private  function is_arg_contained_in_flags (arg, flags) result(res) Arguments Type Intent Optional Attributes Name type( arg_element_t ), intent(in) :: arg type( flag_t ), intent(in) :: flags (:) Return Value logical","tags":"","loc":"interface/operator(.in.).html"},{"title":"mem_dfa_graph – Forgex-CLI","text":"public  function mem_dfa_graph(graph) result(res) Uses forgex_lazy_dfa_graph_m Arguments Type Intent Optional Attributes Name type(dfa_graph_t), intent(in) :: graph Return Value integer Source Code function mem_dfa_graph ( graph ) result ( res ) use :: forgex_lazy_dfa_graph_m implicit none type ( dfa_graph_t ), intent ( in ) :: graph integer :: res , sum_node , sum_tra , i , j res = 16 ! 4 int32 sum_node = 0 do i = 1 , graph % dfa_top - 1 sum_node = sum_node + 6 * 4 ! 3 int32, 3 logical if ( allocated ( graph % nodes ( i )% nfa_set % vec )) then sum_node = sum_node + size ( graph % nodes ( i )% nfa_set % vec ) * 4 ! logical vector end if sum_tra = 0 inner : do j = 1 , graph % nodes ( i )% get_tra_top () sum_tra = sum_tra + 8 + 4 * 2 ! segment + 2 int32 if (. not . allocated ( graph % nodes ( i )% transition )) cycle inner if ( allocated ( graph % nodes ( i )% transition ( j )% nfa_set % vec )) then sum_tra = sum_tra + size ( graph % nodes ( i )% transition ( j )% nfa_set % vec ) * 4 end if end do inner sum_node = sum_node + sum_tra end do res = res + sum_node res = res + ( ubound ( graph % nodes , dim = 1 ) - graph % dfa_top ) * 6 * 4 ! 3 int32, 3 logical end function mem_dfa_graph","tags":"","loc":"proc/mem_dfa_graph.html"},{"title":"mem_nfa_graph – Forgex-CLI","text":"public  function mem_nfa_graph(graph) result(res) Uses forgex_nfa_graph_m Arguments Type Intent Optional Attributes Name type(nfa_graph_t), intent(in) :: graph Return Value integer Source Code function mem_nfa_graph ( graph ) result ( res ) use :: forgex_nfa_graph_m implicit none type ( nfa_graph_t ), intent ( in ) :: graph integer :: res , sum_node , sum_tra , i , j res = 12 ! 3 int32 sum_node = 0 do i = NFA_STATE_BASE , graph % nfa_top sum_node = sum_node + 5 * 4 ! 5 int32 sum_tra = 0 if (. not . allocated ( graph % nodes ( i )% forward )) cycle b : do j = lbound ( graph % nodes ( i )% forward , dim = 1 ), ubound ( graph % nodes ( i )% forward , dim = 1 ) if (. not . allocated ( graph % nodes ( i )% forward )) cycle b sum_tra = sum_tra + 4 * 4 ! 3 int32, 1 logical if ( allocated ( graph % nodes ( i )% forward ( j )% c )) then sum_tra = sum_tra + 8 * size ( graph % nodes ( i )% forward ( j )% c ) end if end do b sum_node = sum_node + sum_tra * 2 ! forward and backward end do res = res + sum_node res = res + ( ubound ( graph % nodes , dim = 1 ) - graph % nfa_top ) * 5 ! 5 int32 end function mem_nfa_graph","tags":"","loc":"proc/mem_nfa_graph.html"},{"title":"mem_tape – Forgex-CLI","text":"public  function mem_tape(tape) result(res) Uses forgex_syntax_tree_node_m Arguments Type Intent Optional Attributes Name type(tape_t), intent(in) :: tape Return Value integer Source Code function mem_tape ( tape ) result ( res ) use :: forgex_syntax_tree_node_m implicit none type ( tape_t ), intent ( in ) :: tape integer :: res res = len ( tape % str ) res = res + 12 end function mem_tape","tags":"","loc":"proc/mem_tape.html"},{"title":"mem_tree – Forgex-CLI","text":"public  function mem_tree(tree) result(res) Uses forgex_syntax_tree_node_m Arguments Type Intent Optional Attributes Name type(tree_node_t), intent(in) :: tree (:) Return Value integer Source Code function mem_tree ( tree ) result ( res ) use :: forgex_syntax_tree_node_m implicit none type ( tree_node_t ), intent ( in ) :: tree (:) integer :: res , sum_c , i res = size ( tree , dim = 1 ) * 6 * 4 ! 5 int32, 1 logical sum_c = 0 do i = lbound ( tree , dim = 1 ), ubound ( tree , dim = 1 ) if ( allocated ( tree ( i )% c )) then sum_c = sum_c + size ( tree ( i )% c ) * 8 ! 8bytes per segment end if end do res = res + sum_c end function mem_tree","tags":"","loc":"proc/mem_tree.html"},{"title":"do_debug_ast – Forgex-CLI","text":"public  subroutine do_debug_ast(flags, pattern) Uses forgex_cli_memory_calculation_m forgex_syntax_tree_optimize_m forgex_syntax_tree_graph_m Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern Source Code subroutine do_debug_ast ( flags , pattern ) use :: forgex_syntax_tree_graph_m use :: forgex_syntax_tree_optimize_m use :: forgex_cli_memory_calculation_m implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern type ( tree_t ) :: tree integer :: root integer :: uni , ierr , siz character (:), allocatable :: buff character (:), allocatable :: ast , prefix , suffix , entire !, middle real ( real64 ) :: lap1 , lap2 if ( flags ( FLAG_HELP )) call print_help_debug_ast call time_begin call tree % build ( trim ( pattern )) lap1 = time_lap () entire = get_entire_literal ( tree ) prefix = get_prefix_literal ( tree ) ! middle = get_middle_literal(tree) suffix = get_suffix_literal ( tree ) lap2 = time_lap () open ( newunit = uni , status = 'scratch' ) call tree % print ( uni ) inquire ( unit = uni , size = siz ) allocate ( character ( siz + 2 ) :: buff ) rewind ( uni ) read ( uni , fmta , iostat = ierr ) buff close ( uni ) ast = trim ( buff ) output : block character ( NUM_DIGIT_KEY ) :: parse_time , literal_time , tree_count , tree_allocated , & memory , literal_pre , literal_post , literal_all , literal_mid character ( NUM_DIGIT_KEY ) :: cbuff ( 9 ) integer :: i parse_time = \"parse time:\" literal_time = \"extract time:\" tree_count = \"tree node count:\" tree_allocated = \"tree node allocated:\" literal_all = \"extracted literal:\" literal_pre = \"extracted prefix:\" literal_mid = \"extracted middle:\" literal_post = \"extracted suffix:\" memory = \"memory (estimated):\" if ( flags ( FLAG_VERBOSE )) then cbuff = [ parse_time , literal_time , literal_all , literal_pre , literal_mid , literal_post , & memory , tree_count , tree_allocated ] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_char ) trim ( cbuff ( 3 )), entire write ( stdout , fmt_out_char ) trim ( cbuff ( 4 )), prefix ! write(stdout, fmt_out_char) trim(cbuff(5)), middle write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), suffix write ( stdout , fmt_out_int ) trim ( cbuff ( 7 )), mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) write ( stdout , fmt_out_int ) trim ( cbuff ( 8 )), root write ( stdout , fmt_out_int ) trim ( cbuff ( 9 )), size ( tree % nodes , dim = 1 ) else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff = [ parse_time , literal_time , literal_all , literal_pre , literal_mid , & literal_post , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 2 )] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_char ) trim ( cbuff ( 3 )), entire write ( stdout , fmt_out_char ) trim ( cbuff ( 4 )), prefix ! write(stdout, fmt_out_char) trim(cbuff(5)), middle write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), suffix write ( stdout , fmt_out_int ) trim ( cbuff ( 7 )), mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) end if end block output if ( flags ( FLAG_TABLE_ONLY )) return write ( stdout , fmta ) ast end subroutine do_debug_ast","tags":"","loc":"proc/do_debug_ast.html"},{"title":"do_debug_thompson – Forgex-CLI","text":"public  subroutine do_debug_thompson(flags, pattern) Uses forgex_cli_memory_calculation_m forgex_automaton_m forgex_syntax_tree_graph_m Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern Source Code subroutine do_debug_thompson ( flags , pattern ) use :: forgex_cli_memory_calculation_m use :: forgex_automaton_m use :: forgex_syntax_tree_graph_m implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern type ( tree_t ) :: tree type ( automaton_t ) :: automaton integer :: root integer :: uni , ierr , i character (:), allocatable :: nfa character ( 256 ) :: line real ( real64 ) :: lap1 , lap2 nfa = '' if ( flags ( FLAG_HELP )) call print_help_debug_thompson if ( pattern == '' ) call print_help_debug_thompson call time_begin () ! call build_syntax_tree(trim(pattern), tree%tape, tree, root) call tree % build ( trim ( pattern )) lap1 = time_lap () call automaton % nfa % build ( tree , automaton % nfa_entry , automaton % nfa_exit , automaton % all_segments ) lap2 = time_lap () open ( newunit = uni , status = 'scratch' ) call automaton % nfa % print ( uni , automaton % nfa_exit ) rewind ( uni ) ierr = 0 do while ( ierr == 0 ) read ( uni , fmta , iostat = ierr ) line if ( ierr /= 0 ) exit if ( get_os_type () == OS_WINDOWS ) then nfa = nfa // trim ( line ) // CRLF else nfa = nfa // trim ( line ) // LF end if end do close ( uni ) output : block character ( NUM_DIGIT_KEY ) :: parse_time , nfa_time , memory , nfa_count , nfa_allocated , tree_count , tree_allocated character ( NUM_DIGIT_KEY ) :: cbuff ( 7 ) = '' integer :: memsiz parse_time = \"parse time:\" nfa_time = \"compile nfa time:\" memory = \"memory (estimated):\" nfa_count = \"nfa states:\" nfa_allocated = \"nfa states allocated:\" tree_count = \"tree node count:\" tree_allocated = \"tree node allocated:\" memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) & + mem_nfa_graph ( automaton % nfa ) + 4 * 3 if ( allocated ( automaton % entry_set % vec )) then memsiz = memsiz + size ( automaton % entry_set % vec , dim = 1 ) end if if ( allocated ( automaton % all_segments )) then memsiz = memsiz + size ( automaton % all_segments , dim = 1 ) * 8 end if if ( flags ( FLAG_VERBOSE )) then cbuff = [ parse_time , nfa_time , memory , tree_count , tree_allocated , nfa_count , nfa_allocated ] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_int ) trim ( cbuff ( 3 )), memsiz write ( stdout , fmt_out_int ) trim ( cbuff ( 4 )), root write ( stdout , fmt_out_int ) trim ( cbuff ( 5 )), size ( tree % nodes , dim = 1 ) write ( stdout , fmt_out_int ) trim ( cbuff ( 6 )), automaton % nfa % nfa_top write ( stdout , fmt_out_int ) trim ( cbuff ( 7 )), automaton % nfa % nfa_limit else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff (:) = [ parse_time , nfa_time , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 4 )] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_int ) trim ( cbuff ( 3 )), memsiz end if if ( flags ( FLAG_TABLE_ONLY )) return write ( stdout , * ) \"\" write ( stdout , fmta ) HEADER_NFA write ( stdout , fmta ) trim ( nfa ) write ( stdout , fmta ) \"Note: all segments of NFA were disjoined with overlapping portions.\" write ( stdout , fmta ) FOOTER end block output end subroutine do_debug_thompson","tags":"","loc":"proc/do_debug_thompson.html"},{"title":"cmd__get_name – Forgex-CLI","text":"private pure function cmd__get_name(self) result(res) Type Bound cmd_t Arguments Type Intent Optional Attributes Name class( cmd_t ), intent(in) :: self Return Value character(len=:), allocatable Source Code pure function cmd__get_name ( self ) result ( res ) implicit none class ( cmd_t ), intent ( in ) :: self character (:), allocatable :: res res = trim ( self % name ) end function cmd__get_name","tags":"","loc":"proc/cmd__get_name.html"},{"title":"cmd__set_name – Forgex-CLI","text":"private pure subroutine cmd__set_name(self, name) Type Bound cmd_t Arguments Type Intent Optional Attributes Name class( cmd_t ), intent(inout) :: self character(len=*), intent(in) :: name Source Code pure subroutine cmd__set_name ( self , name ) implicit none class ( cmd_t ), intent ( inout ) :: self character ( * ), intent ( in ) :: name self % name = name end subroutine cmd__set_name","tags":"","loc":"proc/cmd__set_name.html"},{"title":"forgex_cli_time_measurement_m – Forgex-CLI","text":"This module provides procedures to measure the time it takes to execute.\ncf. https://qiita.com/implicit_none/items/86c9117990798c1e8b3b Uses forgex_cli_parameters_m iso_c_binding iso_fortran_env forgex_cli_utils_m forgex_enums_m Variables Type Visibility Attributes Name Initial real(kind=real64), private :: begin_s real(kind=real64), private :: end_s integer(kind=c_long_long), private :: frequency logical(kind=c_bool), private :: is_succeeded = .false. logical(kind=c_bool), private :: is_supported = .false. real(kind=real64), private :: last_s integer(kind=c_long_long), private :: time_begin_qhc integer(kind=c_long_long), private :: time_end_qhc Interfaces interface For Windows, use high-resolution system call for timing. private  function QueryPerformanceCounter(PerformanceCount_count) result(is_succeeded_c) bind(c, name=\"QueryPerformanceCounter\") Arguments Type Intent Optional Attributes Name integer(kind=c_long_long), intent(out) :: PerformanceCount_count Return Value logical(kind=c_bool) interface For Windows, use high-resolution system call for timing. private  function QueryPerformanceFrequency(Frequency_countPerSec) result(is_supported_c) bind(c, name=\"QueryPerformanceFrequency\") Arguments Type Intent Optional Attributes Name integer(kind=c_long_long), intent(out) :: Frequency_countPerSec Return Value logical(kind=c_bool) Functions public  function get_lap_time_in_appropriate_unit (lap_time) result(res) This function takes a real number of seconds, converts it to the appropriate\nunits, and returns a string with the unit for output. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: lap_time Return Value character(len=NUM_DIGIT_TIME) public  function time_lap () result(res) This function is for timing purposes and returns the lap time\nsince the last call of time_begin or time_lap . Arguments None Return Value real(kind=real64) Subroutines public  subroutine time_begin () This subroutine is for timing purpose and starts a stopwatch. Arguments None","tags":"","loc":"module/forgex_cli_time_measurement_m.html"},{"title":"forgex_cli_find_m – Forgex-CLI","text":"Uses forgex_cli_help_messages_m forgex_cli_parameters_m iso_fortran_env forgex_cli_utils_m forgex_cli_time_measurement_m forgex_enums_m Subroutines public  subroutine do_find_match_dense_dfa (flags, pattern, text, is_exactly) Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern character(len=*), intent(in) :: text logical, intent(in) :: is_exactly public  subroutine do_find_match_forgex (flags, pattern, text, is_exactly) Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern character(len=*), intent(in) :: text logical, intent(in) :: is_exactly public  subroutine do_find_match_lazy_dfa (flags, pattern, text, is_exactly) Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern character(len=*), intent(in) :: text logical, intent(in) :: is_exactly private  subroutine runner_do_matching_exactly (automaton, text, res, prefix, suffix, flag_no_literal_optimize, runs_engine) Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: text logical, intent(inout) :: res character(len=*), intent(in) :: prefix character(len=*), intent(in) :: suffix logical, intent(in) :: flag_no_literal_optimize logical, intent(inout) :: runs_engine private  subroutine runner_do_matching_including (automaton, text, from, to, prefix, suffix, flag_no_literal_optimize, runs_engine) Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: text integer(kind=int32), intent(inout) :: from integer(kind=int32), intent(inout) :: to character(len=*), intent(in) :: prefix character(len=*), intent(in) :: suffix logical, intent(in) :: flag_no_literal_optimize logical, intent(inout) :: runs_engine","tags":"","loc":"module/forgex_cli_find_m.html"},{"title":"forgex_cli_help_messages_m – Forgex-CLI","text":"Uses forgex_cli_parameters_m iso_fortran_env Variables Type Visibility Attributes Name Initial integer(kind=int32), private, parameter :: CMD_DESC_SIZ = 109 integer(kind=int32), private, parameter :: CMD_SIZ = 26 integer(kind=int32), private, parameter :: LINE_SIZ = 128 Subroutines public  subroutine print_help () Arguments None public  subroutine print_help_debug () Arguments None public  subroutine print_help_debug_ast () Arguments None public  subroutine print_help_debug_thompson () Arguments None public  subroutine print_help_find () Arguments None public  subroutine print_help_find_match () Arguments None public  subroutine print_help_find_match_dense_dfa () Arguments None public  subroutine print_help_find_match_forgex_api () Arguments None public  subroutine print_help_find_match_lazy_dfa () Arguments None private  subroutine generate_and_output (header, usage, choice, cmd, cmd_desc, desc) Arguments Type Intent Optional Attributes Name character(len=LINE_SIZ), intent(in) :: header character(len=LINE_SIZ), intent(in) :: usage (:) character(len=*), intent(in) :: choice character(len=CMD_SIZ), intent(in) :: cmd (:) character(len=CMD_DESC_SIZ), intent(in) :: cmd_desc (:) character(len=LINE_SIZ), intent(in), optional :: desc (:)","tags":"","loc":"module/forgex_cli_help_messages_m.html"},{"title":"forgex_cli_cla_m – Forgex-CLI","text":"Uses forgex forgex_cli_help_messages_m forgex_cli_parameters_m forgex_cli_type_m iso_fortran_env forgex_cli_utils_m Variables Type Visibility Attributes Name Initial type( cmd_t ), public :: all_cmds (NUM_CMD) type( flag_t ), public :: all_flags (NUM_FLAGS) Derived Types type, public :: cla_t Components Type Visibility Attributes Name Initial type( arg_t ), public :: arg_info type( cmd_t ), public :: cmd integer, public :: flag_idx (NUM_FLAGS) logical, public :: flags (NUM_FLAGS) type( pattern_t ), public, allocatable :: patterns (:) type( cmd_t ), public :: sub_cmd type( cmd_t ), public :: sub_sub_cmd Type-Bound Procedures procedure, public :: collect_flags => cla__collect_flags procedure, public :: do_debug => cla__do_debug_subc procedure, public :: do_find => cla__do_find_subc procedure, public :: get_patterns => cla__get_patterns procedure, public :: init => cla__initialize procedure, public :: init_debug => cla__init_debug_subc procedure, public :: init_find => cla__init_find_subc procedure, public :: init_find_match => cla__init_find_match_subsubc procedure, public :: read_cmd => cla__read_command procedure, public :: read_subc => cla__read_subcommand procedure, public :: read_subsubc => cla__read_sub_subcommand Subroutines private  subroutine cla__collect_flags (cla) Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__do_debug_subc (cla) Processes the debug command, reads a subcommand, and calls the corresponding procedure. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__do_find_subc (cla) Processes the debug command, reads a subcommand and a sub-subcommand,\nand calls the corresponding procedure. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__get_patterns (cla, offset) Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla integer, intent(in) :: offset private  subroutine cla__init_debug_subc (cla) Prepare subcommands for the debug command. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__init_find_match_subsubc (cla) Prepare sub-subcommands for the match subcommand. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__init_find_subc (cla) Prepare subcommands for the find command. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__initialize (cla) Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__read_command (cla) Read the first argument and match it with registered commands. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__read_sub_subcommand (cla) Read the third argument and match it with registered sub-subcommands. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine cla__read_subcommand (cla) Read the second argument and match it with registered subcommands. Arguments Type Intent Optional Attributes Name class( cla_t ), intent(inout) :: cla private  subroutine init_commands () Arguments None private  subroutine init_flags () This subroutine registers all the flags forgex-cli accepts for the flag_t type array all_flags . Arguments None","tags":"","loc":"module/forgex_cli_cla_m.html"},{"title":"forgex_cli_api_internal_no_opts_m – Forgex-CLI","text":"Uses forgex_parameters_m forgex_automaton_m forgex_utf8_m Subroutines public  subroutine do_matching_exactly_no_literal_opts (automaton, string, res) This subroutine is intended to be called from the forgex_cli_find_m module. Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: string logical, intent(inout) :: res public  subroutine do_matching_including_no_literal_opts (automaton, string, from, to) This procedure reads a text, performs regular expression matching using an automaton,\nand stores the string index in the argument if it contains a match. Arguments Type Intent Optional Attributes Name type(automaton_t), intent(inout) :: automaton character(len=*), intent(in) :: string integer, intent(inout) :: from integer, intent(inout) :: to","tags":"","loc":"module/forgex_cli_api_internal_no_opts_m.html"},{"title":"forgex_cli_parameters_m – Forgex-CLI","text":"Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: CMD_DEBUG = \"debug\" Name of the subcommand debug. character(len=*), public, parameter :: CMD_FIND = \"find\" Name of the subcommand find. character(len=*), public, parameter :: CRLF = char(13)//char(10) Line ending characters for Windows OS character(len=*), public, parameter :: ENGINE_DENSE_DFA = \"dense\" character(len=*), public, parameter :: ENGINE_FORGEX_API = \"forgex\" character(len=*), public, parameter :: ENGINE_LAZY_DFA = \"lazy-dfa\" character(len=*), public, parameter :: FOOTER = \"===================================\" character(len=*), public, parameter :: HEADER_DFA = \"=============== DFA ===============\" character(len=*), public, parameter :: HEADER_NFA = \"========== Thompson NFA ===========\" Headers character(len=*), public, parameter :: INVALID_FLAG = \"INVALID\" String to indicate invalidity if no short flag is present. integer, public, parameter :: LEN_CMD = 16 Length integer, public, parameter :: LEN_ENV_VAR = 255 Maximum length of an environment variable's value. character(len=*), public, parameter :: LF = char(10) Line Feed. integer, public, parameter :: NUM_CMD = 2 Number of sub-command that forgec-cli accepts. integer, public, parameter :: NUM_DIGIT_KEY = 32 Maximum langth of table field name. integer, public, parameter :: NUM_DIGIT_TIME = 13 Number of digits for time display. integer, public, parameter :: NUM_FLAGS = 5 Number of flags (without value) that forgex-cli accepts. integer, public, parameter :: NUM_SUBC_DEBUG = 2 The number of sub-subcommands that debug accepts. integer, public, parameter :: NUM_SUBC_FIND = 1 integer, public, parameter :: NUM_SUBSUBC_MATCH = 3 character(len=*), public, parameter :: OP_IN = \".in.\" character(len=*), public, parameter :: OP_MATCH = \".match.\" Name of the sub-subcommand lazy dfa character(len=*), public, parameter :: SUBC_AST = \"ast\" Name of the sub-subcommand ast. character(len=*), public, parameter :: SUBC_MATCH = \"match\" character(len=*), public, parameter :: SUBC_THOMPSON = \"thompson\" Name of the sub-subcommand thompson. integer, public, parameter :: TREE_BUFF_LEN = 2**16 The buffer length of displaying the AST. character(len=*), public, parameter :: fmt_out_char = \"(a, 1x, a)\" character(len=*), public, parameter :: fmt_out_int = \"(a, i10)\" Output format for displaying an integer in tables. character(len=*), public, parameter :: fmt_out_logi = \"(a, l10)\" character(len=*), public, parameter :: fmt_out_ratio = \"(a, i10, '/', i0)\" character(len=*), public, parameter :: fmt_out_time = \"(a, a15)\" character(len=*), public, parameter :: fmta = \"(a)\" Format for outputting text only. character(len=*), public, parameter :: not_running = \"not running\"","tags":"","loc":"module/forgex_cli_parameters_m.html"},{"title":"forgex_cli_utils_m – Forgex-CLI","text":"Uses forgex_cli_type_m forgex_cli_parameters_m iso_fortran_env Interfaces public        interface operator(.in.) private pure function does_flag_exist (arg, flag_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( flag_t ), intent(in) :: flag_list (:) Return Value logical private pure function does_command_exist (arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg character(len=LEN_CMD), intent(in) :: cmd_list (:) Return Value logical private pure function does_command_exist_type_cmd (arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( cmd_t ), intent(in) :: cmd_list (:) Return Value logical private  function is_arg_contained_in_flags (arg, flags) result(res) Arguments Type Intent Optional Attributes Name type( arg_element_t ), intent(in) :: arg type( flag_t ), intent(in) :: flags (:) Return Value logical Functions public  function get_flag_index (arg, flags) result(res) Arguments Type Intent Optional Attributes Name type( arg_element_t ), intent(in) :: arg type( flag_t ), intent(in) :: flags (:) Return Value integer public  function get_os_type () result(res) Read more… Arguments None Return Value integer public  function text_highlight_green (string, from, to) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer(kind=int32), intent(in) :: from integer(kind=int32), intent(in) :: to Return Value character(len=:), allocatable private pure function does_command_exist (arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg character(len=LEN_CMD), intent(in) :: cmd_list (:) Return Value logical private pure function does_command_exist_type_cmd (arg, cmd_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( cmd_t ), intent(in) :: cmd_list (:) Return Value logical private pure function does_flag_exist (arg, flag_list) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: arg type( flag_t ), intent(in) :: flag_list (:) Return Value logical private  function is_arg_contained_in_flags (arg, flags) result(res) Arguments Type Intent Optional Attributes Name type( arg_element_t ), intent(in) :: arg type( flag_t ), intent(in) :: flags (:) Return Value logical Subroutines public  subroutine get_arg_command_line (argc, arg, entire) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: argc type( arg_element_t ), intent(inout), allocatable :: arg (:) character(len=:), intent(inout), allocatable :: entire public  subroutine info (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str public  subroutine register_cmd (cmd, name) Arguments Type Intent Optional Attributes Name type( cmd_t ), intent(inout) :: cmd character(len=*), intent(in) :: name public  subroutine register_flag (flag, name, long, short) Arguments Type Intent Optional Attributes Name type( flag_t ), intent(inout) :: flag character(len=*), intent(in) :: name character(len=*), intent(in) :: long character(len=*), intent(in), optional :: short public  subroutine right_justify (array) Arguments Type Intent Optional Attributes Name character(len=NUM_DIGIT_KEY), intent(inout) :: array (:)","tags":"","loc":"module/forgex_cli_utils_m.html"},{"title":"forgex_cli_memory_calculation_m – Forgex-CLI","text":"Uses forgex_parameters_m Functions public  function mem_dfa_graph (graph) result(res) Arguments Type Intent Optional Attributes Name type(dfa_graph_t), intent(in) :: graph Return Value integer public  function mem_nfa_graph (graph) result(res) Arguments Type Intent Optional Attributes Name type(nfa_graph_t), intent(in) :: graph Return Value integer public  function mem_tape (tape) result(res) Arguments Type Intent Optional Attributes Name type(tape_t), intent(in) :: tape Return Value integer public  function mem_tree (tree) result(res) Arguments Type Intent Optional Attributes Name type(tree_node_t), intent(in) :: tree (:) Return Value integer","tags":"","loc":"module/forgex_cli_memory_calculation_m.html"},{"title":"forgex_cli_debug_m – Forgex-CLI","text":"Uses forgex_cli_help_messages_m forgex_cli_parameters_m iso_fortran_env forgex_cli_utils_m forgex_cli_time_measurement_m forgex_enums_m Subroutines public  subroutine do_debug_ast (flags, pattern) Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern public  subroutine do_debug_thompson (flags, pattern) Arguments Type Intent Optional Attributes Name logical, intent(in) :: flags (:) character(len=*), intent(in) :: pattern","tags":"","loc":"module/forgex_cli_debug_m.html"},{"title":"forgex_cli_type_m – Forgex-CLI","text":"Uses forgex_cli_parameters_m Derived Types type, public :: arg_element_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: v type, public :: arg_t Components Type Visibility Attributes Name Initial type( arg_element_t ), public, allocatable :: arg (:) integer, public :: argc character(len=:), public, allocatable :: entire type, public :: cmd_t Components Type Visibility Attributes Name Initial character(len=LEN_CMD), public, allocatable :: subc (:) character(len=LEN_CMD), private :: name = '' Type-Bound Procedures procedure, public :: get_name => cmd__get_name procedure, public :: set_name => cmd__set_name type, public :: flag_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: long_f character(len=32), public :: name character(len=:), public, allocatable :: short_f type, public :: pattern_t Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: p Functions private pure function cmd__get_name (self) result(res) Arguments Type Intent Optional Attributes Name class( cmd_t ), intent(in) :: self Return Value character(len=:), allocatable Subroutines private pure subroutine cmd__set_name (self, name) Arguments Type Intent Optional Attributes Name class( cmd_t ), intent(inout) :: self character(len=*), intent(in) :: name","tags":"","loc":"module/forgex_cli_type_m.html"},{"title":"cli_time_measurement_m.F90 – Forgex-CLI","text":"This file provides procedures for time measurement. Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_time_measurement_m module is a part of Forgex. ! !! This file provides procedures for time measurement. ! !> This module provides procedures to measure the time it takes to execute. module forgex_cli_time_measurement_m use , intrinsic :: iso_fortran_env , only : real64 , stderr => error_unit use , intrinsic :: iso_c_binding , only : c_long_long , c_bool !$ use :: omp_lib use :: forgex_cli_parameters_m , only : NUM_DIGIT_TIME use :: forgex_cli_utils_m , only : get_os_type use :: forgex_enums_m , only : OS_WINDOWS implicit none private public :: time_begin , time_lap public :: get_lap_time_in_appropriate_unit real ( real64 ) :: begin_s , last_s , end_s integer ( c_long_long ) :: time_begin_qhc , time_end_qhc , frequency logical ( c_bool ) :: is_supported = . false . logical ( c_bool ) :: is_succeeded = . false . !> For Windows, use high-resolution system call for timing. interface function QueryPerformanceCounter ( PerformanceCount_count ) result ( is_succeeded_c ) & bind ( c , name = \"QueryPerformanceCounter\" ) use , intrinsic :: iso_c_binding implicit none integer ( c_long_long ), intent ( out ) :: PerformanceCount_count logical ( c_bool ) :: is_succeeded_c end function QueryPerformanceCounter function QueryPerformanceFrequency ( Frequency_countPerSec ) result ( is_supported_c ) & bind ( c , name = \"QueryPerformanceFrequency\" ) use , intrinsic :: iso_c_binding implicit none integer ( c_long_long ), intent ( out ) :: Frequency_countPerSec logical ( c_bool ) :: is_supported_c end function QueryPerformanceFrequency end interface !! cf. https://qiita.com/implicit_none/items/86c9117990798c1e8b3b contains !> This subroutine is for timing purpose and starts a stopwatch. subroutine time_begin () implicit none if ( get_os_type () == OS_WINDOWS ) then is_supported = QueryPerformanceFrequency ( frequency ) if ( is_supported ) then is_succeeded = QueryPerformanceCounter ( time_begin_qhc ) else !$ begin_s = omp_get_wtime() !$ last_s = begin_s !$ return call use_cpu_time_begin end if else !$ begin_s = omp_get_wtime() !$ last_s = begin_s !$ return call use_cpu_time_begin end if contains subroutine use_cpu_time_begin implicit none begin_s = 0 d0 last_s = 0 d0 end_s = 0 d0 call cpu_time ( begin_s ) last_s = begin_s end subroutine use_cpu_time_begin end subroutine time_begin !> This function is for timing purposes and returns the lap time !> since the last call of `time_begin` or `time_lap`. function time_lap () result ( res ) implicit none real ( real64 ) :: res if ( get_os_type () == OS_WINDOWS ) then if ( is_supported ) then is_succeeded = QueryPerformanceCounter ( time_end_qhc ) res = dble ( time_end_qhc - time_begin_qhc ) / dble ( frequency ) time_begin_qhc = time_end_qhc else !$ end_s = omp_get_wtime() !$ res = end_s - last_s !$ last_s = end_s !$ return call use_cpu_time_end end if else !$ end_s = omp_get_wtime() !$ res = end_s - last_s !$ last_s = end_s !$ return call use_cpu_time_end end if contains subroutine use_cpu_time_end implicit none call cpu_time ( end_s ) res = end_s - last_s last_s = end_s end subroutine use_cpu_time_end end function time_lap !> This function takes a real number of seconds, converts it to the appropriate !> units, and returns a string with the unit for output. function get_lap_time_in_appropriate_unit ( lap_time ) result ( res ) implicit none real ( real64 ), intent ( in ) :: lap_time character ( NUM_DIGIT_TIME ) :: res character ( 3 ) :: unit real ( real64 ) :: multiplied unit = 's' if ( lap_time >= 6 d1 ) then unit = 'm' multiplied = lap_time / 6 d1 else if ( lap_time >= 1 d0 ) then unit = 's' multiplied = lap_time else if ( lap_time >= 1 d - 3 ) then unit = 'ms' multiplied = lap_time * 1 d3 else if ( lap_time >= 1 d - 6 ) then if ( get_os_type () == OS_WINDOWS ) then unit = 'us' else unit = 'μs' end if multiplied = lap_time * 1 d6 else unit = 'ns' multiplied = lap_time * 1 d9 end if write ( res , '(f10.1, a)' ) multiplied , unit end function get_lap_time_in_appropriate_unit end module forgex_cli_time_measurement_m","tags":"","loc":"sourcefile/cli_time_measurement_m.f90.html"},{"title":"cli_find_m.f90 – Forgex-CLI","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_find_m module is a part of Forgex. ! module forgex_cli_find_m use , intrinsic :: iso_fortran_env , stdout => output_unit use :: forgex_cli_parameters_m use :: forgex_enums_m use :: forgex_cli_time_measurement_m use :: forgex_cli_help_messages_m use :: forgex_cli_utils_m , only : right_justify implicit none private public :: do_find_match_forgex public :: do_find_match_lazy_dfa public :: do_find_match_dense_dfa contains subroutine do_find_match_forgex ( flags , pattern , text , is_exactly ) use :: forgex , only : regex , operator (. in .), operator (. match .) use :: forgex_parameters_m , only : INVALID_CHAR_INDEX use :: forgex_cli_time_measurement_m use :: forgex_cli_utils_m , only : text_highlight_green implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern , text logical , intent ( in ) :: is_exactly real ( real64 ) :: lap logical :: res character (:), allocatable :: res_string integer :: from , to , unused res_string = '' from = INVALID_CHAR_INDEX to = INVALID_CHAR_INDEX call time_begin () if ( is_exactly ) then res = pattern . match . text else res = pattern . in . text end if lap = time_lap () ! Invoke regex subroutine to highlight matched substring. call regex ( pattern , text , res_string , unused , from , to ) output : block character ( NUM_DIGIT_KEY ) :: pattern_key , text_key character ( NUM_DIGIT_KEY ) :: total_time , matching_result character ( NUM_DIGIT_KEY ) :: buf ( 4 ) pattern_key = \"pattern:\" text_key = \"text:\" total_time = \"time:\" matching_result = \"result:\" if ( flags ( FLAG_NO_TABLE )) then write ( stdout , * ) res else buf = [ pattern_key , text_key , total_time , matching_result ] call right_justify ( buf ) write ( stdout , '(a, 1x, a)' ) trim ( buf ( 1 )), trim ( adjustl ( pattern )) write ( stdout , '(a, 1x, a)' ) trim ( buf ( 2 )), '\"' // text_highlight_green ( text , from , to ) // '\"' write ( stdout , fmt_out_time ) trim ( buf ( 3 )), get_lap_time_in_appropriate_unit ( lap ) write ( stdout , fmt_out_logi ) trim ( buf ( 4 )), res end if end block output end subroutine do_find_match_forgex subroutine do_find_match_lazy_dfa ( flags , pattern , text , is_exactly ) use :: forgex_automaton_m use :: forgex_syntax_tree_graph_m use :: forgex_syntax_tree_optimize_m use :: forgex_cli_memory_calculation_m use :: forgex_api_internal_m use :: forgex_nfa_state_set_m use :: forgex_cli_utils_m use :: forgex_utility_m , only : is_there_caret_at_the_top , is_there_dollar_at_the_end use :: forgex_parameters_m , only : ACCEPTED_EMPTY implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern character ( * ), intent ( in ) :: text logical , intent ( in ) :: is_exactly type ( tree_t ) :: tree type ( automaton_t ) :: automaton integer :: uni , ierr , i character (:), allocatable :: dfa_for_print , prefix , suffix , entire character ( 256 ) :: line real ( real64 ) :: lap1 , lap2 , lap3 , lap4 , lap5 logical :: res , flag_runs_engine , flag_fixed_string integer :: from , to dfa_for_print = '' lap1 = 0 d0 lap2 = 0 d0 lap3 = 0 d0 lap4 = 0 d0 lap5 = 0 d0 from = 0 to = 0 prefix = '' suffix = '' entire = '' flag_fixed_string = . false . flag_runs_engine = . false . if ( flags ( FLAG_HELP ) . or . pattern == '' ) call print_help_find_match_lazy_dfa call time_begin () call tree % build ( trim ( pattern )) lap1 = time_lap () call time_begin () if (. not . flags ( FLAG_NO_LITERAL )) then entire = get_entire_literal ( tree ) if ( entire /= '' ) flag_fixed_string = . true . if (. not . flag_fixed_string ) then prefix = get_prefix_literal ( tree ) suffix = get_suffix_literal ( tree ) end if end if lap5 = time_lap () if (. not . flag_fixed_string ) then call automaton % preprocess ( tree ) lap2 = time_lap () call automaton % init () lap3 = time_lap () end if if ( is_exactly ) then if ( flag_fixed_string ) then if ( len ( text ) == len ( entire )) then res = text == entire end if else call runner_do_matching_exactly ( automaton , text , res , prefix , suffix , flags ( FLAG_NO_LITERAL ), flag_runs_engine ) end if lap4 = time_lap () if ( res ) then from = 1 to = len ( text ) end if else block if ( flag_fixed_string ) then from = index ( text , entire ) if ( from > 0 ) to = from + len ( entire ) - 1 else call runner_do_matching_including ( automaton , text , from , to , & prefix , suffix , flags ( FLAG_NO_LITERAL ), flag_runs_engine ) end if if ( from > 0 . and . to > 0 ) then res = . true . else if ( from == ACCEPTED_EMPTY . and . to == ACCEPTED_EMPTY ) then res = . true . else res = . false . end if lap4 = time_lap () end block end if open ( newunit = uni , status = 'scratch' ) write ( uni , fmta ) HEADER_NFA call automaton % nfa % print ( uni , automaton % nfa_exit ) write ( uni , fmta ) HEADER_DFA call automaton % print_dfa ( uni ) rewind ( uni ) ierr = 0 do while ( ierr == 0 ) read ( uni , fmta , iostat = ierr ) line if ( ierr /= 0 ) exit if ( get_os_type () == OS_WINDOWS ) then dfa_for_print = dfa_for_print // trim ( line ) // CRLF else dfa_for_print = dfa_for_print // trim ( line ) // LF end if end do close ( uni ) output : block character ( NUM_DIGIT_KEY ) :: pattern_key , text_key character ( NUM_DIGIT_KEY ) :: parse_time , extract_time character ( NUM_DIGIT_KEY ) :: nfa_time , dfa_init_time , matching_time , memory character ( NUM_DIGIT_KEY ) :: runs_engine_key character ( NUM_DIGIT_KEY ) :: tree_count character ( NUM_DIGIT_KEY ) :: nfa_count character ( NUM_DIGIT_KEY ) :: dfa_count , matching_result character ( NUM_DIGIT_KEY ) :: cbuff ( 13 ) = '' integer :: memsiz pattern_key = \"pattern:\" text_key = \"text:\" parse_time = \"parse time:\" extract_time = \"extract literal time:\" runs_engine_key = \"runs engine:\" nfa_time = \"compile nfa time:\" dfa_init_time = \"dfa initialize time:\" matching_time = \"search time:\" memory = \"memory (estimated):\" matching_result = \"matching result:\" tree_count = \"tree node count:\" nfa_count = \"nfa states:\" dfa_count = \"dfa states:\" if ( flag_fixed_string ) then memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) else memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) + mem_nfa_graph ( automaton % nfa ) & + mem_dfa_graph ( automaton % dfa ) + 4 * 3 end if if ( allocated ( automaton % entry_set % vec )) then memsiz = memsiz + size ( automaton % entry_set % vec , dim = 1 ) end if if ( allocated ( automaton % all_segments )) then memsiz = memsiz + size ( automaton % all_segments , dim = 1 ) * 8 end if if ( flags ( FLAG_VERBOSE )) then cbuff = [ pattern_key , text_key , parse_time , extract_time , runs_engine_key , & nfa_time , dfa_init_time , matching_time , matching_result , memory , tree_count , & nfa_count , dfa_count ] call right_justify ( cbuff ) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 1 )), trim ( adjustl ( pattern )) ! write(stdout, '(a, 1x, a)') trim(cbuff(2)), '\"'//text//'\"' write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 2 )), '\"' // text_highlight_green ( text , from , to ) // '\"' write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 5 )), flag_runs_engine if ( flag_runs_engine . or . . not . flag_fixed_string ) then write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap3 ) else write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), not_running write ( stdout , fmt_out_char ) trim ( cbuff ( 7 )), not_running end if write ( stdout , fmt_out_time ) trim ( cbuff ( 8 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 9 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 10 )), memsiz write ( stdout , fmt_out_ratio ) trim ( cbuff ( 11 )), tree % top , size ( tree % nodes , dim = 1 ) write ( stdout , fmt_out_ratio ) trim ( cbuff ( 12 )), automaton % nfa % nfa_top , automaton % nfa % nfa_limit write ( stdout , fmt_out_ratio ) trim ( cbuff ( 13 )), automaton % dfa % dfa_top , automaton % dfa % dfa_limit else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff (:) = [ pattern_key , text_key , parse_time , extract_time , runs_engine_key , nfa_time , dfa_init_time , & matching_time , matching_result , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 3 )] call right_justify ( cbuff ) write ( stdout , '(a,1x,a)' ) trim ( cbuff ( 1 )), pattern ! write(stdout, '(a,1x,a)') trim(cbuff(2)), \"'\"//text//\"'\" write ( stdout , '(a,1x,a)' ) trim ( cbuff ( 2 )), \"'\" // text_highlight_green ( text , from , to ) // \"'\" write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 5 )), flag_runs_engine if ( flag_runs_engine . or . . not . flag_fixed_string ) then write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap3 ) else write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), not_running write ( stdout , fmt_out_char ) trim ( cbuff ( 7 )), not_running end if write ( stdout , fmt_out_time ) trim ( cbuff ( 8 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 9 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 10 )), memsiz end if if ( flags ( FLAG_TABLE_ONLY ) . or . . not . flag_runs_engine . or . flag_fixed_string ) then call automaton % free return end if write ( stdout , * ) \"\" write ( stdout , fmta , advance = 'no' ) trim ( dfa_for_print ) write ( stdout , fmta ) FOOTER end block output call automaton % free end subroutine do_find_match_lazy_dfa subroutine do_find_match_dense_dfa ( flags , pattern , text , is_exactly ) use :: forgex_automaton_m use :: forgex_syntax_tree_graph_m use :: forgex_cli_memory_calculation_m use :: forgex_cli_time_measurement_m use :: forgex_dense_dfa_m use :: forgex_nfa_state_set_m use :: forgex_cli_utils_m use :: forgex_utility_m implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern character ( * ), intent ( in ) :: text logical , intent ( in ) :: is_exactly type ( tree_t ) :: tree type ( automaton_t ) :: automaton integer :: uni , ierr , i character (:), allocatable :: dfa_for_print character ( 256 ) :: line real ( real64 ) :: lap1 , lap2 , lap3 , lap4 , lap5 logical :: res integer :: from , to from = 0 to = 0 if ( flags ( FLAG_HELP ) . or . pattern == '' ) call print_help_find_match_dense_dfa if ( flags ( FLAG_NO_LITERAL )) call info ( \"No literal search optimization is implemented in dense DFA.\" ) call time_begin () ! call build_syntax_tree(trim(pattern), tape, tree, root) call tree % build ( trim ( pattern )) lap1 = time_lap () call automaton % preprocess ( tree ) lap2 = time_lap () ! build nfa call automaton % init () lap3 = time_lap () ! automaton initialize call construct_dense_dfa ( automaton , automaton % initial_index ) lap4 = time_lap () ! compile nfa to dfa if ( is_exactly ) then res = match_dense_dfa_exactly ( automaton , text ) if ( res ) then from = 1 to = len ( text ) end if else block call match_dense_dfa_including ( automaton , char ( 10 ) // text // char ( 10 ), from , to ) if ( is_there_caret_at_the_top ( pattern )) then from = from else from = from - 1 end if if ( is_there_dollar_at_the_end ( pattern )) then to = to - 2 else to = to - 1 end if if ( from > 0 . and . to > 0 ) then res = . true . else res = . false . end if end block end if lap5 = time_lap () ! search time open ( newunit = uni , status = 'scratch' ) write ( uni , fmta ) HEADER_NFA call automaton % nfa % print ( uni , automaton % nfa_exit ) write ( uni , fmta ) HEADER_DFA call automaton % print_dfa ( uni ) rewind ( uni ) ierr = 0 dfa_for_print = '' do while ( ierr == 0 ) read ( uni , fmta , iostat = ierr ) line if ( ierr /= 0 ) exit if ( get_os_type () == OS_WINDOWS ) then dfa_for_print = dfa_for_print // trim ( line ) // CRLF else dfa_for_print = dfa_for_print // trim ( line ) // LF end if end do close ( uni ) output : block character ( NUM_DIGIT_KEY ) :: pattern_key , text_key character ( NUM_DIGIT_KEY ) :: parse_time , nfa_time , dfa_init_time , dfa_compile_time , matching_time character ( NUM_DIGIT_KEY ) :: memory character ( NUM_DIGIT_KEY ) :: tree_count , nfa_count , dfa_count character ( NUM_DIGIT_KEY ) :: matching_result character ( NUM_DIGIT_KEY ) :: cbuff ( 12 ) = '' integer :: memsiz pattern_key = \"pattern:\" text_key = \"text:\" parse_time = \"parse time:\" nfa_time = \"compile nfa time:\" dfa_init_time = \"dfa initialize time:\" dfa_compile_time = \"compile dfa time:\" matching_time = \"search time:\" memory = \"memory (estimated):\" matching_result = \"matching result:\" tree_count = \"tree node count:\" nfa_count = \"nfa states:\" dfa_count = \"dfa states:\" memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) + mem_nfa_graph ( automaton % nfa ) & + mem_dfa_graph ( automaton % dfa ) + 4 * 3 if ( allocated ( automaton % entry_set % vec )) then memsiz = memsiz + size ( automaton % entry_set % vec , dim = 1 ) end if if ( allocated ( automaton % all_segments )) then memsiz = memsiz + size ( automaton % all_segments , dim = 1 ) * 8 end if if ( flags ( FLAG_VERBOSE )) then cbuff = [ pattern_key , text_key , parse_time , nfa_time , dfa_init_time , dfa_compile_time , matching_time ,& matching_result , memory , tree_count , nfa_count , dfa_count ] call right_justify ( cbuff ) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 1 )), trim ( adjustl ( pattern )) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 2 )), \"'\" // text_highlight_green ( text , from , to ) // \"'\" write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 5 )), get_lap_time_in_appropriate_unit ( lap3 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 8 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 9 )), memsiz write ( stdout , fmt_out_ratio ) trim ( cbuff ( 10 )), tree % top , size ( tree % nodes , dim = 1 ) write ( stdout , fmt_out_ratio ) trim ( cbuff ( 11 )), automaton % nfa % nfa_top , automaton % nfa % nfa_limit write ( stdout , fmt_out_ratio ) trim ( cbuff ( 12 )), automaton % dfa % dfa_top , automaton % dfa % dfa_limit else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff = [ pattern_key , text_key , parse_time , nfa_time , dfa_init_time , dfa_compile_time , matching_time ,& matching_result , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 3 )] call right_justify ( cbuff ) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 1 )), trim ( adjustl ( pattern )) write ( stdout , '(a, 1x, a)' ) trim ( cbuff ( 2 )), \"'\" // text_highlight_green ( text , from , to ) // \"'\" write ( stdout , fmt_out_time ) trim ( cbuff ( 3 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 4 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 5 )), get_lap_time_in_appropriate_unit ( lap3 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 6 )), get_lap_time_in_appropriate_unit ( lap4 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 7 )), get_lap_time_in_appropriate_unit ( lap5 ) write ( stdout , fmt_out_logi ) trim ( cbuff ( 8 )), res write ( stdout , fmt_out_int ) trim ( cbuff ( 9 )), memsiz end if if ( flags ( FLAG_TABLE_ONLY )) then call automaton % free () return end if write ( stdout , * ) \"\" write ( stdout , fmta , advance = 'no' ) trim ( dfa_for_print ) write ( stdout , fmta ) FOOTER end block output call automaton % free () end subroutine do_find_match_dense_dfa subroutine runner_do_matching_exactly ( automaton , text , res , prefix , suffix , flag_no_literal_optimize , runs_engine ) use :: forgex_automaton_m use :: forgex_syntax_tree_optimize_m use :: forgex_cli_api_internal_no_opts_m use :: forgex_api_internal_m implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: text logical , intent ( inout ) :: res logical , intent ( inout ) :: runs_engine logical , intent ( in ) :: flag_no_literal_optimize character ( * ), intent ( in ) :: prefix , suffix if ( flag_no_literal_optimize ) then call do_matching_exactly_no_literal_opts ( automaton , text , res ) runs_engine = . true . else call do_matching_exactly ( automaton , text , res , prefix , suffix , runs_engine ) end if end subroutine runner_do_matching_exactly subroutine runner_do_matching_including ( automaton , text , from , to , prefix , suffix , flag_no_literal_optimize , runs_engine ) use :: forgex_syntax_tree_optimize_m use :: forgex_automaton_m use :: forgex_api_internal_m use :: forgex_cli_api_internal_no_opts_m implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: text integer ( int32 ), intent ( inout ) :: from , to character ( * ), intent ( in ) :: prefix , suffix logical , intent ( in ) :: flag_no_literal_optimize logical , intent ( inout ) :: runs_engine if ( flag_no_literal_optimize ) then call do_matching_including_no_literal_opts ( automaton , text , from , to ) runs_engine = . true . else call do_matching_including ( automaton , text , from , to , prefix , suffix , runs_engine ) end if end subroutine runner_do_matching_including end module forgex_cli_find_m","tags":"","loc":"sourcefile/cli_find_m.f90.html"},{"title":"cli_help_messages_m.f90 – Forgex-CLI","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_help_messages_m module is a part of Forgex. ! module forgex_cli_help_messages_m use , intrinsic :: iso_fortran_env , only : stderr => error_unit , int32 use :: forgex_cli_parameters_m , only : fmta implicit none private public :: print_help public :: print_help_debug public :: print_help_debug_ast public :: print_help_debug_thompson public :: print_help_find public :: print_help_find_match public :: print_help_find_match_dense_dfa public :: print_help_find_match_lazy_dfa public :: print_help_find_match_forgex_api integer ( int32 ), parameter :: LINE_SIZ = 128 integer ( int32 ), parameter :: CMD_SIZ = 26 integer ( int32 ), parameter :: CMD_DESC_SIZ = 109 contains subroutine generate_and_output ( header , usage , choice , cmd , cmd_desc , desc ) implicit none character ( LINE_SIZ ), intent ( in ) :: header character ( LINE_SIZ ), intent ( in ) :: usage (:) character ( * ), intent ( in ) :: choice character ( CMD_SIZ ), intent ( in ) :: cmd (:) ! command character ( CMD_DESC_SIZ ), intent ( in ) :: cmd_desc (:) ! description character ( LINE_SIZ ), intent ( in ), optional :: desc (:) character ( LINE_SIZ ), allocatable :: buff (:) integer :: num_line , i , offset if ( present ( desc )) then num_line = 3 + size ( desc ) + size ( usage ) + 2 + size ( cmd ) else num_line = 3 + size ( usage ) + 2 + size ( cmd ) end if ! header + blank + DESC + blank+ USAGE + size(usage) + blank + COMMANDS + size(cmd) allocate ( buff ( num_line )) buff (:) = \"\" buff ( 1 ) = header ! buff(2) blank offset = 2 if ( present ( desc )) then do i = 1 , size ( desc ) buff ( i + offset ) = desc ( i ) end do offset = offset + size ( desc ) endif offset = offset + 1 buff ( offset ) = \"USAGE:\" do i = 1 , size ( usage ) buff ( i + offset ) = \"   \" // trim ( usage ( i )) end do offset = offset + size ( usage ) buff ( offset + 2 ) = trim ( choice ) // \":\" offset = offset + 2 do i = 1 , size ( cmd ) buff ( i + offset ) = \"   \" // cmd ( i ) // \" \" // cmd_desc ( i ) enddo do i = 1 , num_line write ( stderr , fmta ) trim ( buff ( i )) end do stop end subroutine generate_and_output subroutine print_help implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 2 ) character ( CMD_DESC_SIZ ) :: cdesc ( 2 ) header = \"A tool for interacting with Forgex on the command line.\" usage ( 1 ) = \"forgex-cli <command> ...\" cmd ( 1 ) = \"debug\" cdesc ( 1 ) = \"Print the debug representation from Forgex's regex engine.\" cmd ( 2 ) = \"find\" cdesc ( 2 ) = \"Search for a string using one of the regular expression engines.\" call generate_and_output ( header , usage , \"COMMANDS\" , cmd , cdesc ) end subroutine print_help subroutine print_help_debug implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 2 ) character ( CMD_DESC_SIZ ) :: cdesc ( 2 ) header = \"Prints the debug representation provided by Forgex.\" usage ( 1 ) = \"forgex-cli debug <command> ...\" cmd ( 1 ) = \"ast\" cdesc ( 1 ) = \"Print the debug representation of an AST.\" cmd ( 2 ) = \"thompson\" cdesc ( 2 ) = \"Print the debug representation of a Thompson NFA.\" call generate_and_output ( header , usage , \"COMMANDS\" , cmd , cdesc ) end subroutine print_help_debug !=====================================================================! subroutine print_help_debug_ast implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: op ( 3 ) character ( CMD_DESC_SIZ ) :: odesc ( 3 ) header = \"Print the debug representation of an abstract syntax tree (AST).\" usage ( 1 ) = \"forgex-cli debug ast <pattern>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Passing this flag suppresses the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine subroutine print_help_debug_thompson implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: op ( 3 ) character ( CMD_DESC_SIZ ) :: odesc ( 3 ) header = \"Print the debug representaion of a Thompson NFA.\" usage ( 1 ) = \"forgex-cli debug thompson <pattern>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Suppresses the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_debug_thompson !=====================================================================! subroutine print_help_find implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 1 ) character ( CMD_DESC_SIZ ) :: cdesc ( 1 ) header = \"Executes a search.\" usage ( 1 ) = \"forgex-cli find <command> ...\" cmd ( 1 ) = \"match\" cdesc ( 1 ) = \"Search for full matches.\" call generate_and_output ( header , usage , \"COMMANDS\" , cmd , cdesc ) end subroutine print_help_find subroutine print_help_find_match implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 1 ) character ( CMD_SIZ ) :: cmd ( 3 ) character ( CMD_DESC_SIZ ) :: cdesc ( 3 ) header = \"Executes a search for full matches.\" usage ( 1 ) = \"forgex-cli find match <engine>\" cmd ( 1 ) = \"dense\" cdesc ( 1 ) = \"Search with the fully-compiled DFA regex engine.\" cmd ( 2 ) = \"lazy-dfa\" cdesc ( 2 ) = \"Search with the lazy DFA regex engine.\" cmd ( 3 ) = \"forgex\" cdesc ( 3 ) = \"Search with the top-level API regex engine.\" call generate_and_output ( header , usage , \"ENGINES\" , cmd , cdesc ) end subroutine print_help_find_match subroutine print_help_find_match_lazy_dfa implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 2 ) character ( CMD_SIZ ) :: op ( 4 ) character ( CMD_DESC_SIZ ) :: odesc ( 4 ) header = \"Executes a search for matches using a lazy DFA regex engine.\" usage ( 1 ) = \"forgex-cli debug lazy-dfa <pattern> .match. <text>\" usage ( 2 ) = \"forgex-cli debug lazy-dfa <pattern> .in. <text>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Suppress the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only. \" op ( 4 ) = \"--disable-literal-optimize\" odesc ( 4 ) = \"Disable literals search optimization.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_find_match_lazy_dfa subroutine print_help_find_match_dense_dfa implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 2 ) character ( CMD_SIZ ) :: op ( 3 ) character ( CMD_DESC_SIZ ) :: odesc ( 3 ) header = \"Execute a search for matches using a fully-compiled DFA regex engine.\" usage ( 1 ) = \"forgex-cli find match dense <pattern> .match. <text>\" usage ( 2 ) = \"forgex-cli find match dense <pattern> .in. <text>\" op ( 1 ) = \"--verbose\" odesc ( 1 ) = \"Print more information.\" op ( 2 ) = \"--no-table\" odesc ( 2 ) = \"Suppress the output of the property information table.\" op ( 3 ) = \"--table-only\" odesc ( 3 ) = \"Print the property information table only. \" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_find_match_dense_dfa subroutine print_help_find_match_forgex_api implicit none character ( LINE_SIZ ) :: header character ( LINE_SIZ ) :: usage ( 2 ) character ( CMD_SIZ ) :: op ( 1 ) character ( CMD_DESC_SIZ ) :: odesc ( 1 ) header = \"Executes a search for matches using the top-level API regex engine.\" usage ( 1 ) = \"forgex-cli find match forgex <pattern> .match. <text>\" usage ( 2 ) = \"forgex-cli find match forgex <pattern> .in. <text>\" op ( 1 ) = \"--no-table\" odesc ( 1 ) = \"Suppress the output of the property information table.\" call generate_and_output ( header , usage , \"OPTIONS\" , op , odesc ) end subroutine print_help_find_match_forgex_api end module forgex_cli_help_messages_m","tags":"","loc":"sourcefile/cli_help_messages_m.f90.html"},{"title":"cli_cla_m.f90 – Forgex-CLI","text":"This file includes to handle command line arguments for the tool of forgex-cli. Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_cla_m module is a part of Forgex. ! !! This file includes to handle command line arguments for the tool of forgex-cli. !> module forgex_cli_cla_m use , intrinsic :: iso_fortran_env , only : int32 , real64 , stderr => error_unit use :: forgex , only : operator (. match .) use :: forgex_cli_parameters_m use :: forgex_cli_type_m , only : flag_t , cmd_t , pattern_t , arg_t , arg_element_t use :: forgex_cli_utils_m , only : get_flag_index , operator (. in .), register_flag , register_cmd , & get_arg_command_line use :: forgex_cli_help_messages_m , only : print_help_debug , print_help_debug_ast , & print_help_debug_thompson , print_help_find_match_lazy_dfa , & print_help_find , print_help_find_match , print_help_find_match_lazy_dfa , & print_help_find_match_dense_dfa , print_help_find_match_forgex_api implicit none private type ( flag_t ), public :: all_flags ( NUM_FLAGS ) type ( cmd_t ), public :: all_cmds ( NUM_CMD ) ! The type which represents command line arguments type , public :: cla_t type ( arg_t ) :: arg_info type ( cmd_t ) :: cmd , sub_cmd , sub_sub_cmd type ( pattern_t ), allocatable :: patterns (:) logical :: flags ( NUM_FLAGS ) integer :: flag_idx ( NUM_FLAGS ) contains procedure :: init => cla__initialize procedure :: read_cmd => cla__read_command procedure :: read_subc => cla__read_subcommand procedure :: read_subsubc => cla__read_sub_subcommand procedure :: collect_flags => cla__collect_flags procedure :: get_patterns => cla__get_patterns procedure :: init_debug => cla__init_debug_subc procedure :: init_find => cla__init_find_subc procedure :: init_find_match => cla__init_find_match_subsubc procedure :: do_debug => cla__do_debug_subc procedure :: do_find => cla__do_find_subc end type cla_t contains !=====================================================================! !> This subroutine registers all the flags forgex-cli accepts for the `flag_t` type array `all_flags`. subroutine init_flags () use :: forgex_enums_m implicit none call register_flag ( all_flags ( FLAG_HELP ), 'help' , '--help' , '-h' ) call register_flag ( all_flags ( FLAG_VERBOSE ), 'verbose' , '--verbose' , '-v' ) call register_flag ( all_flags ( FLAG_NO_TABLE ), 'no-table' , '--no-table' ) call register_flag ( all_flags ( FLAG_TABLE_ONLY ), 'table-only' , '--table-only' ) call register_flag ( all_flags ( FLAG_NO_LITERAL ), 'no-literal-optimize' , '--disable-literal-optimize' ) end subroutine init_flags subroutine init_commands () implicit none call register_cmd ( all_cmds ( 1 ), CMD_DEBUG ) call register_cmd ( all_cmds ( 2 ), CMD_FIND ) end subroutine init_commands !=====================================================================! !> Prepare subcommands for the `debug` command. subroutine cla__init_debug_subc ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla allocate ( cla % cmd % subc ( NUM_SUBC_DEBUG )) cla % cmd % subc ( 1 ) = SUBC_AST cla % cmd % subc ( 2 ) = SUBC_THOMPSON end subroutine !> Prepare subcommands for the `find` command. subroutine cla__init_find_subc ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla allocate ( cla % cmd % subc ( NUM_SUBC_FIND )) cla % cmd % subc ( 1 ) = SUBC_MATCH end subroutine cla__init_find_subc !---------------------------------! !> Prepare sub-subcommands for the `match` subcommand. subroutine cla__init_find_match_subsubc ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla allocate ( cla % sub_cmd % subc ( NUM_SUBSUBC_MATCH )) cla % sub_cmd % subc ( 1 ) = ENGINE_LAZY_DFA cla % sub_cmd % subc ( 2 ) = ENGINE_DENSE_DFA cla % sub_cmd % subc ( 3 ) = ENGINE_FORGEX_API end subroutine cla__init_find_match_subsubc !=====================================================================! !> Read the first argument and match it with registered commands. subroutine cla__read_command ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla character (:), allocatable :: cmd if ( ubound ( cla % arg_info % arg , dim = 1 ) < 1 ) then cmd = \"\" return end if cmd = trim ( cla % arg_info % arg ( 1 )% v ) if ( cmd . in . all_cmds ) then call cla % cmd % set_name ( cmd ) else call cla % cmd % set_name ( \"\" ) end if end subroutine cla__read_command !> Read the second argument and match it with registered subcommands. subroutine cla__read_subcommand ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla character (:), allocatable :: cmd integer :: i cmd = trim ( cla % arg_info % arg ( 2 )% v ) do i = 1 , size ( cla % cmd % subc ) if ( cmd == cla % cmd % subc ( i )) then call cla % sub_cmd % set_name ( cmd ) return end if end do end subroutine cla__read_subcommand !> Read the third argument and match it with registered sub-subcommands. subroutine cla__read_sub_subcommand ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla character (:), allocatable :: cmd integer :: i if ( cla % arg_info % argc < 3 ) return cmd = trim ( cla % arg_info % arg ( 3 )% v ) do i = 1 , size ( cla % sub_cmd % subc ) if ( cmd == cla % sub_cmd % subc ( i )) then call cla % sub_sub_cmd % set_name ( cmd ) return end if end do end subroutine cla__read_sub_subcommand !=====================================================================! !> Processes the `debug` command, reads a subcommand, and calls the corresponding procedure. subroutine cla__do_debug_subc ( cla ) use :: forgex_cli_debug_m implicit none class ( cla_t ), intent ( inout ) :: cla integer :: pattern_offset pattern_offset = 3 call cla % init_debug () call cla % read_subc () if ( cla % sub_cmd % get_name () == '' ) then call print_help_debug end if call cla % get_patterns ( pattern_offset ) ! Handle errors when a pattern does not exist. if (. not . allocated ( cla % patterns )) then select case ( cla % sub_cmd % get_name ()) case ( SUBC_AST ) call print_help_debug_ast case ( SUBC_THOMPSON ) call print_help_debug_thompson case default call print_help_debug end select end if if ( size ( cla % patterns ) > 1 ) then write ( stderr , '(a, i0, a)' ) \"Only single pattern is expected, but \" , size ( cla % patterns ), \" were given.\" stop end if select case ( cla % sub_cmd % get_name ()) case ( SUBC_AST ) call do_debug_ast ( cla % flags , cla % patterns ( 1 )% p ) case ( SUBC_THOMPSON ) call do_debug_thompson ( cla % flags , cla % patterns ( 1 )% p ) end select end subroutine cla__do_debug_subc !> Processes the `debug` command, reads a subcommand and a sub-subcommand, !> and calls the corresponding procedure. subroutine cla__do_find_subc ( cla ) use :: forgex_cli_find_m implicit none class ( cla_t ), intent ( inout ) :: cla logical :: is_exactly integer :: pattern_offset character (:), allocatable :: text pattern_offset = 4 call cla % init_find () call cla % read_subc () if ( cla % sub_cmd % get_name () == '' ) then call print_help_find else if ( cla % sub_cmd % get_name () == SUBC_MATCH ) then call cla % init_find_match () endif call cla % read_subsubc () if ( cla % sub_sub_cmd % get_name () == '' ) then select case ( cla % sub_cmd % get_name ()) case ( SUBC_MATCH ) call print_help_find_match end select end if call cla % get_patterns ( pattern_offset ) if (. not . allocated ( cla % patterns )) then select case ( cla % sub_sub_cmd % get_name ()) case ( ENGINE_LAZY_DFA ) call print_help_find_match_lazy_dfa case ( ENGINE_DENSE_DFA ) call print_help_find_match_dense_dfa case ( ENGINE_FORGEX_API ) call print_help_find_match_forgex_api end select end if if ( cla % sub_sub_cmd % get_name () == ENGINE_LAZY_DFA & . or . cla % sub_sub_cmd % get_name () == ENGINE_DENSE_DFA & . or . cla % sub_sub_cmd % get_name () == ENGINE_FORGEX_API ) then if ( size ( cla % patterns ) /= 3 . and . size ( cla % patterns ) /= 2 ) then write ( stderr , \"(a, i0, a)\" ) \"Three arguments are expected, but \" , size ( cla % patterns ), \" were given.\" stop else if ( cla % patterns ( 2 )% p /= OP_MATCH . and . cla % patterns ( 2 )% p /= OP_IN ) then write ( stderr , \"(a)\" ) \"Operator \" // OP_MATCH // \" or \" // OP_IN // \" are expected, but \" // cla % patterns ( 2 )% p // \" was given.\" stop end if if ( cla % patterns ( 2 )% p == OP_MATCH ) then is_exactly = . true . else if ( cla % patterns ( 2 )% p == OP_IN ) then is_exactly = . false . else write ( stderr , '(a)' ) \"Unknown operator: \" // cla % patterns ( 2 )% p end if else call print_help_find_match end if if ( size ( cla % patterns ) == 2 ) then text = '' else text = cla % patterns ( 3 )% p end if select case ( cla % sub_sub_cmd % get_name ()) case ( ENGINE_LAZY_DFA ) call do_find_match_lazy_dfa ( cla % flags , cla % patterns ( 1 )% p , text , is_exactly ) case ( ENGINE_DENSE_DFA ) call do_find_match_dense_dfa ( cla % flags , cla % patterns ( 1 )% p , text , is_exactly ) case ( ENGINE_FORGEX_API ) call do_find_match_forgex ( cla % flags , cla % patterns ( 1 )% p , text , is_exactly ) case default call print_help_find_match end select end subroutine cla__do_find_subc !=====================================================================!s subroutine cla__get_patterns ( cla , offset ) implicit none class ( cla_t ), intent ( inout ) :: cla integer , intent ( in ) :: offset integer :: i , j , k integer , allocatable :: idx (:) j = 0 outer : do i = offset , cla % arg_info % argc ! if ( i <= maxval ( cla % flag_idx )) then do k = 1 , ubound ( cla % flags , dim = 1 ) if ( i == cla % flag_idx ( k )) cycle outer end do end if j = j + 1 if (. not . allocated ( idx )) then idx = [ i ] cycle end if idx = [ idx , i ] end do outer if ( j == 0 ) return allocate ( cla % patterns ( j )) do i = 1 , j cla % patterns ( i )% p = cla % arg_info % arg ( idx ( i ))% v end do end subroutine cla__get_patterns subroutine cla__collect_flags ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla type ( arg_element_t ), allocatable :: input_flags (:) integer :: n , i , j , k integer , allocatable :: indices (:) character ( * ), parameter :: pattern_long = \"(--)(\\w+-?)+\" character ( * ), parameter :: pattern_short = \"-\\w+\" n = cla % arg_info % argc allocate ( input_flags ( n )) allocate ( indices ( n )) indices (:) = 0 ! Scan all command line arguments j = 0 do i = 1 , n if (( pattern_long . match . cla % arg_info % arg ( i )% v ) & . or . ( pattern_short . match . cla % arg_info % arg ( i )% v )) then ! If the CLA in question is a flag, register the CLA to input_flags array ! and record the index in indices array. j = j + 1 ! increment input_flags ( j )% v = cla % arg_info % arg ( i )% v indices ( j ) = i end if end do ! If there are no flags, return immediately. if ( j == 0 ) return ! Register flags to cla object, ! stop the program if invalid flags are found. do k = 1 , j if ( input_flags ( k ) . in . all_flags ) then i = get_flag_index ( input_flags ( k ), all_flags ) cla % flags ( i ) = . true . cla % flag_idx ( i ) = indices ( k ) else write ( stderr , fmta ) \"invalid option \" // \"'\" // input_flags ( k )% v // \"'\" stop end if end do end subroutine subroutine cla__initialize ( cla ) implicit none class ( cla_t ), intent ( inout ) :: cla call get_arg_command_line ( cla % arg_info % argc , cla % arg_info % arg , cla % arg_info % entire ) cla % flags = . false . cla % flag_idx = - 1 call init_flags call init_commands end subroutine cla__initialize end module forgex_cli_cla_m","tags":"","loc":"sourcefile/cli_cla_m.f90.html"},{"title":"cli_api_internal_no_opts_m.f90 – Forgex-CLI","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_api_internal_no_opts_m module is a part of Forgex. ! module forgex_cli_api_internal_no_opts_m use :: forgex_automaton_m use :: forgex_parameters_m use :: forgex_utf8_m implicit none contains !> This procedure reads a text, performs regular expression matching using an automaton, !> and stores the string index in the argument if it contains a match. subroutine do_matching_including_no_literal_opts ( automaton , string , from , to ) use :: forgex_utility_m implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: string integer , intent ( inout ) :: from , to integer :: cur_i , dst_i ! current and destination index of DFA nodes integer :: ci ! character index integer :: next_ci ! next character index integer :: max_match ! maximum value of match attempts integer :: start ! starting character index integer :: i character (:), allocatable :: str str = string from = 0 to = 0 str = char ( 0 ) // string // char ( 0 ) cur_i = automaton % initial_index if ( cur_i == DFA_NOT_INIT ) then error stop \"DFA have not been initialized.\" end if if ( len ( string ) <= 1 . and . string == '' ) then if ( automaton % dfa % nodes ( cur_i )% accepted ) then from = ACCEPTED_EMPTY to = ACCEPTED_EMPTY end if return end if loop_init : block i = 1 start = i end block loop_init do while ( start < len ( str )) max_match = 0 ci = start cur_i = automaton % initial_index ! Traverse the DFA with the input string from the current starting position of ``cur_i`. do while ( cur_i /= DFA_INVALID_INDEX ) if ( automaton % dfa % nodes ( cur_i )% accepted . and . ci /= start ) then max_match = ci end if if ( ci > len ( str )) exit next_ci = idxutf8 ( str , ci ) + 1 call automaton % construct ( cur_i , dst_i , str ( ci : next_ci - 1 )) cur_i = dst_i ci = next_ci end do ! Update match position if a match is found. if ( max_match > 0 ) then from = start - 1 if ( from == 0 ) from = 1 ! handle leading NULL character. if ( max_match >= len ( str )) then to = len ( string ) else to = max_match - 2 end if return end if start = idxutf8 ( str , start ) + 1 ! Bruteforce searching end do end subroutine do_matching_including_no_literal_opts !> This subroutine is intended to be called from the `forgex_cli_find_m` module. subroutine do_matching_exactly_no_literal_opts ( automaton , string , res ) implicit none type ( automaton_t ), intent ( inout ) :: automaton character ( * ), intent ( in ) :: string logical , intent ( inout ) :: res integer :: cur_i , dst_i ! current and destination index of DFA nodes integer :: ci ! character index integer :: next_ci ! next character index integer :: max_match ! character (:), allocatable :: str ! Initialize `cur_i` with automaton's initial index. cur_i = automaton % initial_index ! If the DFA have not been initialized, abort the program. if ( cur_i == DFA_NOT_INIT ) then error stop \"DFA have not been initialized.\" end if ! If the input string is an empty string, returns a logical value ! indicating whether the current state is accepting or not. if ( len ( string ) == 0 ) then res = automaton % dfa % nodes ( cur_i )% accepted return end if ! Initialize counter variables. max_match = 0 ci = 1 str = char ( 0 ) // string // char ( 0 ) ! Loop and proceed with matching unless the current index is DFA_INVALID_INDEX. do while ( cur_i /= DFA_INVALID_INDEX ) ! If the current state acceptable, the value of `max_match` is updated with `i`. if ( automaton % dfa % nodes ( cur_i )% accepted ) then max_match = ci end if if ( ci > len ( str )) exit ! Get the index of the next character and assign it to `next_ci`. next_ci = idxutf8 ( str , ci ) + 1 ! Lazy evaluation is performed by calling this procedure here. ! The index of destination DFA node is stored in the `dst_i` variable. call automaton % construct ( cur_i , dst_i , str ( ci : next_ci - 1 )) ! If there is mismatch in the first byte of the NULL character, try again with the second byte. if ( dst_i == DFA_INVALID_INDEX . and . ci == 1 ) then ci = 2 next_ci = idxutf8 ( str , ci ) + 1 call automaton % construct ( cur_i , dst_i , str ( ci : next_ci - 1 )) end if ! update counters cur_i = dst_i ci = next_ci end do ! If the maximum index of the match is one larger than length of the string, ! this function returns true, otherwise it returns false. if ( max_match >= len ( string ) + 2 ) then res = . true . else res = . false . end if end subroutine do_matching_exactly_no_literal_opts end module forgex_cli_api_internal_no_opts_m","tags":"","loc":"sourcefile/cli_api_internal_no_opts_m.f90.html"},{"title":"cli_parameter_m.f90 – Forgex-CLI","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_parameter_m module is a part of Forgex. ! module forgex_cli_parameters_m implicit none private !> Number of flags (without value) that forgex-cli accepts. integer , parameter , public :: NUM_FLAGS = 5 !> Number of sub-command that forgec-cli accepts. integer , parameter , public :: NUM_CMD = 2 !> Length integer , parameter , public :: LEN_CMD = 16 !> Number of digits for time display. integer , parameter , public :: NUM_DIGIT_TIME = 13 !> Maximum langth of table field name. integer , parameter , public :: NUM_DIGIT_KEY = 32 !> Maximum length of an environment variable's value. integer , parameter , public :: LEN_ENV_VAR = 255 !> The buffer length of displaying the AST. integer , parameter , public :: TREE_BUFF_LEN = 2 ** 16 !---------------------------------------------------------------------! !> Name of the subcommand debug. character ( * ), parameter , public :: CMD_DEBUG = \"debug\" !> The number of sub-subcommands that debug accepts. integer , parameter , public :: NUM_SUBC_DEBUG = 2 !> Name of the sub-subcommand ast. character ( * ), parameter , public :: SUBC_AST = \"ast\" !> Name of the sub-subcommand thompson. character ( * ), parameter , public :: SUBC_THOMPSON = \"thompson\" !---------------------------------------------------------------------! !> Name of the subcommand find. character ( * ), parameter , public :: CMD_FIND = \"find\" integer , parameter , public :: NUM_SUBC_FIND = 1 character ( * ), parameter , public :: SUBC_MATCH = \"match\" integer , parameter , public :: NUM_SUBSUBC_MATCH = 3 character ( * ), parameter , public :: ENGINE_LAZY_DFA = \"lazy-dfa\" character ( * ), parameter , public :: ENGINE_DENSE_DFA = \"dense\" character ( * ), parameter , public :: ENGINE_FORGEX_API = \"forgex\" !---------------------------------------------------------------------! !> Name of the sub-subcommand lazy dfa character ( * ), parameter , public :: OP_MATCH = \".match.\" character ( * ), parameter , public :: OP_IN = \".in.\" !> String to indicate invalidity if no short flag is present. character ( * ), parameter , public :: INVALID_FLAG = \"INVALID\" !> Output format for displaying an integer in tables. character ( * ), parameter , public :: fmt_out_int = \"(a, i10)\" character ( * ), parameter , public :: fmt_out_ratio = \"(a, i10, '/', i0)\" character ( * ), parameter , public :: fmt_out_char = \"(a, 1x, a)\" character ( * ), parameter , public :: fmt_out_time = \"(a, a15)\" character ( * ), parameter , public :: fmt_out_logi = \"(a, l10)\" character ( * ), parameter , public :: not_running = \"not running\" !> Format for outputting text only. character ( * ), parameter , public :: fmta = \"(a)\" !> Line ending characters for Windows OS character ( * ), parameter , public :: CRLF = char ( 13 ) // char ( 10 ) !> Line Feed. character ( * ), parameter , public :: LF = char ( 10 ) !> Headers character ( * ), parameter , public :: HEADER_NFA = \"========== Thompson NFA ===========\" character ( * ), parameter , public :: HEADER_DFA = \"=============== DFA ===============\" character ( * ), parameter , public :: FOOTER = \"===================================\" end module forgex_cli_parameters_m","tags":"","loc":"sourcefile/cli_parameter_m.f90.html"},{"title":"cli_utils_m.f90 – Forgex-CLI","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_utils_m module is a part of Forgex. ! module forgex_cli_utils_m use , intrinsic :: iso_fortran_env , only : int32 , real64 , stderr => error_unit use :: forgex_cli_parameters_m , only : LEN_ENV_VAR , NUM_FLAGS , INVALID_FLAG , LEN_CMD use forgex_cli_type_m , only : arg_element_t , flag_t , cmd_t implicit none private public :: right_justify public :: operator (. in .) interface operator (. in .) module procedure :: does_flag_exist module procedure :: does_command_exist module procedure :: does_command_exist_type_cmd module procedure :: is_arg_contained_in_flags end interface public :: get_arg_command_line public :: get_flag_index public :: register_flag public :: register_cmd public :: get_os_type public :: info public :: text_highlight_green contains function get_os_type () result ( res ) use :: forgex , only : operator (. in .) use :: forgex_enums_m implicit none integer :: res integer , save :: res_save logical , save :: is_first = . true . character ( LEN_ENV_VAR ) :: val1 , val2 integer :: len1 , len2 , stat1 , stat2 if (. not . is_first ) then res = res_save return end if res = OS_UNKNOWN call get_environment_variable ( name = 'OS' , value = val1 , length = len1 , status = stat1 ) if ( stat1 == 0 . and . len1 > 0 ) then if ( \"Windows_NT\" . in . val1 ) then res_save = OS_WINDOWS res = res_save is_first = . false . return end if end if call get_environment_variable ( name = 'OSTYPE' , value = val2 , length = len2 , status = stat2 ) if ( stat2 == 0 . and . len2 > 0 ) then !! @todo end if end function get_os_type function get_flag_index ( arg , flags ) result ( res ) implicit none type ( arg_element_t ), intent ( in ) :: arg type ( flag_t ), intent ( in ) :: flags (:) integer :: res integer :: i res = - 1 do i = 1 , NUM_FLAGS if ( arg % v == flags ( i )% long_f . or . arg % v == flags ( i )% short_f ) then res = i return end if end do end function get_flag_index function is_arg_contained_in_flags ( arg , flags ) result ( res ) implicit none type ( arg_element_t ), intent ( in ) :: arg type ( flag_t ), intent ( in ) :: flags (:) logical :: res integer :: i res = . false . do i = 1 , ubound ( flags , dim = 1 ) res = res & . or . flags ( i )% long_f == arg % v & . or . flags ( i )% short_f == arg % v if ( res ) return end do end function is_arg_contained_in_flags subroutine get_arg_command_line ( argc , arg , entire ) implicit none integer ( int32 ), intent ( inout ) :: argc ! argc type ( arg_element_t ), allocatable , intent ( inout ) :: arg (:) character (:), allocatable , intent ( inout ) :: entire integer :: i , len_ith , entire_len argc = command_argument_count () call get_command ( length = entire_len ) allocate ( character ( entire_len ) :: entire ) call get_command ( command = entire ) allocate ( arg ( 0 : argc )) do i = 0 , argc ! Get length of i-th command line argmuemnt. call get_command_argument ( number = i , length = len_ith ) ! Allocate str(i)%v of the same length as the i-th argument. allocate ( character ( len_ith ) :: arg ( i )% v ) ! Get the value of the i-th argument as a string. call get_command_argument ( number = i , value = arg ( i )% v ) end do end subroutine get_arg_command_line !=====================================================================! pure function does_command_exist ( arg , cmd_list ) result ( res ) implicit none character ( * ), intent ( in ) :: arg character ( LEN_CMD ), intent ( in ) :: cmd_list (:) logical :: res integer :: i res = . false . do i = lbound ( cmd_list , dim = 1 ), ubound ( cmd_list , dim = 1 ) res = res . or . trim ( arg ) == trim ( cmd_list ( i )) if ( res ) return end do end function does_command_exist pure function does_command_exist_type_cmd ( arg , cmd_list ) result ( res ) implicit none character ( * ), intent ( in ) :: arg type ( cmd_t ), intent ( in ) :: cmd_list (:) logical :: res integer :: i res = . false . do i = lbound ( cmd_list , dim = 1 ), ubound ( cmd_list , dim = 1 ) res = res . or . trim ( arg ) == trim ( cmd_list ( i )% get_name ()) if ( res ) return end do end function does_command_exist_type_cmd pure function does_flag_exist ( arg , flag_list ) result ( res ) implicit none character ( * ), intent ( in ) :: arg type ( flag_t ), intent ( in ) :: flag_list (:) logical :: res integer :: i res = . false . do i = lbound ( flag_list , dim = 1 ), ubound ( flag_list , dim = 1 ) res = res & . or . trim ( arg ) == trim ( flag_list ( i )% short_f ) & . or . trim ( arg ) == trim ( flag_list ( i )% long_f ) if ( res ) return end do end function does_flag_exist subroutine register_flag ( flag , name , long , short ) implicit none type ( flag_t ), intent ( inout ) :: flag character ( * ), intent ( in ) :: name character ( * ), intent ( in ) :: long character ( * ), intent ( in ), optional :: short flag % name = name flag % long_f = long if ( present ( short )) then flag % short_f = short else flag % short_f = INVALID_FLAG end if end subroutine subroutine register_cmd ( cmd , name ) implicit none type ( cmd_t ), intent ( inout ) :: cmd character ( * ), intent ( in ) :: name call cmd % set_name ( name ) end subroutine register_cmd subroutine right_justify ( array ) use :: forgex_cli_parameters_m , only : NUM_DIGIT_KEY implicit none character ( NUM_DIGIT_KEY ), intent ( inout ) :: array (:) character ( NUM_DIGIT_KEY ), allocatable :: buff (:) integer :: i , max_len allocate ( buff ( size ( array , dim = 1 ))) buff (:) = array (:) max_len = 0 do i = 1 , size ( buff ) max_len = max ( max_len , len_trim ( adjustl ( buff ( i )))) end do ! right justify do i = 1 , size ( buff ) buff ( i ) = adjustl ( array ( i )) buff ( i ) = repeat ( ' ' , max_len - len_trim ( buff ( i ))) // buff ( i ) end do array (:) = buff (:) end subroutine subroutine info ( str ) implicit none character ( * ), intent ( in ) :: str write ( stderr , '(a)' ) \"[info]: \" // str end subroutine info function text_highlight_green ( string , from , to ) result ( res ) implicit none character ( * ), intent ( in ) :: string integer ( int32 ), intent ( in ) :: from , to character (:), allocatable :: res character ( 5 ) :: green = char ( 27 ) // \"[32m\" character ( 5 ) :: hend = char ( 27 ) // \"[39m\" character ( 4 ) :: bold = char ( 27 ) // \"[1m\" character ( 4 ) :: bend = char ( 27 ) // \"[0m\" res = '' if ( from > 0 . and . to > 0 . and . from <= to . and . len ( string ) > 0 ) then res = string ( 1 : from - 1 ) // green // bold // string ( from : to ) // bend // hend // string ( to + 1 : len ( string )) else res = string end if end function text_highlight_green end module forgex_cli_utils_m","tags":"","loc":"sourcefile/cli_utils_m.f90.html"},{"title":"cli_memory_calculation_m.f90 – Forgex-CLI","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_memory_calculation_m module is a part of Forgex. ! module forgex_cli_memory_calculation_m use :: forgex_parameters_m , only : NFA_STATE_BASE implicit none private public :: mem_tape public :: mem_tree public :: mem_nfa_graph public :: mem_dfa_graph contains function mem_tape ( tape ) result ( res ) use :: forgex_syntax_tree_node_m implicit none type ( tape_t ), intent ( in ) :: tape integer :: res res = len ( tape % str ) res = res + 12 end function mem_tape function mem_tree ( tree ) result ( res ) use :: forgex_syntax_tree_node_m implicit none type ( tree_node_t ), intent ( in ) :: tree (:) integer :: res , sum_c , i res = size ( tree , dim = 1 ) * 6 * 4 ! 5 int32, 1 logical sum_c = 0 do i = lbound ( tree , dim = 1 ), ubound ( tree , dim = 1 ) if ( allocated ( tree ( i )% c )) then sum_c = sum_c + size ( tree ( i )% c ) * 8 ! 8bytes per segment end if end do res = res + sum_c end function mem_tree function mem_nfa_graph ( graph ) result ( res ) use :: forgex_nfa_graph_m implicit none type ( nfa_graph_t ), intent ( in ) :: graph integer :: res , sum_node , sum_tra , i , j res = 12 ! 3 int32 sum_node = 0 do i = NFA_STATE_BASE , graph % nfa_top sum_node = sum_node + 5 * 4 ! 5 int32 sum_tra = 0 if (. not . allocated ( graph % nodes ( i )% forward )) cycle b : do j = lbound ( graph % nodes ( i )% forward , dim = 1 ), ubound ( graph % nodes ( i )% forward , dim = 1 ) if (. not . allocated ( graph % nodes ( i )% forward )) cycle b sum_tra = sum_tra + 4 * 4 ! 3 int32, 1 logical if ( allocated ( graph % nodes ( i )% forward ( j )% c )) then sum_tra = sum_tra + 8 * size ( graph % nodes ( i )% forward ( j )% c ) end if end do b sum_node = sum_node + sum_tra * 2 ! forward and backward end do res = res + sum_node res = res + ( ubound ( graph % nodes , dim = 1 ) - graph % nfa_top ) * 5 ! 5 int32 end function mem_nfa_graph function mem_dfa_graph ( graph ) result ( res ) use :: forgex_lazy_dfa_graph_m implicit none type ( dfa_graph_t ), intent ( in ) :: graph integer :: res , sum_node , sum_tra , i , j res = 16 ! 4 int32 sum_node = 0 do i = 1 , graph % dfa_top - 1 sum_node = sum_node + 6 * 4 ! 3 int32, 3 logical if ( allocated ( graph % nodes ( i )% nfa_set % vec )) then sum_node = sum_node + size ( graph % nodes ( i )% nfa_set % vec ) * 4 ! logical vector end if sum_tra = 0 inner : do j = 1 , graph % nodes ( i )% get_tra_top () sum_tra = sum_tra + 8 + 4 * 2 ! segment + 2 int32 if (. not . allocated ( graph % nodes ( i )% transition )) cycle inner if ( allocated ( graph % nodes ( i )% transition ( j )% nfa_set % vec )) then sum_tra = sum_tra + size ( graph % nodes ( i )% transition ( j )% nfa_set % vec ) * 4 end if end do inner sum_node = sum_node + sum_tra end do res = res + sum_node res = res + ( ubound ( graph % nodes , dim = 1 ) - graph % dfa_top ) * 6 * 4 ! 3 int32, 3 logical end function mem_dfa_graph end module forgex_cli_memory_calculation_m","tags":"","loc":"sourcefile/cli_memory_calculation_m.f90.html"},{"title":"cli_debug_m.f90 – Forgex-CLI","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_debug_m module is a part of Forgex. ! module forgex_cli_debug_m use , intrinsic :: iso_fortran_env , only : int32 , real64 , stderr => error_unit , stdout => output_unit use :: forgex_cli_time_measurement_m , only : time_begin , time_lap , get_lap_time_in_appropriate_unit use :: forgex_cli_parameters_m , only : NUM_DIGIT_KEY , fmt_out_time , fmt_out_int , fmt_out_ratio , & fmt_out_logi , fmta , fmt_out_char , CRLF , LF , HEADER_DFA , HEADER_NFA , FOOTER use :: forgex_enums_m , only : FLAG_HELP , FLAG_NO_TABLE , FLAG_VERBOSE , FLAG_TABLE_ONLY , OS_WINDOWS use :: forgex_cli_utils_m , only : get_os_type , right_justify use :: forgex_cli_help_messages_m , only : print_help_debug_ast , print_help_debug_thompson implicit none private public :: do_debug_ast public :: do_debug_thompson contains subroutine do_debug_ast ( flags , pattern ) use :: forgex_syntax_tree_graph_m use :: forgex_syntax_tree_optimize_m use :: forgex_cli_memory_calculation_m implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern type ( tree_t ) :: tree integer :: root integer :: uni , ierr , siz character (:), allocatable :: buff character (:), allocatable :: ast , prefix , suffix , entire !, middle real ( real64 ) :: lap1 , lap2 if ( flags ( FLAG_HELP )) call print_help_debug_ast call time_begin call tree % build ( trim ( pattern )) lap1 = time_lap () entire = get_entire_literal ( tree ) prefix = get_prefix_literal ( tree ) ! middle = get_middle_literal(tree) suffix = get_suffix_literal ( tree ) lap2 = time_lap () open ( newunit = uni , status = 'scratch' ) call tree % print ( uni ) inquire ( unit = uni , size = siz ) allocate ( character ( siz + 2 ) :: buff ) rewind ( uni ) read ( uni , fmta , iostat = ierr ) buff close ( uni ) ast = trim ( buff ) output : block character ( NUM_DIGIT_KEY ) :: parse_time , literal_time , tree_count , tree_allocated , & memory , literal_pre , literal_post , literal_all , literal_mid character ( NUM_DIGIT_KEY ) :: cbuff ( 9 ) integer :: i parse_time = \"parse time:\" literal_time = \"extract time:\" tree_count = \"tree node count:\" tree_allocated = \"tree node allocated:\" literal_all = \"extracted literal:\" literal_pre = \"extracted prefix:\" literal_mid = \"extracted middle:\" literal_post = \"extracted suffix:\" memory = \"memory (estimated):\" if ( flags ( FLAG_VERBOSE )) then cbuff = [ parse_time , literal_time , literal_all , literal_pre , literal_mid , literal_post , & memory , tree_count , tree_allocated ] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_char ) trim ( cbuff ( 3 )), entire write ( stdout , fmt_out_char ) trim ( cbuff ( 4 )), prefix ! write(stdout, fmt_out_char) trim(cbuff(5)), middle write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), suffix write ( stdout , fmt_out_int ) trim ( cbuff ( 7 )), mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) write ( stdout , fmt_out_int ) trim ( cbuff ( 8 )), root write ( stdout , fmt_out_int ) trim ( cbuff ( 9 )), size ( tree % nodes , dim = 1 ) else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff = [ parse_time , literal_time , literal_all , literal_pre , literal_mid , & literal_post , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 2 )] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_char ) trim ( cbuff ( 3 )), entire write ( stdout , fmt_out_char ) trim ( cbuff ( 4 )), prefix ! write(stdout, fmt_out_char) trim(cbuff(5)), middle write ( stdout , fmt_out_char ) trim ( cbuff ( 6 )), suffix write ( stdout , fmt_out_int ) trim ( cbuff ( 7 )), mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) end if end block output if ( flags ( FLAG_TABLE_ONLY )) return write ( stdout , fmta ) ast end subroutine do_debug_ast subroutine do_debug_thompson ( flags , pattern ) use :: forgex_cli_memory_calculation_m use :: forgex_automaton_m use :: forgex_syntax_tree_graph_m implicit none logical , intent ( in ) :: flags (:) character ( * ), intent ( in ) :: pattern type ( tree_t ) :: tree type ( automaton_t ) :: automaton integer :: root integer :: uni , ierr , i character (:), allocatable :: nfa character ( 256 ) :: line real ( real64 ) :: lap1 , lap2 nfa = '' if ( flags ( FLAG_HELP )) call print_help_debug_thompson if ( pattern == '' ) call print_help_debug_thompson call time_begin () ! call build_syntax_tree(trim(pattern), tree%tape, tree, root) call tree % build ( trim ( pattern )) lap1 = time_lap () call automaton % nfa % build ( tree , automaton % nfa_entry , automaton % nfa_exit , automaton % all_segments ) lap2 = time_lap () open ( newunit = uni , status = 'scratch' ) call automaton % nfa % print ( uni , automaton % nfa_exit ) rewind ( uni ) ierr = 0 do while ( ierr == 0 ) read ( uni , fmta , iostat = ierr ) line if ( ierr /= 0 ) exit if ( get_os_type () == OS_WINDOWS ) then nfa = nfa // trim ( line ) // CRLF else nfa = nfa // trim ( line ) // LF end if end do close ( uni ) output : block character ( NUM_DIGIT_KEY ) :: parse_time , nfa_time , memory , nfa_count , nfa_allocated , tree_count , tree_allocated character ( NUM_DIGIT_KEY ) :: cbuff ( 7 ) = '' integer :: memsiz parse_time = \"parse time:\" nfa_time = \"compile nfa time:\" memory = \"memory (estimated):\" nfa_count = \"nfa states:\" nfa_allocated = \"nfa states allocated:\" tree_count = \"tree node count:\" tree_allocated = \"tree node allocated:\" memsiz = mem_tape ( tree % tape ) + mem_tree ( tree % nodes ) & + mem_nfa_graph ( automaton % nfa ) + 4 * 3 if ( allocated ( automaton % entry_set % vec )) then memsiz = memsiz + size ( automaton % entry_set % vec , dim = 1 ) end if if ( allocated ( automaton % all_segments )) then memsiz = memsiz + size ( automaton % all_segments , dim = 1 ) * 8 end if if ( flags ( FLAG_VERBOSE )) then cbuff = [ parse_time , nfa_time , memory , tree_count , tree_allocated , nfa_count , nfa_allocated ] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_int ) trim ( cbuff ( 3 )), memsiz write ( stdout , fmt_out_int ) trim ( cbuff ( 4 )), root write ( stdout , fmt_out_int ) trim ( cbuff ( 5 )), size ( tree % nodes , dim = 1 ) write ( stdout , fmt_out_int ) trim ( cbuff ( 6 )), automaton % nfa % nfa_top write ( stdout , fmt_out_int ) trim ( cbuff ( 7 )), automaton % nfa % nfa_limit else if ( flags ( FLAG_NO_TABLE )) then continue else cbuff (:) = [ parse_time , nfa_time , memory , ( repeat ( \" \" , NUM_DIGIT_KEY ), i = 1 , 4 )] call right_justify ( cbuff ) write ( stdout , fmt_out_time ) trim ( cbuff ( 1 )), get_lap_time_in_appropriate_unit ( lap1 ) write ( stdout , fmt_out_time ) trim ( cbuff ( 2 )), get_lap_time_in_appropriate_unit ( lap2 ) write ( stdout , fmt_out_int ) trim ( cbuff ( 3 )), memsiz end if if ( flags ( FLAG_TABLE_ONLY )) return write ( stdout , * ) \"\" write ( stdout , fmta ) HEADER_NFA write ( stdout , fmta ) trim ( nfa ) write ( stdout , fmta ) \"Note: all segments of NFA were disjoined with overlapping portions.\" write ( stdout , fmta ) FOOTER end block output end subroutine do_debug_thompson !=====================================================================! end module forgex_cli_debug_m","tags":"","loc":"sourcefile/cli_debug_m.f90.html"},{"title":"cli_type_m.f90 – Forgex-CLI","text":"Source Code ! Fortran Regular Expression (Forgex) ! ! MIT License ! ! (C) Amasaki Shinobu, 2023-2024 !     A regular expression engine for Fortran. !     forgex_cli_type_m module is a part of Forgex. ! module forgex_cli_type_m use :: forgex_cli_parameters_m implicit none private type , public :: arg_element_t character (:), allocatable :: v end type arg_element_t type , public :: arg_t integer :: argc type ( arg_element_t ), allocatable :: arg (:) character (:), allocatable :: entire end type arg_t type , public :: pattern_t character (:), allocatable :: p end type pattern_t type , public :: cmd_t ! command type character ( LEN_CMD ), private :: name = '' character ( LEN_CMD ), allocatable :: subc (:) ! sub-command contains procedure :: get_name => cmd__get_name procedure :: set_name => cmd__set_name end type cmd_t ! option flags, such as '--help', '-h' type , public :: flag_t character ( 32 ) :: name character (:), allocatable :: long_f , short_f end type flag_t contains pure function cmd__get_name ( self ) result ( res ) implicit none class ( cmd_t ), intent ( in ) :: self character (:), allocatable :: res res = trim ( self % name ) end function cmd__get_name pure subroutine cmd__set_name ( self , name ) implicit none class ( cmd_t ), intent ( inout ) :: self character ( * ), intent ( in ) :: name self % name = name end subroutine cmd__set_name end module forgex_cli_type_m","tags":"","loc":"sourcefile/cli_type_m.f90.html"},{"title":"Documentation – Forgex-CLI","text":"Documentation of Forgex These pages explain the usage and development of Forgex-cli. This documentation is available in English and Japanese, but currently work in progress. Please select a topic from the content list on the left.","tags":"","loc":"page/index.html"},{"title":"English/英語 – Forgex-CLI","text":"README This package provides a command line tool which named forgex-cli for interacting with Forgex—Fortran Regular Expression .\nThe forgex-cli command was originally part of Forgex package, but was moved to this separate repository starting with Forgex version 3.5. Installation Getting Source Code Clone the repository: git clone https://github.com/shinobuamasaki/forgex-cli Alternatively, download the latest source package: wget https://github.com/ShinobuAmasaki/forgex-cli/archive/refs/tags/v3.5.tar.gz In that case, decompress the archive file: tar xvzf v3.5.tar.gz Building Change directory to the cloned or decompressed location: cd forgex-cli Execute building with Fortran Package Manager ( fpm ): fpm build This will automatically resolve the dependency and compile forgex-cli , including forgex . Operation Check Operation of this command has been confirmed with the following compilers: GNU Fortran ( gfortran ) v13.2.1 Intel Fortran Compiler ( ifx ) 2024.0.0 20231017 It is assumed that you will use the Fortran Package Manager( fpm ). Usage This article describes basic usage of forgex-cli . Command Line Interface Currently, commands find and debug ,  and following subcommands and sub-subcommands can be executed: forgex-cli\n├── find\n│   └── match\n│       ├── lazy-dfa <pattern> <operator> <input text>\n│       ├── dense <pattern> <operator> <input text>\n│       └── forgex <pattern> <operator> <input text>\n└── debug\n    ├── ast <pattern>\n    └── thompson <pattern> Run the forgex-cli command as follows: forgex-cli <comamnd> <subcommand> ...\nfpm run -- <command> <subcommand> ... Examples find command Using the find command and the match subcommand, you can specify an engine and run benchmark tests on regular expression matching with .in. and .match. operators.\nAfter the subcommand, select the engine from, lazy-dfa , dense , forgex , and after that, specify the pattern, operator, and input string as if you were writing Fortran code using Forgex to perform matching. For instance, execute the find command: forgex-cli find match lazy-dfa '([a-z]*g+)n?' .match. 'assign' If you run it through fpm run : fpm run --profile release -- find match lazy-dfa '([a-z]*g+)n?' .match. 'assign' and you will get output similar to the following: pattern: ([ a - z ] * g + ) n ? text: ' assign ' parse time : 42.9 μ s extract literal time : 23.0 μ s runs engine: T compile nfa time : 26.5 μ s dfa initialize time : 4.6 μ s search time : 617.1 μ s matching result: T automata and tree size: 10324 bytes ========== Thompson NFA =========== state 1 : ( ? , 5 ) state 2 : < Accepted > state 3 : ( n , 2 )( ? , 2 ) state 4 : ( g , 7 ) state 5 : ([ \"a\" - \"f\" ], 6 )( g , 6 )([ \"h\" - \"m\" ], 6 )( n , 6 )([ \"o\" - \"z\" ], 6 )( ? , 4 ) state 6 : ( ? , 5 ) state 7 : ( ? , 8 ) state 8 : ( g , 9 )( ? , 3 ) state 9 : ( ? , 8 ) =============== DFA =============== 1 : [ \"a\" - \"f\" ] => 2 2 : [ \"o\" - \"z\" ] => 2 [ \"h\" - \"m\" ] => 2 g => 3 3 A: n => 4 4 A: state 1 = ( 1 4 5 ) state 2 = ( 4 5 6 ) state 3 A = ( 2 3 4 5 6 7 8 ) state 4 A = ( 2 4 5 6 ) =================================== debug Using debug command allows you to obtain information about the abstract syntax tree and the structure of the Thompson NFA. For example, execute the debug command with ast subcommand: forgex-cli debug ast 'foo[0-9]+bar' then, you will get output similar to the following: parse time : 133 . 8μs extract time : 36 . 8μs extracted literal : extracted prefix : foo extracted suffix : bar memory ( estimated ): 848 ( concatenate ( concatenate ( concatenate ( concatenate ( concatenate ( concatenate \"f\" \"o\" ) \"o\" ) ( concatenate [ \"0\" - \"9\" ; ] ( closure [ \"0\" - \"9\" ; ] ))) \"b\" ) \"a\" ) \"r\" ) Note: Notice also that the prefix and suffix literals are now extracted. Here's how to get a graph of the NFA. To get the Thompson NFA, run the following command: forgex-cli debug thompson 'foo[0-9]+bar' This will give you output like this: parse time:       144.5μs\n  compile nfa time:        57.0μs\nmemory (estimated):     11589\n\n========== Thompson NFA ===========\nstate    1: (f, 8)\nstate    2: <Accepted>\nstate    3: (r, 2)\nstate    4: (a, 3)\nstate    5: (b, 4)\nstate    6: ([\"0\"-\"9\"], 9)\nstate    7: (o, 6)\nstate    8: (o, 7)\nstate    9: (?, 10)\nstate   10: ([\"0\"-\"9\"], 11)(?, 5)\nstate   11: (?, 10)\n\nNote: all segments of NFA were disjoined with overlapping portions.\n=================================== Notes You can get information about available option flags specifying the --help command line argument. If you use this forgex-cli command with PowerShell on Windows, use UTF-8 as your system locale to properly input and output Unicode characters. To do The following features are planned to be implemented in the future: Publish the documentation Support CMake building ✅️ Add a CLI tool for debugging and benchmarking ✅️ Add Time measurement tools (basic) Code Convention All code contained herein shall be written with a three-space indentation. Acknowledgements The command-line interface design of forgex-cli was inspired in part by the package regex-cli of Rust language. References rust-lang/regex/regex-cli License Forgex-CLI is as a freely available under the MIT license. See LICENSE .","tags":"","loc":"page/English/index.html"},{"title":"Japanese/日本語 – Forgex-CLI","text":"README このパッケージは、Fortran Regular Expression (Forgex) を対話的に実行する forgex-cli というコマンドラインツールを提供します。 forgex-cli コマンドはもともとForgexの一部として提供されていましたが、Forgexバージョン3.5より、本リポジトリとして\n分離されました。 動作確認 このソフトウェアの動作は以下のコンパイラで確認されています。 GNU Fortran ( gfortran ) v13.2.1 Intel Fortran Compiler ( ifx ) 2024.0.0 20231017 Fortran Package Manager( fpm )を使用することを前提にしています。 インストール ソースコードの入手 リポジトリをクローンします。 git clone https://github.com/shinobuamasaki/forgex-cli もしくは最新のソースファイルをダウンロードします。 wget https://github.com/ShinobuAmasaki/forgex-cli/archive/refs/tags/v3.5.tar.gz この場合は、ダウンロードしたアーカイブファイルを展開します。 tar xvzf v3.5.tar.gz ビルド クローン、もしくは展開されたディレクトリに移動します。 cd forgex-cli Fortran Package Managerの fpm コマンドを使用してビルドを実行します。 fpm build これにより、依存関係が自動的に解決され、Forgexを含む forgex-cli がコンパイルされます。\nビルド後は fpm run コマンドを使用して、 forgex-cli を実行することができます。 PATHの通ったディレクトリにインストールする場合は、 fpm install を実行してください。\n例えば次のようにします。 fpm install --prefix /usr/local なお、 fpm build や fpm install では --profile release オプションを指定して、最適化オプション等を有効にして\nビルド及びインストールすることができます。 使い方 この記事では、 forgex-cli コマンドの基本的な使い方について解説します。 コマンドライン・インターフェイス 現在、 find と debug のコマンドと、以下のサブコマンド等が実行可能です。 forgex-cli\n├── find\n│    └── match\n│         ├── lazy-dfa <pattern> <operator> <input text>\n│         ├── dense <pattern> <operator> <input text>\n│         └── forgex <pattern> <operator> <input text>\n└── debug\n      ├── ast <pattern>\n      └── thompson <pattern> forgex-cli のコマンドは次のように実行します forgex-cli <command> <subcommand> ...\nfpm run -- <command> <subcommand> ... 使用例 find コマンド find コマンドと match サブコマンドを使用すると、エンジンを指定して、 .in. と .match. 演算子を用いた正規表現マッチングのベンチマークテストを実行することができます。 サブコマンドの後ろに、以下のエンジンのいずれかを指定します。\n- lazy-dfa - dense - forgex さらにその後ろには、正規表現パターン、演算子、入力テキストの順に、Forgexを使ってFortranコードを書くのと同じように指定します。\n例えば、次のようになります。 forgex-cli find match lazy-dfa '([a-z]*g+)n?' .match. 'assign' もしくは、 fpm run を介して実行することもできます。 fpm run -- find match lazy-dfa '([a-z]*g+)n?' .match. 'assign' いずれかを実行すると、以下のような実行結果が得られます。 pattern: ([ a - z ] * g + ) n ? text: ' assign ' parse time : 42.9 μ s extract literal time : 23.0 μ s runs engine: T compile nfa time : 26.5 μ s dfa initialize time : 4.6 μ s search time : 617.1 μ s matching result: T automata and tree size: 10324 bytes ========== Thompson NFA =========== state 1 : ( ? , 5 ) state 2 : < Accepted > state 3 : ( n , 2 )( ? , 2 ) state 4 : ( g , 7 ) state 5 : ([ \"a\" - \"f\" ], 6 )( g , 6 )([ \"h\" - \"m\" ], 6 )( n , 6 )([ \"o\" - \"z\" ], 6 )( ? , 4 ) state 6 : ( ? , 5 ) state 7 : ( ? , 8 ) state 8 : ( g , 9 )( ? , 3 ) state 9 : ( ? , 8 ) =============== DFA =============== 1 : [ \"a\" - \"f\" ] => 2 2 : [ \"o\" - \"z\" ] => 2 [ \"h\" - \"m\" ] => 2 g => 3 3 A: n => 4 4 A: state 1 = ( 1 4 5 ) state 2 = ( 4 5 6 ) state 3 A = ( 2 3 4 5 6 7 8 ) state 4 A = ( 2 4 5 6 ) =================================== debug コマンド debug コマンドを使用すると、正規表現から構築された抽象構文木（AST）や非決定性有限オートマトン（NFA）の情報を得ることができます。 例えば、 debug コマンドと ast サブコマンドに、正規表現パターン foo[0-9]+bar を与えて実行します。 forgex-cli debug ast 'foo[0-9]+bar' そうすると、以下のように出力され、ASTの構造を知ることができます。 parse time : 133 . 8μs extract time : 36 . 8μs extracted literal : extracted prefix : foo extracted suffix : bar memory ( estimated ): 848 ( concatenate ( concatenate ( concatenate ( concatenate ( concatenate ( concatenate \"f\" \"o\" ) \"o\" ) ( concatenate [ \"0\" - \"9\" ; ] ( closure [ \"0\" - \"9\" ; ] ))) \"b\" ) \"a\" ) \"r\" ) 次にNFAの情報を得るには、 debug コマンドと thompson サブコマンドを指定して、パターンを与えます。 forgex-cli debug thompson 'foo[0-9]+bar' このコマンドの出力は、次のようになります。 parse time:       144.5μs\n  compile nfa time:        57.0μs\nmemory (estimated):     11589\n\n========== Thompson NFA ===========\nstate    1: (f, 8)\nstate    2: <Accepted>\nstate    3: (r, 2)\nstate    4: (a, 3)\nstate    5: (b, 4)\nstate    6: ([\"0\"-\"9\"], 9)\nstate    7: (o, 6)\nstate    8: (o, 7)\nstate    9: (?, 10)\nstate   10: ([\"0\"-\"9\"], 11)(?, 5)\nstate   11: (?, 10)\n\nNote: all segments of NFA were disjoined with overlapping portions.\n=================================== 注意 コマンドライン引数に --help を指定すると、使用可能なオプションフラグに関する情報を取得できます。 コマンドラインツール forgex-cli をWindows上のPowerShellで利用する場合、Unicode文字を正しく入出力するには、システムのロケールをUTF-8に変更する必要があります。 To Do ドキュメントの公開 CMakeによるビルドのサポート ✅️ デバッグおよびベンチマーク用のCLIツールを追加 ✅️ 簡単な時間計測ツールの追加 コーディング規約 本プロジェクトに含まれるすべてのコードは、3スペースのインデントで記述されます。 謝辞 forgex-cli のコマンドラインインターフェイスの設計については、Rust言語の regex-cli を参考にしました。 参考文献 rust-lang/regex/regex-cli ライセンス このプロジェクトはMITライセンスで提供されるフリーソフトウェアです\n（cf. LICENSE ）。","tags":"","loc":"page/Japanese/index.html"}]}